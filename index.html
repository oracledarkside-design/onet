<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <link rel="manifest" href="manifest.json">
  <link rel="icon" href="favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>Головоломка</title> 

  <style>
  /* Базовый контейнер загрузчика */
  #game-loader {
    position: fixed;
    inset: 0; /* top:0; right:0; bottom:0; left:0; */
    /*display: none; /* по умолчанию скрыт — показываем через showLoader() */
    align-items: center;
    justify-content: center;
    background: rgba(10, 12, 14);
    z-index: 9999;
    -webkit-font-smoothing: antialiased;
    /*font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;*/
  }

  /* Внутренний контейнер для центровки и подписи */
  .loader-inner {
    display: flex;
    flex-direction: column;
    gap: 16px;
    align-items: center;
    justify-content: center;
  }

  /* Белый "кубик" — квадрат с лёгкой 3D-подсказкой и мягкой анимацией */
  .cube {
    width: 44px;
    height: 44px;
    background: linear-gradient(180deg, #ffffff 0%, #f0f0f0 100%);
    border-radius: 6px;
    box-shadow:
      0 10px 20px rgba(0,0,0,0.35),
      0 2px 6px rgba(0,0,0,0.18);
    transform: rotateX(18deg) rotateY(-18deg);
    /* анимация: плавное появление/исчезание + лёгкое качание/масштаб */
    animation: cube-pulse 1.2s ease-in-out infinite;
    will-change: opacity, transform;
  }

  /* Мелкий декоративный отблеск на кубике */
  .cube::before {
    content: "";
    position: absolute;
    pointer-events: none;
    width: 44px;
    height: 44px;
    border-radius: 6px;
    background: linear-gradient(135deg, rgba(255,255,255,0.85) 0%, rgba(255,255,255,0.05) 50%);
    mix-blend-mode: screen;
    transform: translateZ(1px);
    opacity: 0.85;
  }

  /* Подпись (необязательно отображать, можно скрыть в продакшне) */
  .loader-label {
    color: #e6e7e9;
    font-size: 13px;
    letter-spacing: 0.2px;
    opacity: 1;
  }

  /* Ключевые кадры: мягкий пульс и небольшая ротация */
  @keyframes cube-pulse {
    0% {
      opacity: 0.18;
      transform: rotateX(16deg) rotateY(-16deg) scale(0.98);
    }
    25% {
      opacity: 0.9;
      transform: rotateX(18deg) rotateY(-18deg) scale(1.02);
    }
    50% {
      opacity: 1;
      transform: rotateX(20deg) rotateY(-20deg) scale(1.00);
    }
    75% {
      opacity: 0.9;
      transform: rotateX(18deg) rotateY(-18deg) scale(1.01);
    }
    100% {
      opacity: 0.18;
      transform: rotateX(16deg) rotateY(-16deg) scale(0.98);
    }
  }

  /* Адаптив: чуть меньше на узких экранах */
  @media (max-width: 420px) {
    .cube { width: 34px; height: 34px; border-radius: 5px; }
    .loader-label { font-size: 12px; }
  }
</style>
  <style> /*времееное решение в мета max-width=device-width, initial-scale=0.95, maximum-scale=0.99,*/
    :root {
      --width: 10;                /* редактируемо: ширина поля */
      --height: 10;              /* редактируемо: высота поля */
      /*--cell: 56px;             /* размер клетки */
      /*--gap: 6px;                /* отступ между клетками */
      --hl: 120,180,255;        /* базовый цвет подсветки (RGB) */
        --board-padding: 10px; 
          --color-accent-1: #64e0d0;
          --color-accent-1-SCRLBR: #64e0d0 #1a2130;
          --color-accent-2: #4a4a4a;
          --color-accent-2-SCRLBR: #4a4a4a #1a2130;
    }

    body {
      margin: 0; padding: 0px; background: #0c0f14; color: #e9ecf1;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
     
    }

    html { height: 100%; overscroll-behavior: none; }
    body { overscroll-behavior: none; }
    * { -webkit-tap-highlight-color: transparent; }


    /*.pulse-same {will-change: background-color;}*/

    .game {
      display: grid; grid-template-columns: 1fr; row-gap: 5px; max-width: calc(
    var(--width) * var(--cell) +
    (var(--width) - 1) * var(--gap) +
    2 * var(--board-padding)
  );
     /* min-width: 100%; /*Улучшение CLS*/ 
      margin: 0 auto; 
    }

    .hud { display:flex; align-items:center; justify-content:space-between; gap:12px; }
    .hud .badge { padding: 6px 10px; background:#1a2130; border:1px solid #283248; border-radius: 10px; font-size: 12px; opacity:.9; }

    #board {
      display: grid;
      grid-template-columns: repeat(var(--width), var(--cell));
      grid-auto-rows: var(--cell);
      gap: var(--gap);
      position: relative;
      padding: var(--board-padding); box-sizing: border-box;  border-radius: 16px; background: #0f1522; box-shadow: inset 0 0 0 1px #1f2940, 0 10px 30px rgba(0,0,0,.4);
      transition: filter .2s ease, opacity .2s ease; 
      width: fit-content; 
      
    }

    /* Отключаем прокрутку/растяжение при жестах, включаем точные pointer события на мобильных */
    #board { touch-action: none; overscroll-behavior: contain; }

    #board.dimmed {
      pointer-events: none;     /* блокирует клики */

    }



    #board.dimmed::after {
      content: '';
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,.4);
      pointer-events: none;
      border-radius: inherit;
      z-index: 5;

      transition: opacity 0.5s ease; /* плавность */
    }

    #board.dimmedclone {
      pointer-events: none;     /* блокирует клики */
    }


#board.dimmedclone::after {
  content: '';
  position: absolute;
  inset: 0;
  background: rgba(0,0,0,.4);
  pointer-events: none;
  border-radius: inherit;
  z-index: 5;

  opacity: 0;
  transition: opacity 0.5s ease; /* плавность */
}

/* Когда активен dimmedclone — затемнение видно */
#board.dimmedclone.active::after {
  opacity: 1;
}

    .cell {
      position: relative;
      border-radius: 9px;
      overflow: hidden;
      background: #121826; /* для пустых */
      cursor: default;
      user-select: none;
      outline: none;
      transform: translateZ(0);
    }

    .cell { -webkit-user-select: none; -ms-user-select: none; }

    .cell.filled { cursor: pointer; }

    /* Базовый заливочный цвет клетки (по умолчанию серый), плавное включение цвета */
    .cell { transform .06s linear; }
    /* фон без перехода по умолчанию — чтобы "серые" не анимировались */

.cell.filled {
  background-color: var(--color, #2b2f3a);
  /*transition: none;*/ /* Убираем резкую остановку анимации */
  background-position: center center;
  /*background-size: 70%;*/
  background-repeat: no-repeat;
  background-origin: content-box;
  /* на случай, если раньше background задавался через background shorthand */
  /*background-image: none;*/
  background-size: contain;   /* масштаб по большей стороне */
  padding: 15%;               /* «уменьшает» рабочее поле, картинка становится меньше блока */
}

/* Плавный переход включается только для активированных клеток */
.cell.filled[data-activated="1"] {
  transition: background-color .35s ease;
}

   

/* псевдо-элемент для картинки */
.cell.filled::before {
  content: "";
  position: absolute;
  inset: 0; /* заполняет всю ячейку */
  background-position: center center;
  background-repeat: no-repeat;
  background-size: contain; /* чуть меньше чем блок */
  margin: 15%;
  opacity: 0;
  transition: opacity .35s ease;
}

/* активированная ячейка — картинка плавно проявляется */
.cell.filled[data-activated="1"]::before {
  opacity: 1;
}

.cell.filled::before {
  background-image: var(--img-url);
}


    /* Подсветка источника и кандидатов */
    .cell.source { box-shadow: 0 0 0 1.25px rgba(255,255,255,.8), 0 8px 20px rgba(255,255,255,.15), inset 0 0 10px rgba(255,255,255,.15); z-index: 990;}
    .cell.candidate { box-shadow: 0 0 0 1.25px rgba(130,200,255,.95), 0 10px 26px rgba(60,170,255,.25), inset 0 0 16px rgba(120,200,255,.25); z-index: 999;
      pointer-events: auto;}
    .cell.row-hl { box-shadow: 0 0 0 1.25px rgba(var(--hl),.6), 0 6px 18px rgba(var(--hl),.18), inset 0 0 0 rgba(0,0,0,0.0); }
    .cell.col-hl { box-shadow: 0 0 0 1.25px rgba(var(--hl),.6), 0 6px 18px rgba(var(--hl),.18), inset 0 0 0 rgba(0,0,0,0.0); }
    /* Подсветка одинаковых блоков при клике */
    .cell.filled.pulse-same { 
      background-color: rgba(var(--hl), .35) !important; 
      box-shadow: 0 0 0 1.25px rgba(64,224,208,1)/*, 
                  0 10px 26px rgba(64,224,208,.25)*/, 
                  inset 0 0 16px rgba(64,224,208,.25)/**/;
                  /* плавный откат к исходному состоянию */
  transition-delay: 0s; /* старт сразу */
    }
    .cell.dragging { z-index: 999; }

    /* Анимация исчезновения */
    .cell.vanish { animation: vanish .25s ease-in forwards; }
    @keyframes vanish {
      to { opacity: 0; transform: scale(.85); filter: blur(2px); }
    }

    /* Анимация удаления с эффектом взрыва */
    .cell.explode { animation: explode .4s ease-out forwards; }
    @keyframes explode {
      0% { 
        opacity: 1; 
        transform: scale(0.7) rotate(0deg); 
        filter: brightness(1) saturate(1);
      }
      50% { 
        opacity: 1; 
        transform: scale(0.7) rotate(180deg); 
        filter: brightness(1.5) saturate(1.5);
      }
      100% { 
        opacity: 0; 
        transform: scale(0.1) rotate(360deg); 
        filter: brightness(0) saturate(0);
      }
    }

    /* Анимация удаления с эффектом затухания */
    .cell.fade-out { animation: fadeOut .3s ease-in forwards; }
    @keyframes fadeOut {
      0% { 
        opacity: 1; 
        transform: scale(1); 
        filter: hue-rotate(0deg);
      }
      100% { 
        opacity: 0; 
        transform: scale(0.8); 
        filter: hue-rotate(180deg) brightness(0.3);
      }
    }

    /* Анимация удаления с эффектом сжатия */
    .cell.shrink { animation: shrink .25s ease-in forwards; }
    @keyframes shrink {
      0% { 
        opacity: 1; 
        transform: scale(1); 
        border-radius: 12px;
      }
      100% { 
        opacity: 0; 
        transform: scale(0.1); 
        border-radius: 50%;
      }
    }

    /* Анимация удаления с эффектом волны */
    .cell.wave-out { animation: waveOut .35s ease-out forwards; }
    @keyframes waveOut {
      0% { 
        opacity: 1; 
        transform: scale(1) rotateY(0deg); 
      }
      50% { 
        opacity: 0.7; 
        transform: scale(1.1) rotateY(90deg); 
      }
      100% { 
        opacity: 0; 
        transform: scale(0.5) rotateY(180deg); 
      }
    }
    /* Анимация удаления после перемещения */
    .cell.move-remove {
      transition: all 0.3s ease-out;
    }


    /*  подсказки */
    .hint { font-size: 13px; opacity: .8; }
    button { background:#1c2335; color:#e9ecf1; border:1px solid #2a3550; border-radius:12px; padding:8px 12px; cursor:pointer; }
    button:hover { background:#222c44; }
    button { transition: filter .25s linear, background-color .25s linear, color .25s linear, opacity .25s linear; }
    #hint.cooldown, #challenge-mode.cooldown  { filter: brightness(0.7) saturate(0.7); opacity: 0.7; pointer-events: none; }
    /* Подсветка супер-пары (исключительный красный) */


    .cell.filled.hinted-super {
      background-color: rgba(255, 60, 60, .35) !important;
      box-shadow: 0 0 0 1.25px rgba(255,80,80,.95), 0 10px 26px rgba(255,60,60,.25), inset 0 0 16px rgba(255,120,120,.25);
    }
    /* Центрированное всплывающее сообщение */
    .overlay-message {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%) scale(.8);
      pointer-events: none;
      padding: 10px 14px;
      border-radius: 12px;
      background: rgba(20,26,40,.8);
      border: 1px solid #2a3550;
      color: #e9ecf1;
      font-weight: 600;
      text-align: center;
      opacity: 0;
      animation: msg-pop 900ms ease-out forwards;
      z-index: 1000;
      white-space: nowrap;
    }
    @keyframes msg-pop {
      10% { opacity: 1; transform: translate(-50%, -50%) scale(1.06); }
      40% { opacity: 1; transform: translate(-50%, -50%) scale(1.0); }
      100% { opacity: 0; transform: translate(-50%, -50%) scale(1.05); }
    }





    .settings-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      display: none;
      justify-content: center;
      align-items: center;
    
      z-index: 1000;
    }

    .settings-modal.active {
      display: flex;
    }

    .settings-content {
      background: #0f1522;
      border: 1px solid #1f2940;
      border-radius: 16px;
      padding: 24px;
      max-width: 400px;
      width: 90vw;
      max-height: 80vh;
      overflow-y: auto;
      
 
      scrollbar-width: thin;
      scrollbar-color:  var(--color-accent-1-SCRLBR);
    }
    

    .settings-content::-webkit-scrollbar {
      width: 6px;
    }
    
    .settings-content::-webkit-scrollbar-track {
      background: #1a2130;
      border-radius: 3px;
    }
    
    .settings-content::-webkit-scrollbar-thumb {
      background: #64e0d0;
      border-radius: 3px;
      transition: background 0.2s ease;
    }
    
    .settings-content::-webkit-scrollbar-thumb:hover {
      background: #7aebe0;
    }

    .settings-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .settings-title {
      font-size: 18px;
      font-weight: 600;
      color: #e9ecf1;
    }

    .settings-close {
      background: none;
      border: none;
      color: #e9ecf1;
      font-size: 24px;
      cursor: pointer;
      padding: 0;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: background-color 0.2s;
    }

    .settings-close:hover {
      background: #1a2130;
    }

    .setting-group {
      margin-bottom: 20px;
    }

    .setting-label {
      display: block;
      margin-bottom: 8px;
      font-size: 14px;
      color: #e9ecf1;
      font-weight: 500;
    }

    .setting-value {
      display: inline-block;
      margin-left: 10px;
      color: #64e0d0;
      font-weight: 600;
    }
    /* ===== Адаптация под мобильные (страница полностью помещается на экран) ===== */
      @media (min-width: 769px) {
      :root { /*--cell: 56px; /*--gap: 3px;*/ } /* вот с этим небольше проблемки. было --gap: 6 т.е. в 2 раза больше; */
      body { padding:inherit; }
      .hud { flex-wrap: wrap; gap: 8px; padding-top: var(--board-padding);}
      .settings-content {max-height: 80vh;}
      #board .cell {border-radius: 7px; }
    }
    @media (max-width: 768px) {
      :root { /*--cell: 44px; /*--gap: 3px;*/ }
      body { padding:inherit; }
      .hud { flex-wrap: wrap; gap: 8px; padding-top: var(--board-padding);}
      .settings-content {max-height: 80vh;}
      #board .cell {border-radius: 7px; }
    }
    @media (max-width: 480px) {
      :root { /*--cell: 34px; /*--gap: 2px;*/ }
      body { padding:inherit; }
      .hint { font-size: 12px; }
      .hud {padding-top: var(--board-padding);}
      .settings-content {max-height: 80vh;}
      #board .cell {border-radius: 6px;}
    }
    @media (max-width: 380px) {
      :root { /*--cell: 30px; /*--gap: 1.5px;*/ }
      body { padding: inherit; }
      .hud {padding-top: var(--board-padding);}
      .settings-content {max-height: 80vh;}
      #board .cell {border-radius: 5px;}
    }

    .slider-container {
      position: relative;
      margin-top: 8px;
      padding: 0 12px 0 12px;
    }

    .slider {
      width: 100%;
      height: 6px;
      background: #1a2130;
      border-radius: 3px;
      outline: none;
      -webkit-appearance: none;
      appearance: none;
    }

    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      background: #64e0d0;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(100, 224, 208, 0.3);
      transition: all 0.2s;
    }

    .slider::-webkit-slider-thumb:hover {
      background: #7aebe0;
      transform: scale(1.1);
    }

    .slider::-moz-range-thumb {
      width: 18px;
      height: 18px;
      background: #64e0d0;
      border-radius: 50%;
      cursor: pointer;
      border: none;
      box-shadow: 0 2px 6px rgba(100, 224, 208, 0.3);
    }

    .slider-labels {
      display: flex;
      justify-content: space-between;
      margin-top: 8px;
      font-size: 12px;
      color: #8b9bb4;
    }

    .size-slider-labels {
      display: flex;
      justify-content: space-between;
      margin-top: 8px;
      font-size: 12px;
      color: #8b9bb4;
    }

    .size-slider-labels .auto {
      color: #64e0d0;
      font-weight: 600;
    }

    .settings-actions {
      display: flex;
      gap: 12px;
      margin-top: 24px;
    }

    .settings-actions button {
      flex: 1;
      padding: 10px 16px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn-apply {
      background: #64e0d0;
      color: #0f1522;
      border: none;
    }

    .btn-apply:hover {
      background: #7aebe0;
    }

    .btn-cancel {
      background: #1a2130;
      color: #e9ecf1;
      border: 1px solid #2a3550;
    }

    .btn-cancel:hover {
      background: #222c44;
    }


    .btn-settings {
      background: #1c2335;
      color: #e9ecf1;
      border: 1px solid #2a3550;
      border-radius: 12px;
      padding: 8px 12px;
      cursor: pointer;
      transition: all 0.25s linear;
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
    }

    .btn-settings:hover {
      background: #222c44;
    }

    .btn-settings svg {
      width: 14px;
      height: 14px;
      fill: currentColor;
    }

    .theme-selector {
      margin-top: 8px;
    }

    .theme-select {
      width: 100%;
      padding: 8px 12px;
      background: #1a2130;
      color: #e9ecf1;
      border: 1px solid #2a3550;
      border-radius: 8px;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .theme-select:hover {
      background: #222c44;
      border-color: #64e0d0;
    }

    .theme-select:focus {
      outline: none;
      border-color: #64e0d0;
      box-shadow: 0 0 0 2px rgba(100, 224, 208, 0.2);
    }

    .theme-preview {
      margin-top: 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 12px;
      background: #0a0f1a;
      border: 1px solid #1f2940;
      border-radius: 8px;
      max-height: 300px;
      overflow-y: auto;
      

      scrollbar-width: thin;
      scrollbar-color: #64e0d0 #1a2130;
    }
    
  
    .theme-preview::-webkit-scrollbar {
      width: 6px;
    }
    
    .theme-preview::-webkit-scrollbar-track {
      background: #1a2130;
      border-radius: 3px;
    }
    
    .theme-preview::-webkit-scrollbar-thumb {
      background: #64e0d0;
      border-radius: 3px;
      transition: background 0.2s ease;
    }
    
    .theme-preview::-webkit-scrollbar-thumb:hover {
      background: #7aebe0;
    }

    .color-preview {
      width: 20px;
      height: 20px;
      border-radius: 3px;
      border: 1px solid #2a3550;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }

    .color-preview:hover {
      transform: scale(1.15);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
    }

    .color-preview.selected {
      border: 2px solid #64e0d0;
      box-shadow: 0 0 0 2px rgba(100, 224, 208, 0.3);
    }

    .theme-preview.empty {
      display: flex;
      align-items: center;
      justify-content: center;
      color: #8b9bb4;
      font-size: 12px;
      font-style: italic;
      min-height: 60px;
    }


    .palette-header {
      transition: all 0.2s ease;
      border-radius: 4px;
      padding: 2px 4px;
    }

    .palette-header:hover {
      background: rgba(100, 224, 208, 0.1);
      color: #64e0d0 !important;
    }

    .palette-header:active {
      background: rgba(100, 224, 208, 0.2);
      transform: scale(0.98);
    }

    .custom-theme-input {
      margin-top: 16px;
      padding: 16px;
      background: #0a0f1a;
      border: 1px solid #1f2940;
      border-radius: 8px;
    }

    .input-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .btn-clear-custom {
      background: #2a3550;
      color: #e9ecf1;
      border: 1px solid #3a4560;
      border-radius: 6px;
      padding: 6px 12px;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn-clear-custom:hover {
      background: #3a4560;
      border-color: #64e0d0;
    }

    #custom-colors-input {
      width: 100%;
      width: -webkit-fill-available;
      background: #1a2130;
      color: #e9ecf1;
      border: 1px solid #2a3550;
      border-radius: 6px;
      padding: 10px;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      resize: vertical;
      min-height: 80px;
      transition: all 0.2s;
      
 
      scrollbar-width: thin;
      scrollbar-color: #64e0d0 #1a2130;
    }
    
  
    #custom-colors-input::-webkit-scrollbar {
      width: 6px;
    }
    
    #custom-colors-input::-webkit-scrollbar-track {
      background: #1a2130;
      border-radius: 3px;
    }
    
    #custom-colors-input::-webkit-scrollbar-thumb {
      background: #64e0d0;
      border-radius: 3px;
      transition: background 0.2s ease;
    }
    
    #custom-colors-input::-webkit-scrollbar-thumb:hover {
      background: #7aebe0;
    }

    #custom-colors-input:focus {
      outline: none;
      border-color: #64e0d0;
      box-shadow: 0 0 0 2px rgba(100, 224, 208, 0.2);
    }

    #custom-colors-input::placeholder {
      color: #8b9bb4;
      opacity: 0.7;
    }

    .input-actions {
      margin-top: 12px;
      display: flex;
      gap: 8px;
    }

    .btn-add-custom {
      background: #64e0d0;
      color: #0f1522;
      border: none;
      border-radius: 6px;
      padding: 8px 16px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn-add-custom:hover {
      background: #7aebe0;
    }

    .btn-add-custom:disabled {
      background: #2a3550;
      color: #8b9bb4;
      cursor: not-allowed;
    }


    .palette-container.swipeable {
      position: relative;
      overflow: hidden;
      min-height: fit-content;
    }

    .palette-container.swipeable .swipe-overlay {
      position: absolute;
      top: 0;
      right: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent 0%, rgba(255, 0, 0, 0.25) 50%, rgba(255, 0, 0, 1) 100%);
      display: flex;
      align-items: center;
      justify-content: flex-end;
      padding-right: 12px;
      color: #ffffff #ff4444;
      font-size: 12px;
      font-weight: 600;
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
      z-index: 2;
    }

    .palette-container.swipeable.swiping .swipe-overlay {
      opacity: 1;
    }

    .palette-container.swipeable.deleting {
      transform: translateX(-100%);
      opacity: 0;
      transition: all 0.3s ease-out;
    }
    .hud-right {
  display: flex;
  gap: 6px; 
}

/* Контейнер тоггла */
.toggle {
  position: relative;
  display: inline-block;
  width: 70px;
  height: 34px;
  cursor: pointer;
}

/* Скрытый input */
.toggle input {
  opacity: 0;
  width: 0;
  height: 0;
}

/* Слайдер */
.toggle-slider {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #ccc;
  border-radius: 12px; /* закругленные углы */
  transition: 0.3s;
  font-size: 14px;
  font-family: sans-serif;
  color: white;
  text-align: center;
  line-height: 34px;
}

/* Когда включен */
.toggle input:checked + .toggle-slider {
  background-color: #4caf50;
}

/* Текст внутри */
.toggle-slider::before {
  content: "Выкл";
  position: absolute;
  left: 0;
  width: 100%;
  transition: 0.3s;
}

.toggle input:checked + .toggle-slider::before {
  content: "Вкл";
}

* { box-sizing: border-box; }

.hidden {
  display: none;
}

.start-btn {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 4rem;
  background: none;
  border: none;
  color: white;
  text-shadow: 0 0 10px black;
  cursor: pointer;
  opacity: 0.9;
  transition: opacity 0.3s ease;
  z-index: 20;
}

.start-btn:hover {
  opacity: 1;
}


.overlay-message {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(0,0,0,0.8);
  color: white;
  padding: 20px;
  border-radius: 12px;
  text-align: center;
  z-index: 30;
}

.overlay-message button {
  margin-top: 15px;
  padding: 8px 16px;
  font-size: 1rem;
  border: none;
  border-radius: 8px;
  cursor: pointer;
}

.overlay-level {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: #0a0f1a;
  border: 1px solid #1f2940;
  border-radius: 12px;
  padding: 20px 28px;
  color: #e0e6f0;
  text-align: center;
  z-index: 50;
  width: 90%;
  box-shadow: 0 0 25px rgba(0,0,0,0.8);
}

.overlay-level-title {
  font-size: 1.6rem;
  font-weight: bold;
  margin-bottom: 16px;
  color: #ffffff;
}

.overlay-level-time {
  font-size: 1.2rem;
  margin-bottom: 16px;
  color: #ffffff;
}

.overlay-level-info {
  display: flex;
  flex-direction: column;
  gap: 6px;
  padding: 12px;
  margin-bottom: 20px;
  background: #111a2c;
  border: 1px solid #1f2940;
  border-radius: 8px;
  font-size: 0.95rem;
  text-align: left;
}

.overlay-level-btn {
  padding: 10px 22px;
  font-size: 1rem;
  background: #64e0d0;
  border: none;
  border-radius: 8px;
  color: #0a0f1a;
  font-weight: 600;
  cursor: pointer;
  transition: background 0.2s ease;
}

.overlay-level-btn:hover {
  background: #7aebe0;
}



.overlay-countdown {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 80px;
  font-weight: bold;
  color: #fff;
  text-shadow: 2px 2px 10px rgba(0,0,0,0.7);
  pointer-events: none;
  z-index: 9999;
  opacity: 0;
}

/* Анимация появления и исчезновения */
.overlay-countdown.animate {
  animation: countdownPop 1s ease forwards;
}

@keyframes countdownPop {
  0% {
    transform: translate(-50%, -50%) scale(2);
    opacity: 0;
  }
  30% {
    transform: translate(-50%, -50%) scale(1);
    opacity: 1;
  }
  70% {
    transform: translate(-50%, -50%) scale(1);
    opacity: 1;
  }
  100% {
    transform: translate(-50%, -50%) scale(0.5);
    opacity: 0;
  }
}

#hint.cooldown,
#challenge-mode.cooldown,
#back.cooldown {
  filter: brightness(0.7) saturate(0.7);
  /*opacity: 0.7;*/
  pointer-events: none;
  animation: cooldown var(--cooldown-time) linear;
}




  </style>
 
  <style type="text/css">
    .settings-content {
  display: flex;
  flex-direction: column;
  background: #0f1522;
  border: 1px solid #1f2940;
  border-radius: 16px;
  max-width: 420px;
  width: 90vw;
  overflow: hidden;
      min-height: 80vh;
}

/* Вкладки */
.settings-tabs {
  border-bottom: 1px solid #1f2940;
  margin: 0px;
  /*overflow-x: auto;
      overflow-y: clip;*/
  white-space: nowrap;
  padding: 0px;
        scrollbar-color:  var(--color-accent-2-SCRLBR);
        scrollbar-width: thin;
}

.tab-buttons {
  display: flex;
  gap: 6px;
  min-width: fit-content;
  padding-bottom: 10px;
}

.tab-button {

  background: #1a2130;
  color: #ccc;
  border: none;
  padding: 6px 12px;
  border-radius: 8px;
  cursor: pointer;
  flex-shrink: 0;
  transition: 0.2s;
  font-size: 14px;
}

.tab-button.active {
  background: #64e0d0;
  color: #0f1522;
  /*font-weight: 600;*/
}

/* Прокручиваемая часть */
div.settings-content .settings-scroll {
  flex: 1;
  overflow-y: auto;
  padding: 0 12px 12px 12px;
  scrollbar-width: thin;
  scrollbar-color: #64e0d0 #1a2130;   margin-top: 20px;
}

.settings-scroll::-webkit-scrollbar {
  width: 6px;
  margin-top: 20px;
}
.settings-scroll::-webkit-scrollbar-track {
  background: #1a2130;
  border-radius: 3px;   margin-top: 20px;
}
.settings-scroll::-webkit-scrollbar-thumb {
  background: #64e0d0;
  border-radius: 3px;   margin-top: 20px;
}
.settings-scroll::-webkit-scrollbar-thumb:hover {
  background: #7aebe0;   margin-top: 20px;
}

/* Футер */
.settings-footer {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  /*padding: 12px 24px 16px 24px;
  background: rgba(10, 14, 22, 0.95);
  border-top: 1px solid #1f2940;
  border-radius: 0 0 16px 16px;*/
  margin-top: 20px;
}
.settings-footer {
  position: relative;
  display: flex;
  justify-content: space-between;
  gap: 10px;
  background:  rgb(15,21,34,1); /* цвет фона футера */
}

/* Добавляем градиент сверху футера */
.settings-footer::before {
  content: "";
  position: absolute;
  top: -50px; /* высота градиента над футером */
  left: 0;
  width: 100%;
  height: 30px;
  /*background: linear-gradient(to bottom, rgba(15,21,34,0) 0%, rgba(15,21,34,1) 100%);*/
  background: linear-gradient(
    to bottom,
    rgba(15,21,34,0) 0%,        /* полностью прозрачный верх */
    rgba(15,21,34,0.7) 50%,     /* полупрозрачный середина */
    rgba(15,21,34,1) 100%       /* полностью видимый низ (цвет футера) */
  );
  pointer-events: none; /* чтобы не мешал кликам */
}

.btn-apply,
.btn-cancel {
  flex: 1;
  padding: 8px 12px;
  border: none;
  border-radius: 8px;
  font-size: 14px;
  font-weight: 600;*/
  cursor: pointer;
  transition: 0.2s;
}

.btn-apply {
  background: #64e0d0;
  color: #0f1522;
}
.btn-apply:hover {
  background: #7aebe0;
}

.btn-cancel {
  background: #1a2130;
  color: #e9ecf1;
}
.btn-cancel:hover {
  background: #222a3a;
}

/* Содержимое вкладок */
.tab-pane {
  display: none;
  animation: fadeIn 0.2s ease;
}
.tab-pane.active {
  display: block;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(5px); }
  to { opacity: 1; transform: translateY(0); }
}

  </style>
  <style type="text/css">
    /*.slider-labels {
  display: flex;
  justify-content: space-between;
  font-size: 0.85em;
  user-select: none;
}
.slider-labels span {
  flex: 1;
  text-align: center;
}*/

  </style>
  <style type="text/css">

.slider-checkbox {
  display: flex;
  align-items: center;
  justify-content: flex-end;
  gap: 6px;
  margin-top: 4px;
  font-size: 12px;
  color: #8b9bb4;
}

.slider-checkbox input[type="checkbox"] {
  width: 14px;
  height: 14px;
  accent-color: #64e0d0;
  cursor: pointer;
}


/*/ */
.slider-checkbox-row {
  display: flex;
  align-items: center;
  gap: 8px;
}

.slider-with-checkbox {
  flex: 1;
  display: flex;
  flex-direction: column;
}

/* Подогнать подписи под шкалу */
.slider-labels {
  display: flex;
  justify-content: space-between;
  font-size: 12px;
  color: #8b9bb4;
}

/* Стиль чекбокса */
.slider-checkbox {
  display: flex;
  align-items: center;
  gap: 4px;
  font-size: 12px;
  color: #8b9bb4;
}

.slider-checkbox input[type="checkbox"] {
  width: 14px;
  height: 14px;
  accent-color: #64e0d0;
  cursor: pointer;
}

  </style>

  <style>
.game-stats { 
  display: flex;
  flex-direction: column;
  gap: 6px;
  /*margin-top: 10px;*/
  /*font-family: "Segoe UI", sans-serif;*/
  font-size: 14px;
}
.stat-item {
  display: flex;
  gap: 6px;
  align-items: center;
}
.stat-label {
  font-weight: 600;
  color: #ccc;
}
.stat-value {
  font-weight: 700;
  transition: color 0.3s ease;
}
.stat-value.easy { color: #4CAF50; }    /* зелёный */
.stat-value.normal { color: #FFC107; }  /* жёлтый */
.stat-value.hard { color: #FF5722; }    /* оранжевый */
.stat-value.extreme { color: #E91E63; } /* розово-красный */


.slider-checkbox-row {
  display: flex;
  align-items: flex-start; /* Выравнивание по верху */
  gap: 8px;
}

.slider-with-checkbox {
  flex: 1;
  display: flex;
  flex-direction: column;
}

.slider-labels {
  display: flex;
  justify-content: space-between;
  font-size: 12px;
  color: #8b9bb4;
}

.checkbox-wrapper {
  display: flex;
  flex-direction: column; /* подпись под чекбоксом */
  align-items: center;
  font-size: 12px;
  color: #8b9bb4;
  margin-top: 3px;
}

.checkbox-wrapper input[type="checkbox"] {
  width: 14px;
  height: 14px;
  accent-color: #64e0d0;
  cursor: pointer;
}

.checkbox-label {
  margin-top: 2px;
  font-size: 11px;
  margin-top: 4px;
}

</style>
</head>
<body>
  <!-- Loader -->
<div id="game-loader" aria-hidden="true" role="status" aria-live="polite">
  <div class="loader-inner" aria-hidden="true">
    <div class="cube" aria-hidden="true"></div>
    <div class="loader-label">Загрузка...</div>
  </div>
</div>


  <div class="game">
    <div class="hud">
     <div class="hud-left">
      <button id="hint" class="btn-settings" style="margin-left: 10px;">Подсказка</button>
      <button id="back" class="btn-settings hidden" style="margin-left: 10px;">
        <svg viewBox="0 0 24 24">
          <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
        </svg>
      </button>

      </div>
      <!-- Центральная зона -->
      <div class="hud-center">



        
      </div>

      <div class="hud-right">
        <!-- Кнопка для включения режима испытания -->

        <button id="challenge-mode" class="btn-settings">
          <svg viewBox="0 0 24 24" width="24" height="24">
            <!-- круг циферблата -->
            <circle cx="12" cy="12" r="9" stroke="currentColor" stroke-width="2" fill="none"/>
            <!-- стрелка часов -->
            <line x1="12" y1="12" x2="12" y2="7" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
            <!-- стрелка минут -->
            <line x1="12" y1="12" x2="16" y2="12" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
          </svg>
        </button>
        <!-- Таймер (по умолчанию скрыт) -->
        <span id="timer" class="btn-settings hidden" style="margin-right: 10px; max-height: 32px;">00:00</span>
      <button id="reset" class="btn-settings">
        <svg viewBox="0 0 24 24" width="12" height="12" fill="white">
          <path d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.11-.3 2.15-.82 3.05l1.46 1.46C19.24 14.88 20 13.5 20 12c0-4.42-3.58-8-8-8zm-6.64 3.05L3.9 5.59C2.76 7.12 2 9.06 2 11c0 4.42 3.58 8 8 8v3l4-4-4-4v3c-3.31 0-6-2.69-6-6 0-1.11.3-2.15.82-3.05z"/>
        </svg>
        
      </button>
     
      <button id="settings" class="btn-settings" style="margin-right: 10px;">
        <svg viewBox="0 0 24 24">
          <path d="M12,15.5A3.5,3.5 0 0,1 8.5,12A3.5,3.5 0 0,1 12,8.5A3.5,3.5 0 0,1 15.5,12A3.5,3.5 0 0,1 12,15.5M19.43,12.97C19.47,12.65 19.5,12.33 19.5,12C19.5,11.67 19.47,11.34 19.43,11L21.54,9.37C21.73,9.22 21.78,8.95 21.66,8.73L19.66,5.27C19.54,5.05 19.27,4.96 19.05,5.05L16.56,6.05C16.04,5.66 15.5,5.32 14.87,5.07L14.5,2.42C14.46,2.18 14.25,2 14,2H10C9.75,2 9.54,2.18 9.5,2.42L9.13,5.07C8.5,5.32 7.96,5.66 7.44,6.05L4.95,5.05C4.73,4.96 4.46,5.05 4.34,5.27L2.34,8.73C2.22,8.95 2.27,9.22 2.46,9.37L4.57,11C4.53,11.34 4.5,11.67 4.5,12C4.5,12.33 4.53,12.65 4.57,12.97L2.46,14.63C2.27,14.78 2.22,15.05 2.34,15.27L4.34,18.73C4.46,18.95 4.73,19.03 4.95,18.95L7.44,17.94C7.96,18.34 8.5,18.68 9.13,18.93L9.5,21.58C9.54,21.82 9.75,22 10,22H14C14.25,22 14.46,21.82 14.5,21.58L14.87,18.93C15.5,18.68 16.04,18.34 16.56,17.94L19.05,18.95C19.27,19.03 19.54,18.95 19.66,18.73L21.66,15.27C21.78,15.05 21.73,14.78 21.54,14.63L19.43,12.97Z"/>
        </svg>
        
      </button></div>
    </div>
    <div id="board" aria-label="Игровое поле"></div>

  </div>

<div class="settings-modal">
  <div class="settings-content">
    <div class="settings-header">
      <h2 class="settings-title">Настройки игры</h2>
      <button class="settings-close" onclick="closeSettings()">×</button>
    </div>

    <!-- Вкладки -->
    <div class="settings-tabs">
      <div class="tab-buttons" id="tab-buttons">
        <button class="tab-button active" data-tab="game">Основные</button>
        <button class="tab-button" data-tab="appearance">Оформление</button>
        <button class="tab-button" data-tab="system">Прочее</button>
      </div>
    </div>

    <!-- Прокручиваемая часть -->
    <div class="settings-scroll">
      <div class="tab-content">
        <!-- Вкладка: Игра -->
        <div class="tab-pane active" id="tab-game">
<div class="setting-group">
<div class="game-stats">
  <div class="stat-item">
    <span class="stat-label">Сложность:</span>
    <span id="difficulty-name" class="stat-value">—</span>
  </div>
  <div class="stat-item">
    <span class="stat-label">Расчётное время:</span>
    <span id="duration-value" class="stat-value">—</span>
  </div>
</div>
</div>

<div class="setting-group">
  <label class="setting-label">
    Размер поля: <span class="setting-value" id="settings-size">10×10</span>
  </label>
  <div class="slider-checkbox-row">
    <div class="slider-container slider-with-checkbox">
      <input type="range" min="0" max="3" value="0" class="slider" id="size-slider">
      <div class="size-slider-labels">
        <span>auto</span>
        <span>10×10</span>
        <span>10×15</span>
        <span>10×20</span>
      </div>
    </div>
    <div class="checkbox-wrapper">
      <input type="checkbox" id="size-maxCheck">
      <span class="checkbox-label">max</span>
    </div>
  </div>
</div>

<div class="setting-group">
  <label class="setting-label">
    Количество цветов: <span class="setting-value" id="settings-maxColors">20</span>
  </label>
  <div class="slider-checkbox-row">
    <div class="slider-container slider-with-checkbox">
      <input type="range" class="slider" id="maxColors-slider">
      <div class="slider-labels">
        <span id="maxColors-minLabel"></span>
        <span id="maxColors-maxLabel"></span>
      </div>
    </div>
    <div class="checkbox-wrapper">
      <input type="checkbox" id="maxColors-maxCheck">
      <span class="checkbox-label">max</span>
    </div>
  </div>
</div>


<div class="setting-group">
  <label class="setting-label">
    Минимум пар: <span class="setting-value" id="settings-minPair">1</span>
  </label>
  <div class="slider-checkbox-row">
    <div class="slider-container slider-with-checkbox">
      <input type="range" class="slider" id="minPair-slider">
      <div class="slider-labels">
        <span id="minPair-minLabel"></span>
        <span id="minPair-maxLabel"></span>
      </div>
    </div>
    <div class="checkbox-wrapper">
      <input type="checkbox" id="minPair-maxCheck">
      <span class="checkbox-label">max</span>
    </div>
  </div>
</div>
</div>

        <!-- Вкладка: Оформление -->
        <div class="tab-pane" id="tab-appearance">
          <div class="setting-group">
            <label class="setting-label">
              Использовать рисунки: <span class="setting-value" id="settings-useImages">Включено</span>
            </label>
            <div class="slider-container">
              <input type="range" min="0" max="1" value="1" class="slider" id="useImages-slider">
              <div class="slider-labels"><span>Выключено</span><span>Включено</span></div>
            </div>
          </div>

          <div class="setting-group">
            <label class="setting-label">Галерея рисунков: <span class="setting-value" id="settings-room"></span></label>
            <select id="room-selector" class="theme-select">
              <option value="room1">"Сказания о..." (24)</option>
              <option value="room2">"Осенний вайб" (29)</option>
            </select>
          </div>

          <div class="setting-group">
            <label class="setting-label">Тема палитры: <span class="setting-value" id="settings-theme">По умолчанию</span></label>
            <select id="theme-selector" class="theme-select">
              <option value="default">По умолчанию</option>
              <option value="mononight">Одноцветная ночь</option>
              <option value="bright">Другие темы</option>
              <option value="custom">Пользовательская</option>
            </select>

            <div class="theme-preview" id="theme-preview"></div>

            <div class="custom-theme-input" id="custom-theme-input" style="display:none;">
              <div class="input-header">
                <label class="setting-label">Введите цвета</label>
                <button class="btn-clear-custom" onclick="clearCustomTheme()">Очистить</button>
              </div>
              <textarea id="custom-colors-input" placeholder="#ff0000, #00ff00, #0000ff" rows="3"></textarea>
              <div class="input-actions">
                <button class="btn-add-custom" onclick="addCustomColors()">Добавить цвета</button>
              </div>
            </div>
          </div>
        </div>

        <!-- Вкладка: Система -->
        <div class="tab-pane" id="tab-system">
          <div class="setting-group">
            <label class="setting-label">
              Полноэкранный режим: <span class="setting-value" id="settings-fullscreen">Выключен</span>
            </label>
            <div class="slider-container">
              <input type="range" min="0" max="1" value="0" class="slider" id="fullscreen-slider">
              <div class="slider-labels"><span>Выключен</span><span>Включен</span></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Фиксированный футер -->
    <div class="settings-footer">
      <button class="btn-apply" onclick="applySettings()">Применить</button>
      <button class="btn-cancel" onclick="closeSettings()">Отмена</button>
    </div>
  </div>
</div>

<script type="text/javascript">
  document.querySelectorAll('.tab-button').forEach(button => {
  button.addEventListener('click', () => {
    document.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
    document.querySelectorAll('.tab-pane').forEach(p => p.classList.remove('active'));

    button.classList.add('active');
    document.getElementById(`tab-${button.dataset.tab}`).classList.add('active');
  });
});

</script>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-PYJ5SM4Z1Y"></script>


<script>
  let loaderStartTime = 0;

  window.showLoader = function() {
    const loader = document.getElementById('game-loader');
    if (!loader) return;
    loader.style.display = 'flex';
    loader.style.opacity = "1";
    loader.setAttribute('aria-hidden', 'false');
    loaderStartTime = Date.now();
  };

    // hideLoader теперь умеет принимать callback
  window.hideLoader = function(callback) {
    const loader = document.getElementById('game-loader');
    if (!loader || loader.style.display === 'none') {
      // если скрывать нечего — вызываем callback сразу
      if (typeof callback === "function") callback();
      return;
    }

    const elapsed = Date.now() - loaderStartTime;
    const minDuration = 500; // минимум 0,5 секунд

    const remaining = Math.max(0, minDuration - elapsed);
    setTimeout(() => {
      loader.style.transition = "opacity 0.5s ease";
      loader.style.opacity = "0";

      setTimeout(() => {
        loader.style.display = 'none';
        loader.style.transition = "";
        loader.setAttribute('aria-hidden', 'true');

        if (typeof callback === "function") {
          callback();
        }
      }, 500); // совпадает с transition
    }, remaining);
  };

</script>
<script>

  //ImageDB.cleanup().catch(console.error);использовать на случай очистки imagedb

// indexeddb.js
const ImageDB = {
  db: null,

  async open() {
    if (this.db) return this.db;

    return new Promise((resolve, reject) => {
      const request = indexedDB.open("GameImagesDB", 2); // версия БД

      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        if (db.objectStoreNames.contains("images")) {
          db.deleteObjectStore("images");
        }
        const store = db.createObjectStore("images"); // key = url
        store.createIndex("timestamp", "timestamp");
      };

      request.onsuccess = (event) => {
        this.db = event.target.result;
        resolve(this.db);
      };

      request.onerror = (event) => reject(event.target.error);
    });
  },

  async put(key, blob) {
    const db = await this.open();
    const record = { blob, timestamp: Date.now() };

    return new Promise((resolve, reject) => {
      const tx = db.transaction("images", "readwrite");
      tx.objectStore("images").put(record, key);
      tx.oncomplete = () => resolve();
      tx.onerror = (e) => reject(e.target.error);
    });
  },

  async get(key) {
    const db = await this.open();
    return new Promise((resolve, reject) => {
      const tx = db.transaction("images", "readonly");
      const request = tx.objectStore("images").get(key);
      request.onsuccess = () => resolve(request.result);
      request.onerror = (e) => reject(e.target.error);
    });
  },

  async delete(key) {
    const db = await this.open();
    return new Promise((resolve, reject) => {
      const tx = db.transaction("images", "readwrite");
      tx.objectStore("images").delete(key);
      tx.oncomplete = () => resolve();
      tx.onerror = (e) => reject(e.target.error);
    });
  },

  async cleanup(olderThanMs = 7 * 24 * 60 * 60 * 1000) {
    const db = await this.open();
    return new Promise((resolve, reject) => {
      const tx = db.transaction("images", "readwrite");
      const store = tx.objectStore("images");
      const req = store.openCursor();

      req.onsuccess = (e) => {
        const cursor = e.target.result;
        if (cursor) {
          const { timestamp } = cursor.value;
          if (Date.now() - timestamp > olderThanMs) {
            cursor.delete();
          }
          cursor.continue();
        }
      };

      tx.oncomplete = () => resolve();
      tx.onerror = (e) => reject(e.target.error);
    });
  }
};


</script>


</script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-PYJ5SM4Z1Y');
</script>
  <script>
    
    const CONFIG = {
      width: 10,         // ширина поля (редактируемо)
      height: 10,       // высота поля (редактируемо)
      maxColors: 20,      // MAXID_color — максимум разных цветов (редактируемо)
      minPair: 1,       // MIN_pair — минимум пар каждого цвета (редактируемо)
      theme: 'default', 
      fullscreen: false,    
      useImages: true,       // <-- по умолчанию рисунки выключены
      currentRoom: 'room1', // ключ из AVAILABLE_ROOM
    };


    // примеры массивов (файлы лежат в /img)
    const ROOM1 = [
      // одна «тема» (напр., набор картинок для комнаты)
      ['1.png', '2.png', '3.png', '4.png', '5.png', '6.png', '7.png', '8.png', '9.png', '10.png', '11.png', '12.png', '13.png', '14.png', '15.png', '16.png', '17.png', '18.png', '19.png', '20.png', '21.png', '22.png','23.png','24.png'/*,'25.png'*/]
    ];

    const ROOM2 = [
      ['1.png','2.png','3.png','4.png','5.png','6.png','7.png','8.png','9.png', '10.png', '11.png', '12.png', '13.png', '13a.png', '14.png', '15.png', '16.png', '17.png', '18.png', '19.png', '20.png', '21.png', '22.png', '23.png', '24.png', '25.png',  '26.png', '27.png', '28.png']
    ];

    const AVAILABLE_ROOM = {
      room1: { name: 'Комната 1', folder: 'img', themes: ROOM1 },
      room2: { name: 'Комната 2', folder: 'img2', themes: ROOM2 }
    };

    // Темы цветов
    const THEMES = [

      ['#D16F6F', '#e2a73d', '#3EA084', '#4B79B0', '#7A5EA0',
       '#B36D8C', '#246e5f', '#C07A3F', '#794b4b', '#6FAF7A',
        '#B05B4A', '#B78E62', '#3e5553', '#213D45', '#BFAF56',
         '#675250', '#426b37', '#6B8B2E', '#867a30', '#af3e33',
          '#74717d', '#D26947', '#0E7A78', '#C6A200', '#5A4970', '#0E7A78', '#C6A200', '#5A4970', '#5A4970'],

    ];


   
    const THEMES_MONONIGHT = [
      
      ['#5a1830','#6f1e3a','#7e2346','#8b2d59','#a33b6b','#b24c79','#c25a89','#d06a95','#7a2048','#9a3a69'],
      
      ['#0b3134','#0d3d40','#0e5054','#0f6b69','#0e6062','#136c6f','#1a7f82','#259499','#2aa9ad','#34b7ba'],
  
      ['#2a2440','#2b2a49','#3b2f6e','#494a83','#5c4fb3','#6e65c8','#575aa0','#646ab8','#7a7bd0','#8a8ae0'],

      ['#1c2734','#203040','#243244','#2a3e54','#2d3e55','#34506a','#3e6280','#405677','#487496','#4f80a4'],

      ['#163021','#1d3b2a','#1f4330','#25503a','#285740','#2e664a','#316b50','#377c5a','#3a7f60','#41926a'],

      ['#4a2f15','#5a3a1a','#5e3d1b','#6f4a21','#724b21','#845a28','#865a27','#996a30','#9a682d','#ae7a37']
    ];

        const THEMES_BRIGHT = [
          ['#ff0000','#ff7f00','#ffff00','#7fff00','#00ff00',
       '#00ff7f','#00ffff','#007fff','#0000ff','#7f00ff',
       '#ff00ff','#ff007f','#bf3030','#bf6f30','#bfbf30',
       '#6fbf30','#30bf30','#30bf6f','#30bfbf','#306fbf',
       '#3030bf','#6f30bf','#bf30bf','#bf306f','#bf3030'],

        [   "#5a0f0f",
  "#7a1b1b",
  "#8b2e2e",
  "#a14418",
  "#b36a1f",
  "#8c6c1a",
  "#6b4f16",
  "#4d3812",
  "#1e3a1e",
  "#2d572c",
  "#3c7040",
  "#496d5a",
  "#355b57",
  "#2a4d4a",
  "#1f3b3a",
  "#2e3e5c",
  "#1d2f4d",
  "#243a6b",
  "#162236",
  "#301d4a",
  "#42295f",
  "#532f73",
  "#3d2557",
  "#2b193f",
  "#5a2b4b",
  "#6c3558",
  "#472d20",
  "#3b2a1d",
  "#5c442f",
  "#6a5a48" ] 

    ];

    
    const THEMES_CUSTOM = [];

   
    const AVAILABLE_THEMES = {
      'default': { name: 'По умолчанию', themes: THEMES },
      'mononight': { name: 'Одноцветная ночь', themes: THEMES_MONONIGHT },
      'bright': { name: 'Яркие', themes: THEMES_BRIGHT },
      'custom': { name: 'Пользовательская', themes: THEMES_CUSTOM }
    };

    // Утилиты координат
    const idx = (x, y, width) => y * width + x;
    
    
    const STORAGE_KEY = 'blockGameData';
    //let challengeModeToken = 0;
      let challengeMode = false;
    
    function saveGameData() {
      if (!CONFIG.saveData) return;
      
      try {
        const gameData = {
         

          config: {
            width: game.width,
            height: game.height,
            maxColors: game.maxColors,
            minPair: game.minPair,
            theme: game.currentTheme,
            fullscreen: CONFIG.fullscreen,
            saveData: CONFIG.saveData,
            useImages: CONFIG.useImages,
            currentRoom: CONFIG.currentRoom
          },

         
          gameState: {
            board: game.board,
            pinnedPaletteIndex: game.pinnedPaletteIndex,
            theme: game.theme
          },
          
          customPalettes: THEMES_CUSTOM,
          
          lastSaved: Date.now()
        };
        
        localStorage.setItem(STORAGE_KEY, JSON.stringify(gameData));
        console.log('Данные игры сохранены');
      } catch (error) {
        console.error('Ошибка сохранения данных:', error);
        showMessage('Ошибка сохранения данных', 'error');
      }
    }
    
    function loadGameData() {
      if (!CONFIG.saveData) return null;
      
      try {
        const savedData = localStorage.getItem(STORAGE_KEY);
        if (!savedData) return null;
        
        const gameData = JSON.parse(savedData);
        

        const thirtyDaysAgo = Date.now() - (30 * 24 * 60 * 60 * 1000);
        if (gameData.lastSaved < thirtyDaysAgo) {
          console.log('Сохраненные данные устарели, используем настройки по умолчанию');
          return null;
        }
        
        console.log('Данные игры загружены');
        return gameData;
      } catch (error) {
        console.error('Ошибка загрузки данных:', error);
        return null;
      }
    }
    
    function clearGameData() {
      try {
        localStorage.removeItem(STORAGE_KEY);

      } catch (error) {

      }
    }



function parseTimeToSeconds(timeStr) {
  try {
    const [minutes, seconds] = timeStr.split(":").map(Number);
    return minutes * 60 + seconds;
  } catch (err) {
    console.warn("⏱ Ошибка при разборе времени:", err);
    return null;
  }
}


function sendChallengeCompletedEvent(finalTime) {
  try {
    const elapsedSeconds = parseTimeToSeconds(finalTime);

    gtag('event', 'challenge_completed', {
      time_spent_sec: elapsedSeconds ?? 0,  // если null → подставим 0
      time_spent_str: finalTime,            // оставим и строку для отладки
      board_height: CONFIG.height,
      color_count: CONFIG.maxColors,
      min_pairs: CONFIG.minPair,
      room: CONFIG.currentRoom 
    });
  } catch (err) {
    console.warn("⚠️ Ошибка при отправке события challenge_completed:", err);
  }
}


    class Game {

      constructor({ width, height, maxColors, minPair, theme = 'default' }) {
        this.width = width;
        this.height = height;
        this.size = Math.max(width, height);
        this.currentTheme = theme;
        this.pinnedPaletteIndex = -1;


        this.useImages = CONFIG.useImages;
        this.currentRoom = CONFIG.currentRoom || 'room1';


        // 🔹 вот тут выбираем картинки для текущей комнаты
        this.roomImages = AVAILABLE_ROOM[this.currentRoom] || [];

       this.imageUrlCache = new Map(); // ключ -> готовый blobUrl

        this.theme = this.getCurrentThemeColors();
        this.maxColors = Math.min(maxColors, this.theme.length);
        this.minPair = minPair;

        this.state = {
          locked: false,
          source: null,
          candidates: []
        };

        this.palette = this.getCurrentThemeColors();
        this.roomImages = this.getCurrentRoomImages();
        this.ensureImageModeLimits();

        this.superHint = null;
        this._hintCooldownUntil = 0;
        this.drag = {
          active: false,
          startX: null,
          startY: null,
          axis: null,
          startClientX: 0,
          startClientY: 0,
          thresholdPx: 8,
        };
        this._blockClicksUntil = 0;

        // показываем загрузчик (делегировано глобально)
        window.showLoader();

        // >>> ожидание загрузки картинок <<<
        if (this.useImages && this.roomImages.length > 0) {
          this.preloadImages(this.roomImages).then(() => {
            this.initGame();
          });
        } else {
          this.initGame();
        }
      }

      // запуск после всех подготовок
      async initGame() {

        // 🔹 показываем loader сразу
        if (typeof window.showLoader === "function") window.showLoader();

        // 1️⃣ прелоадим картинки (если включены)
        if (this.useImages && this.roomImages.length > 0) {
          await this.preloadImages(this.roomImages);
          // тут все картинки уже загружены и в IndexedDB
        }

        // 2️⃣ генерируем доску
        this.board = this.generateBoard();

        // 3️⃣ монтируем доску в DOM
        this.mount();

        // 4️⃣ биндим кнопку подсказки
        this.bindHintButton();

        // 🔹 скрываем loader только после отрисовки доски
        if (typeof window.hideLoader === "function") window.hideLoader();
      }


      getImageBasePath() {
        // если ensureImageModeLimits() установил this.roomFolder — используем его
        if (this.roomFolder && this.roomFolder.length > 0) return this.roomFolder;
        // fallback по теме (текущее поведение)
        return this.currentTheme === 'adventure' ? 'img2' : 'img';
      }


    clearImageUrlCache() {
      for (const url of this.imageUrlCache.values()) {
        URL.revokeObjectURL(url);
      }
      this.imageUrlCache.clear();
    }

      // прелоадер для изображений

        async preloadImages(files) {
          const basePath = this.getImageBasePath();

          const promises = files.map(async (filename) => {
            const key = `${basePath}/${filename}`;

            // Проверяем blobUrl в памяти
            if (this.imageUrlCache.has(key)) {
              return this.imageUrlCache.get(key);
            }

            // Берём из IndexedDB
            let record = await ImageDB.get(key);
            let blob;

            if (record && record.blob) {
              blob = record.blob;
            } else {
              // Нет в IndexedDB → качаем
              const response = await fetch(key);
              blob = await response.blob();
              await ImageDB.put(key, blob);
            }

            // Создаём blobUrl
            const blobUrl = URL.createObjectURL(blob);
            this.imageUrlCache.set(key, blobUrl);

            return blobUrl;
          });

          return Promise.all(promises);
        }



      getCurrentThemeColors() {
        const themeConfig = AVAILABLE_THEMES[this.currentTheme];
        if (!themeConfig || !themeConfig.themes || themeConfig.themes.length === 0) {
         
          return THEMES[Math.floor(Math.random() * THEMES.length)];
        }
        
      
        const themes = themeConfig.themes;
        let selectedPaletteIndex;
        
        if (this.pinnedPaletteIndex >= 0 && this.pinnedPaletteIndex < themes.length) {
         
          selectedPaletteIndex = this.pinnedPaletteIndex;
        } else {
       
          selectedPaletteIndex = Math.floor(Math.random() * themes.length);
        }
        
        const selectedPalette = themes[selectedPaletteIndex];
        
      
        const shuffledPalette = [...selectedPalette].sort(() => Math.random() - 0.5);
        
        return shuffledPalette;
      }

  
      updateTheme(newTheme) {
        this.currentTheme = newTheme;
        
      
        const themeConfig = AVAILABLE_THEMES[newTheme];
        if (themeConfig && themeConfig.themes && this.pinnedPaletteIndex >= 0) {
          if (this.pinnedPaletteIndex >= themeConfig.themes.length) {
          
            this.pinnedPaletteIndex = -1;
            showMessage('Закрепленная палитра недоступна в новой теме', 'info');

          }
        }
        
        this.theme = this.getCurrentThemeColors();
        this.maxColors = Math.min(this.maxColors, this.theme.length);
        this.redrawAll();
      }

 

      togglePalettePin(paletteIndex) {
        if (this.pinnedPaletteIndex === paletteIndex) {
          this.pinnedPaletteIndex = -1; // снять закрепление
          showMessage('Палитра откреплена', 'success');
        } else {
          this.pinnedPaletteIndex = paletteIndex; // закрепить
          showMessage(`Палитра ${paletteIndex + 1} закреплена`, 'success');
        }

        this.updateThemePreview();
      }

    
      getCurrentPaletteIndex() {
        const themeConfig = AVAILABLE_THEMES[this.currentTheme];
        if (!themeConfig || !themeConfig.themes) return -1;
        
       
        const palettes = themeConfig.themes;
        for (let i = 0; i < palettes.length; i++) {
          const palette = palettes[i];
        
          const currentColors = new Set(this.theme);
          const paletteColors = new Set(palette);
          
          if (this.theme.every(color => paletteColors.has(color))) {
            return i;
          }
        }
        return -1; 
    }
updateSettingsDisplay() {


  const sizeSlider = document.getElementById('size-slider');
  const maxColorsSlider = document.getElementById('maxColors-slider');
  const minPairSlider = document.getElementById('minPair-slider');

  if (sizeSlider && maxColorsSlider && minPairSlider) {
    // ======== Размер поля ========
    const currentSize = `${this.width}x${this.height}`;
    const sizeMap = { '10x10': 1, '10x15': 2, '10x20': 3 };
    sizeSlider.value = sizeMap[currentSize] || 0;
    document.getElementById('settings-size').textContent = currentSize;

    // ======== Количество цветов ========
    const colorsBounds = (() => {
      const paletteColors = this.getCurrentThemeColors?.().length || 0;
      const roomKey = document.getElementById('room-selector')?.value || 'room1';
      const roomImages = (AVAILABLE_ROOM[roomKey]?.themes?.[0]?.length) || 0;
      const nmin = 15;
      const nmax = Math.max(nmin, Math.min(paletteColors || 0, roomImages || 0));
      return { nmin, nmax };
    })();

    const { nmin: nminColors, nmax: nmaxColors } = colorsBounds;
    const maxColorsValue = Math.min(Math.max(this.maxColors ?? CONFIG.maxColors ?? nminColors, nminColors), nmaxColors);
    const totalPositionsColors = (nmaxColors - nminColors + 1) + 2;

    maxColorsSlider.min = 0;
    maxColorsSlider.max = totalPositionsColors - 1;
    maxColorsSlider.step = 1;
    maxColorsSlider.dataset.nmin = nminColors;
    maxColorsSlider.dataset.nmax = nmaxColors;
    maxColorsSlider.dataset.totalPositions = totalPositionsColors;
    maxColorsSlider.dataset.currentNumeric = maxColorsValue;
    maxColorsSlider.dataset.mode = 'value';
    document.getElementById('settings-maxColors').textContent = String(maxColorsValue);

    // ======== Минимум пар ========
    let totalCells = this.width * this.height;
    const colorsCount = maxColorsValue;
    const nminPairs = 1; // фиксированное значение
let nmaxPairs = Math.max(1, Math.floor(totalCells / Math.max(colorsCount * 2, 1)));
    if (nmaxPairs < nminPairs) nmaxPairs = nminPairs;

    const totalPositionsPairs = Math.max(3, (nmaxPairs - nminPairs + 1) + 2);
    minPairSlider.min = 0;
    minPairSlider.max = totalPositionsPairs - 1;
    minPairSlider.step = 1;
    minPairSlider.dataset.nmin = nminPairs;
    minPairSlider.dataset.nmax = nmaxPairs;
    minPairSlider.dataset.totalPositions = totalPositionsPairs;

    const minPairValue = Math.min(Math.max(this.minPair ?? CONFIG.minPair ?? nminPairs, nminPairs), nmaxPairs);
    minPairSlider.dataset.currentNumeric = minPairValue;
    minPairSlider.dataset.mode = 'value';
    document.getElementById('settings-minPair').textContent = String(minPairValue);

    // ======== Fullscreen ========
    const fullscreenSlider = document.getElementById('fullscreen-slider');
    if (fullscreenSlider) {
      const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement);
      fullscreenSlider.value = isFullscreen ? '1' : '0';
      document.getElementById('settings-fullscreen').textContent = isFullscreen ? 'Включен' : 'Выключен';
    }

    // ======== Тема ========
    const themeSelector = document.getElementById('theme-selector');
    if (themeSelector) {
      themeSelector.value = this.currentTheme;
      const themeName = AVAILABLE_THEMES[this.currentTheme]?.name || 'По умолчанию';
      document.getElementById('settings-theme').textContent = themeName;

      const customInput = document.getElementById('custom-theme-input');
      if (customInput) customInput.style.display = this.currentTheme === 'custom' ? 'block' : 'none';

      this.updateThemePreview();
    }
  }

  // ======== Use Images ========
  const useImagesSlider = document.getElementById('useImages-slider');
  const useImagesLabel = document.getElementById('settings-useImages');
  if (useImagesSlider && useImagesLabel) {
    useImagesLabel.textContent = useImagesSlider.value === '1' ? 'Включено' : 'Выключено';
    useImagesSlider.oninput = (e) => {
      useImagesLabel.textContent = e.target.value === '1' ? 'Включено' : 'Выключено';
    };
  }

  // ======== Комната ========
  const roomSelector = document.getElementById('room-selector');
  const roomLabel = document.getElementById('settings-room');
  if (roomSelector && roomLabel) {
    roomLabel.textContent = roomSelector.options[roomSelector.selectedIndex]?.text || '';
    roomSelector.onchange = () => {
      roomLabel.textContent = roomSelector.options[roomSelector.selectedIndex]?.text || '';
    };
  }
}



    updateThemePreview() {
      const previewContainer = document.getElementById('theme-preview');
      if (!previewContainer) return;
      
      previewContainer.innerHTML = '';
      
      const themeConfig = AVAILABLE_THEMES[this.currentTheme];
      if (!themeConfig || !themeConfig.themes || themeConfig.themes.length === 0) {
        previewContainer.innerHTML = '<div class="theme-preview empty">Нет доступных цветов</div>';
        return;
      }
      
      const palettes = themeConfig.themes;
      
      palettes.forEach((palette, paletteIndex) => {
        const headerWrapper = document.createElement('div');
        headerWrapper.style.cssText = 'display: flex; align-items: center; justify-content: space-between; margin: 8px 0 4px;';

        const paletteHeader = document.createElement('div');
        paletteHeader.className = 'palette-header';

        const currentPaletteIndex = this.getCurrentPaletteIndex();
        const isCurrentPalette = currentPaletteIndex === paletteIndex;
        const isPinnedPalette = this.pinnedPaletteIndex === paletteIndex;

        // текст заголовка
        const headerLabel = document.createElement('span');
        headerLabel.textContent = `Палитра ${paletteIndex + 1}${isCurrentPalette ? ' (текущая)' : ''}`;

        // иконка 📌
        const pinIcon = document.createElement('span');
        pinIcon.textContent = ' 📌';
        pinIcon.style.marginLeft = '6px';
        pinIcon.style.filter = isPinnedPalette ? 'grayscale(0)' : 'grayscale(100%)';
        pinIcon.style.transition = 'filter 0.2s ease';

        paletteHeader.appendChild(headerLabel);
        paletteHeader.appendChild(pinIcon);

        paletteHeader.style.cssText = `
          font-size: 12px;
          color: ${isCurrentPalette ? '#64e0d0' : '#8b9bb4'};
          font-weight: ${isCurrentPalette ? '600' : '400'};
          cursor: pointer;
          user-select: none;
        `;

        paletteHeader.addEventListener('click', () => {
          this.togglePalettePin(paletteIndex);
        });

        // кнопка копирования 📋
        const copyBtn = document.createElement('button');
        copyBtn.innerHTML = '📋';
        copyBtn.title = 'Скопировать все цвета';
        copyBtn.style.cssText = 'background: none; border: none; cursor: pointer; font-size: 14px; padding: 0; color: #8b9bb4;';
        
        copyBtn.addEventListener('click', (e) => {
          e.stopPropagation(); // не триггерим togglePalettePin
          const text = palette.join(', ');
          navigator.clipboard.writeText(text).then(() => {
            copyBtn.innerHTML = '✅'; // временно показываем галочку
            setTimeout(() => { copyBtn.innerHTML = '📋'; }, 1000);
          });
        });

        headerWrapper.appendChild(paletteHeader);
        headerWrapper.appendChild(copyBtn);
        previewContainer.appendChild(headerWrapper);

        const paletteContainer = document.createElement('div');
        paletteContainer.className = 'palette-container';
        const borderColor = isCurrentPalette ? '#64e0d0' : (isPinnedPalette ? '#ffaa00' : '#1f2940');
        const bgColor = isCurrentPalette ? '#1a2130' : (isPinnedPalette ? '#2a1f0a' : '#0a0f1a');
        paletteContainer.style.cssText = `display: flex; flex-wrap: wrap; gap: 4px; margin-bottom: 12px; padding: 6px; background: ${bgColor}; border-radius: 6px; border: 1px solid ${borderColor};`;

        if (this.currentTheme === 'custom') {
          paletteContainer.classList.add('swipeable');
          paletteContainer.dataset.paletteIndex = paletteIndex;

          const swipeOverlay = document.createElement('div');
          swipeOverlay.className = 'swipe-overlay';
          swipeOverlay.textContent = 'Удалить';

          // вставляем overlay в начало, чтобы он был "подложкой"
          paletteContainer.insertBefore(swipeOverlay, paletteContainer.firstChild);

          this.addSwipeHandlers(paletteContainer, paletteIndex);
        }


        palette.forEach((color, colorIndex) => {
          const colorPreview = document.createElement('div');
          colorPreview.className = 'color-preview';
          colorPreview.style.backgroundColor = color;
          colorPreview.title = `Палитра ${paletteIndex + 1}, Цвет ${colorIndex + 1}: ${color}`;
          paletteContainer.appendChild(colorPreview);
        });

        previewContainer.appendChild(paletteContainer);
      });

updateStats();

    }


    addSwipeHandlers(element, paletteIndex) {
      let startX = 0;
      let currentX = 0;
      let isSwiping = false;

      const softThreshold = 60;   // «визуальный свайп» (подвинуть, но не удалить)
      const deleteThreshold = 200; // явный длинный свайп для удаления

      const onTouchStart = (e) => {
        startX = e.touches[0].clientX;
        currentX = startX;
        isSwiping = true;
        element.classList.add('swiping');
        element.style.transition = 'none';
      };

      const onTouchMove = (e) => {
        if (!isSwiping) return;
        currentX = e.touches[0].clientX;
        const deltaX = currentX - startX;

        if (deltaX < 0) {
          element.style.transform = `translateX(${deltaX}px)`;
          element.style.opacity = Math.max(0.4, 1 + deltaX / deleteThreshold);
        }
      };

      const onTouchEnd = () => {
        if (!isSwiping) return;
        isSwiping = false;
        element.classList.remove('swiping');
        element.style.transition = 'transform 0.25s ease, opacity 0.25s ease';

        const deltaX = currentX - startX;

        if (deltaX < -deleteThreshold) {
          // длинный и явный свайп → удаляем
          this.deleteCustomPalette(paletteIndex);
        } else {
          // иначе возвращаем назад
          element.style.transform = '';
          element.style.opacity = '';
        }
      };

      element.addEventListener('touchstart', onTouchStart);
      element.addEventListener('touchmove', onTouchMove);
      element.addEventListener('touchend', onTouchEnd);
    }


    deleteCustomPalette(paletteIndex) {
      const paletteContainer = document.querySelector(`[data-palette-index="${paletteIndex}"]`);
      if (paletteContainer) {
        paletteContainer.classList.add('deleting');
        setTimeout(() => {
          paletteContainer.remove();
          THEMES_CUSTOM.splice(paletteIndex, 1);
          this.updateThemePreview();
        }, 300);
      }
    }

    calculateMaxHeight() {
      const viewportHeight = window.innerHeight;

      const root = document.documentElement;
      const styles = getComputedStyle(root);

      const cellHeight = parseFloat(styles.getPropertyValue('--cell')) || 56;
      const gapHeight  = parseFloat(styles.getPropertyValue('--gap')) || 6;

      const hud = document.querySelector('.hud');
      const hudHeight = hud ? hud.offsetHeight : 0;

      const game = document.querySelector('.game');
      const rowGap = game ? parseFloat(getComputedStyle(game).rowGap) || 0 : 0;

      const outerMargin = 5; // фиксированный запас

      // доступная высота = экран - hud - gap между hud и board - отступы
      const availableHeight = viewportHeight - hudHeight - rowGap - 2 * outerMargin;

      // формула: cell*N + gap*(N-1) <= availableHeight
      const maxCells = Math.floor((availableHeight + gapHeight) / (cellHeight + gapHeight));

      // ограничиваем диапазон (например 8–20)
      return Math.max(8, Math.min(20, maxCells));
    }


      // === Генерация поля с гарантированными парами ===
      generateBoard() {
        const total = this.width * this.height;
        const flat = Array(total).fill(null);

        // Коррекция MIN_pair на случай, если не помещается
        const maxPairsPossible = Math.floor(total / (2 * this.maxColors));
        const effectiveMinPair = Math.min(this.minPair, maxPairsPossible);
        if (effectiveMinPair !== this.minPair) {
          this.minPair = effectiveMinPair;
          CONFIG.minPair = effectiveMinPair;
        }

        // Собираем все индексы и перемешиваем один раз
        const indices = Array.from({ length: total }, (_, i) => i);
        for (let i = indices.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [indices[i], indices[j]] = [indices[j], indices[i]];
        }

        let pos = 0;

        // 1) обязательные пары для каждого цвета
        for (let color = 0; color < this.maxColors; color++) {
          for (let p = 0; p < effectiveMinPair; p++) {
            flat[indices[pos++]] = color;
            flat[indices[pos++]] = color;
          }
        }

        // 2) оставшиеся клетки — случайными парами
        while (pos < indices.length) {
          const color = Math.floor(Math.random() * this.maxColors);
          flat[indices[pos++]] = color;
          flat[indices[pos++]] = color;
        }

        // Преобразуем в 2D
        const grid = [];
        for (let y = 0; y < this.height; y++) {
          grid[y] = [];
          for (let x = 0; x < this.width; x++) {
            grid[y][x] = flat[idx(x, y, this.width)];
          }
        }

        return grid;
      }


      #placeRandomPair(flat, color) {
        const a = this.#randomEmptyIndex(flat);
        flat[a] = color;
        const b = this.#randomEmptyIndex(flat);
        flat[b] = color;
      }
      #randomEmptyIndex(flat) {
        let i = Math.floor(Math.random() * flat.length);
        while (flat[i] !== null) i = Math.floor(Math.random() * flat.length);
        return i;
      }
      // === Отрисовка ===

      mount(cell) {
      const boardEl = document.getElementById('board');
      boardEl.innerHTML = '';
      boardEl.style.setProperty('--width', this.width);
      boardEl.style.setProperty('--height', this.height);

      // Отменяем предыдущее анимирование (и timeouts, на всякий случай)
      if (this._revealTimer) {
        cancelAnimationFrame(this._revealTimer);
        this._revealTimer = null;
      }
      if (this._revealTimers && this._revealTimers.length) {
        for (const t of this._revealTimers) clearTimeout(t);
      }
      this._revealTimers = [];

      for (let y = 0; y < this.height; y++) {
        for (let x = 0; x < this.width; x++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.tabIndex = -1;
          cell.dataset.x = x;
          cell.dataset.y = y;

          const color = this.board[y][x];
          if (color !== null && color !== undefined) {
            // пока не задаём CSS-переменную --color — клетка остаётся серой,
            // и у неё data-activated = '0' => переходы/блик будут отключены по CSS

            cell.classList.add('filled');
            cell.dataset.colorId = String(color);
            cell.dataset.activated = '0';
          } else {
            cell.dataset.activated = '0';

          }

          cell.addEventListener('click', (e) => this.onCellClick(e, x, y));
          cell.addEventListener('pointerdown', (e) => this.onPointerDown(e, x, y));

          boardEl.appendChild(cell);

        }
      }

      // запуск «включения лампочек»
      //this.runInitialReveal(2500);
              window.hideLoader(() => {
          this.runInitialReveal(2500);
        });

    }


    #applyColor(cell, colorId, instant = false) {
      const colorHex = this.theme[colorId % this.theme.length];
      // общая часть
      cell.classList.add('filled');
      cell.classList.remove('vanish');
      cell.dataset.colorId = String(colorId);

      if (instant) {
        // мгновенно: временно отключаем inline transition и сразу применяем цвет
        const prevTransition = cell.style.transition;
        cell.style.transition = 'none';
        cell.dataset.activated = '1';
        cell.style.setProperty('--color', colorHex);

        // форс рефлоу, затем восстановим transition
        void cell.offsetWidth;
        cell.style.transition = prevTransition;
      } else {
        // обычный (анимационный) путь: ставим activated, затем меняем цвет
        // — это активирует CSS-переходы, определенные в .cell.filled[data-activated="1"]
        cell.dataset.activated = '1';
        cell.style.setProperty('--color', colorHex);

      }
    }


    // вернуть массив файлов для текущей комнаты (одно измерение — список файлов)
    getCurrentRoomImages() {
      const roomConfig = AVAILABLE_ROOM[this.currentRoom]; // <-- use this.currentRoom
      if (!roomConfig || !Array.isArray(roomConfig.themes) || roomConfig.themes.length === 0) {
        return { folder: '', files: [] };
      }

      const themes = roomConfig.themes;
      const idx = (this.pinnedPaletteIndex >= 0 && this.pinnedPaletteIndex < themes.length)
        ? this.pinnedPaletteIndex
        : Math.floor(Math.random() * themes.length);

      const selected = themes[idx] || [];
      // roomConfig.folder обязан содержать 'img' или 'img2' или любой путь, который вы используете
      return { folder: roomConfig.folder, files: Array.isArray(selected) ? selected.slice() : [] };
    }



    // вызываем при старте и при переключении темы/включении режимов

    ensureImageModeLimits() {
      this.palette = this.getCurrentThemeColors();
      const roomData = this.getCurrentRoomImages();
      this.roomFolder = roomData.folder;
      this.roomImages = roomData.files;

      if (CONFIG.useImages && this.roomImages.length > 0) {
        const available = this.roomImages.length;
        if (CONFIG.maxColors > available) {
          CONFIG.maxColors = available;
          this.maxColors = available;
          const slider = document.getElementById('maxColors-slider');
          if (slider) {
            slider.value = available;
            document.getElementById('settings-maxColors').textContent = available;
          }
        } else {
          this.maxColors = Math.min(this.maxColors, CONFIG.maxColors);
        }
        this.useImages = true;
      } else {
        this.useImages = false;
        this.maxColors = Math.min(this.maxColors, this.palette.length);
      }
      
    }


    // главный хелпер: назначить background-image для одной .cell на основе data-color-id

applyImageBackgroundToCell(cell) {
  const id = Number(cell.dataset.colorId);

  if (!this.useImages || !Array.isArray(this.roomImages) || this.roomImages.length === 0) {
    cell.style.setProperty('--img-url', '');
    return;
  }

  const idx = Math.max(0, Math.min(id, this.roomImages.length - 1));
  const filename = this.roomImages[idx];
  const basePath = this.getImageBasePath();
  const key = `${basePath}/${filename}`;

  // Берём blobUrl из кэша
  let blobUrl = this.imageUrlCache.get(key);

  if (!blobUrl) {
    // пока ставим пустой фон
    cell.style.setProperty('--img-url', '');

    // фоновая подгрузка
    this.preloadImages([filename]).then(() => {
      const readyUrl = this.imageUrlCache.get(key);
      if (readyUrl) {
        cell.style.setProperty('--img-url', `url("${readyUrl}")`);
      }
    });
    return;
  }

  cell.style.setProperty('--img-url', `url("${blobUrl}")`);
}









      runInitialReveal(totalMs = 2500, batchSize = 16, cell) {
        const cellsToReveal = [];
        for (let y = 0; y < this.height; y++) {
          for (let x = 0; x < this.width; x++) {
            const el = this.getCellEl(x, y);
            if (!el) continue;
            if (el.classList.contains('filled') && el.dataset.activated !== '1') {
              const colorId = Number(el.dataset.colorId);
              if (!Number.isNaN(colorId)) {
                cellsToReveal.push({ x, y, el, colorId, diag: x + y });
              }
            }
          }
        }
        if (cellsToReveal.length === 0) return;

        // сортировка по диагоналям
        cellsToReveal.sort((a, b) => a.diag - b.diag || a.x - b.x);

        // отменяем старый rAF
        if (this._revealTimer) {
          cancelAnimationFrame(this._revealTimer);
          this._revealTimer = null;
        }

        const lastIndex = cellsToReveal.length - 1;
        const startTime = performance.now();
        this._revealIndex = 0;

        const animate = (now) => {
          const elapsed = now - startTime;
          const progress = Math.min(elapsed / totalMs, 1);
          const targetIndex = Math.floor(progress * (lastIndex + 1));

          // вместо того, чтобы открывать сразу все targetIndex,
          // откроем только batchSize за кадр
          let processed = 0;
          while (this._revealIndex < targetIndex && processed < batchSize) {
            const { el, colorId } = cellsToReveal[this._revealIndex];
            if (el.dataset.activated !== '1') {
              const colorHex = this.theme[colorId % this.theme.length];
              el.dataset.activated = '1';
              el.style.setProperty('--color', colorHex);

              // применение картинки, если включено
              this.applyImageBackgroundToCell(el);

            }
            this._revealIndex++;
            processed++;
          }

          if (progress < 1 || this._revealIndex < cellsToReveal.length) {
            this._revealTimer = requestAnimationFrame(animate);
          } else {
            this._revealTimer = null;
            this._revealIndex = 0;
          }
        };

        this._revealTimer = requestAnimationFrame(animate);
      }



      #clearCell(cell) {
        cell.removeAttribute('style');
        cell.classList.remove('filled', 'candidate', 'source');
        cell.classList.add('vanish');
        delete cell.dataset.colorId;
        cell.dataset.activated = '0';
        setTimeout(() => { cell.classList.remove('vanish'); }, 260);
      }


      getCellEl(x, y) {
        return document.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`);
      }
      // === Поиск ближайших по 4 направлениям до первой преграды ===
      findNearestBlocksSameColor(x, y) {
        const color = this.board[y][x];
        if (color === null) return [];

        const dirs = [ [1,0], [-1,0], [0,1], [0,-1] ];
        const found = [];
        for (const [dx, dy] of dirs) {
          let cx = x + dx, cy = y + dy;
          while (cx >= 0 && cx < this.width && cy >= 0 && cy < this.height) {
            const c = this.board[cy][cx];
            if (c !== null) { 
              if (c === color) found.push({ x: cx, y: cy });
              break;
            }
            cx += dx; cy += dy;
          }
        }
        return found; // массив координат кандидатов
      }
      // === Drag & Move Mechanics ===
      onPointerDown(e, x, y) {
        // Если есть подсказка — запомним её для текущего действия и сбросим визуально
        let hintForThisAction = null;
        let isHintedStart = false;
        if (this.superHint) {
          isHintedStart = (this.superHint.a.x === x && this.superHint.a.y === y) || (this.superHint.b.x === x && this.superHint.b.y === y);
          hintForThisAction = this.superHint;
          // Сбрасываем подсказку и запускаем кулдаун, но не перехватываем действия
          this.clearSuperHint(false);
          /*this.startHintCooldown();*/ //расход подсказки при клике
        }
        if (this.state.locked) return;
        const color = this.board[y][x];
        if (color === null) return;
        e.preventDefault();
        // Преддвижение: первичный поиск пар на исходной позиции
        const preCandidates = this.findNearestBlocksSameColor(x, y);
        if (preCandidates.length === 1) {
          const { x: tx, y: ty } = preCandidates[0];
          // Центрируем все блоки перед удалением пары
          this.centerAllBlocks();
          this.removePair(x, y, tx, ty);
          return;
        }
        if (preCandidates.length > 1) {
          // Если стартовали по подсвеченному блоку — обойти режим выбора и удалить супер-пару
          if (hintForThisAction && isHintedStart) {
            const other = (hintForThisAction.a.x === x && hintForThisAction.a.y === y) ? hintForThisAction.b : hintForThisAction.a;
            // Центрируем все блоки перед удалением супер-пары
            //this.centerAllBlocks(); ИЗБЫТОЧНО 1509
            this.removePair(x, y, other.x, other.y);
            return;
          }
          const boardEl = document.getElementById('board');
          // Центрируем все блоки перед входом в режим выбора
          //this.centerAllBlocks(); ИЗБЫТОЧНО 1509
          this.enterSelectionMode(x, y, preCandidates);
          boardEl.classList.add('dimmed');
          return;
        }
        this.drag.active = true;
        this.drag.startX = x;
        this.drag.startY = y;
        this.drag.axis = null;
        this.drag.startClientX = e.clientX;
        this.drag.startClientY = e.clientY;
        this.drag.stepPx = this.#getStepPixels();
        this.drag.previewCells = [];
        this.drag.previewOffset = 0;
        // запомним подсказку для возможной логики после перемещения
        this.drag.hintForThisAction = hintForThisAction;
        this.drag.startedOnHinted = !!isHintedStart;
        this.highlightCross(x, y);
        this._bindPointerListeners();
      }

      _bindPointerListeners() {
        this._onPointerMove = this._onPointerMove || ((ev) => this.onPointerMove(ev));
        this._onPointerUp = this._onPointerUp || ((ev) => this.onPointerUp(ev));
        window.addEventListener('pointermove', this._onPointerMove);
        window.addEventListener('pointerup', this._onPointerUp, { once: true });
        window.addEventListener('pointercancel', this._onPointerUp, { once: true });
      }

      _unbindPointerListeners() {
        window.removeEventListener('pointermove', this._onPointerMove);
      }

      onPointerMove(e) {
        if (!this.drag.active) return;
        const dx = e.clientX - this.drag.startClientX;
        const dy = e.clientY - this.drag.startClientY;
        if (this.drag.axis === null) {
          if (Math.abs(dx) < this.drag.thresholdPx && Math.abs(dy) < this.drag.thresholdPx) return;
          this.drag.axis = Math.abs(dx) >= Math.abs(dy) ? 'x' : 'y';
        }
        const axis = this.drag.axis;
        const stepPx = this.drag.stepPx;
        const delta = axis === 'x' ? dx : dy;
        if (delta === 0) { this.clearPreviewTransforms(); return; }
        const sign = Math.sign(delta);
        // максимально допустимое число шагов (в клетках) по текущему направлению
        const allowedSteps = Math.abs(this.computeAllowedShift(this.drag.startX, this.drag.startY, axis, sign * 999));
        if (allowedSteps === 0) { this.clearPreviewTransforms(); return; }
        const desiredStepsFloat = delta / stepPx;
        const clampedStepsFloat = Math.max(-allowedSteps, Math.min(allowedSteps, desiredStepsFloat));
        const offsetPx = clampedStepsFloat * stepPx;
        const { from, to } = this.getChainRange(this.drag.startX, this.drag.startY, axis, sign);
        this.applyPreviewTransforms(axis, this.drag.startX, this.drag.startY, from, to, offsetPx);
        // обновить подсветку текущего пересечения по ближайшей клетке к положению курсора
        const roundedSteps = Math.round(clampedStepsFloat);
        const hx = axis === 'x' ? Math.max(0, Math.min(this.width - 1, this.drag.startX + roundedSteps)) : this.drag.startX;
        const hy = axis === 'y' ? Math.max(0, Math.min(this.height - 1, this.drag.startY + roundedSteps)) : this.drag.startY;
        this.highlightCross(hx, hy);
      }

      onPointerUp(e) {
        if (!this.drag.active) return;
        const dx = e.clientX - this.drag.startClientX;
        const dy = e.clientY - this.drag.startClientY;
        const axis = this.drag.axis;
        this.drag.active = false;
        this._unbindPointerListeners();
        this.clearHighlightCross();
        const stepPx = this.drag.stepPx;

        if (!axis) {
          // treat as click - центрируем блоки при клике
          //this.centerAllBlocks(); ИЗБЫТОЧНО ?? 1509
          return;
        }
        const desiredSteps = axis === 'x' ? Math.round(dx / stepPx) : Math.round(dy / stepPx);
        if (desiredSteps === 0) {
          // no move - центрируем блоки при клике без движения
          this.centerAllBlocks();
          return;
        }
        const actualSteps = this.computeAllowedShift(this.drag.startX, this.drag.startY, axis, desiredSteps);
        if (actualSteps === 0) return;
        const sign = Math.sign(actualSteps);
        const range = this.getChainRange(this.drag.startX, this.drag.startY, axis, sign);
        const snapshot = this.captureChainSnapshot(this.drag.startX, this.drag.startY, axis, range.from, range.to);

        const { x: nx, y: ny } = this.moveChain(this.drag.startX, this.drag.startY, axis, actualSteps);
        this._blockClicksUntil = performance.now() + 200;
        // новое правило: если пар нет, откатить перемещение
        const candidates = this.findNearestBlocksSameColor(nx, ny);
        const boardEl = document.getElementById('board');

        if (candidates.length === 0) {
          // Откатываем визуально (убираем preview transform), и восстанавливаем snapshot.
          // clearPreviewTransforms нужно вызвать до restore, чтобы ячейки не оставались с translate.
          this.clearPreviewTransforms();
          // Восстанавливаем состояние цепочки. (Важно: captureChainSnapshot не должен восстанавливать ячейки, которые
          // намеренно должны исчезнуть — но тут нет найденных кандидатов, так что обычный откат корректен.)
          this.restoreChainSnapshot(snapshot, axis, actualSteps);
          // Центрируем все блоки после отката
          //this.centerAllBlocks(); ИЗБЫТОЧНО ?? 1509
          return;
        }
        // Если нашли кандидатов — не откатываем transform: пусть блок останется визуально на месте отпускания.
        // Затем удаляем пару и плавно убираем их визуально (fade-out).
        const scheduleClearPreview = () => {
          // небольшой таймаут — даём время анимации fade-out выполниться, затем чистим preview transforms.
          setTimeout(() => {
            this.clearPreviewTransforms();
            // также можно принудительно очистить вспомогательные классы
            if (boardEl) boardEl.classList.remove('noreturn');
            // Центрируем все блоки после очистки preview transforms
            //this.centerAllBlocks();
          }, 0);
        };
        // --- 1 кандидат: удаляем напрямую ---
        if (candidates.length === 1) {
          const { x: tx, y: ty } = candidates[0];
          // Визуально: отключаем анимацию возвращения (чтобы не было эффекта "отката")
          if (boardEl) boardEl.classList.add('noreturn');

          this.removePair(nx, ny, tx, ty);
          scheduleClearPreview();
          // Центрируем все блоки после успешного удаления
          //setTimeout(() => this.centerAllBlocks(), 100); ИЗБЫТОЧНО ?? 1509
          return;
        }
        // --- несколько кандидатов — если тянули, начав с подсказанного блока, удалить супер-пару ---
        if (this.drag.hintForThisAction && this.drag.startedOnHinted) {
          const { a, b } = this.drag.hintForThisAction;
          const isStartA = a.x === this.drag.startX && a.y === this.drag.startY;
          const partner = isStartA ? b : a;
          // учтём, что партнёр мог быть частью сдвигаемой цепочки и сместился
          let px = partner.x, py = partner.y;
          if (axis === 'x' && partner.y === this.drag.startY) {
            const rng = this.getChainRange(this.drag.startX, this.drag.startY, axis, sign);
            if (partner.x >= rng.from && partner.x <= rng.to) px = partner.x + actualSteps;
          }
          if (axis === 'y' && partner.x === this.drag.startX) {
            const rng = this.getChainRange(this.drag.startX, this.drag.startY, axis, sign);
            if (partner.y >= rng.from && partner.y <= rng.to) py = partner.y + actualSteps;
          }

          if (boardEl) boardEl.classList.add('noreturn');

          this.removePair(nx, ny, px, py);
          scheduleClearPreview();
          // Центрируем все блоки после удаления супер-пары
          //setTimeout(() => this.centerAllBlocks(), 100); ИЗБЫТОЧНО 1509
          return;
        }
        // иначе — режим выбора (selection mode)
        this.enterSelectionMode(nx, ny, candidates);
        if (boardEl) boardEl.classList.add('dimmed');
        //this.centerAllBlocks(); ИЗБЫТОЧНО
        // Примечание: в режиме выбора мы оставляем preview-transform, чтобы игрок видел, где он отпустил блок.
      }



      #getStepPixels() {
        const rootStyles = getComputedStyle(document.documentElement);
        const cell = parseFloat(rootStyles.getPropertyValue('--cell')) || 56;
        const gap = parseFloat(rootStyles.getPropertyValue('--gap')) || 6;
        return cell + gap;
      }
      // Функция для центрирования всех блоков на игровом поле
      centerAllBlocks() {
        for (let y = 0; y < this.height; y++) {
          for (let x = 0; x < this.width; x++) {
            const cell = this.getCellEl(x, y);
            if (cell) {
              // Убираем все transform стили, чтобы блоки вернулись в исходное положение
              cell.style.transform = '';
              cell.classList.remove('dragging');
            }
          }
        }
      }

      computeAllowedShift(x0, y0, axis, desiredSteps) {
        const sign = Math.sign(desiredSteps);
        if (sign === 0) return 0;
        const limit = Math.abs(desiredSteps);
        if (axis === 'x') {
          const y = y0;
          if (sign > 0) {
            let chainEnd = x0;
            while (chainEnd + 1 < this.width && this.board[y][chainEnd + 1] !== null) chainEnd++;
            let empty = 0; let i = chainEnd + 1;
            while (i < this.width && this.board[y][i] === null) { empty++; i++; }
            return Math.min(limit, empty) * sign;
          } else {
            let chainStart = x0;
            while (chainStart - 1 >= 0 && this.board[y][chainStart - 1] !== null) chainStart--;
            let empty = 0; let i = chainStart - 1;
            while (i >= 0 && this.board[y][i] === null) { empty++; i--; }
            return Math.min(limit, empty) * sign;
          }
        } else {
          const x = x0;
          if (sign > 0) {
            let chainEnd = y0;
            while (chainEnd + 1 < this.height && this.board[chainEnd + 1][x] !== null) chainEnd++;
            let empty = 0; let i = chainEnd + 1;
            while (i < this.height && this.board[i][x] === null) { empty++; i++; }
            return Math.min(limit, empty) * sign;
          } else {
            let chainStart = y0;
            while (chainStart - 1 >= 0 && this.board[chainStart - 1][x] !== null) chainStart--;
            let empty = 0; let i = chainStart - 1;
            while (i >= 0 && this.board[i][x] === null) { empty++; i--; }
            return Math.min(limit, empty) * sign;
          }
        }
      }

      getChainRange(x0, y0, axis, sign) {
        if (axis === 'x') {
          const y = y0;
          if (sign > 0) {
            let end = x0;
            while (end + 1 < this.width && this.board[y][end + 1] !== null) end++;
            return { from: x0, to: end };
          } else {
            let start = x0;
            while (start - 1 >= 0 && this.board[y][start - 1] !== null) start--;
            return { from: start, to: x0 };
          }
        } else {
          const x = x0;
          if (sign > 0) {
            let end = y0;
            while (end + 1 < this.height && this.board[end + 1][x] !== null) end++;
            return { from: y0, to: end };
          } else {
            let start = y0;
            while (start - 1 >= 0 && this.board[start - 1][x] !== null) start--;
            return { from: start, to: y0 };
          }
        }
      }

      captureChainSnapshot(x0, y0, axis, from, to) {
        const items = [];
        if (axis === 'x') {
          const y = y0;
          for (let x = from; x <= to; x++) {
            items.push({ x, y, color: this.board[y][x] });
          }
        } else {
          const x = x0;
          for (let y = from; y <= to; y++) {
            items.push({ x, y, color: this.board[y][x] });
          }
        }
        return { axis, items };
      }

      restoreChainSnapshot(snapshot, axis, steps) {
        const sign = Math.sign(steps);
        if (snapshot.axis !== axis) return;
        for (const it of snapshot.items) {
          const dx = axis === 'x' ? it.x + steps : it.x;
          const dy = axis === 'y' ? it.y + steps : it.y;
          if (dy >= 0 && dy < this.height && dx >= 0 && dx < this.width) {
            this.board[dy][dx] = null;
          }
        }
        for (const it of snapshot.items) {
          this.board[it.y][it.x] = it.color;
        }
        if (axis === 'x') this.redrawRow(snapshot.items[0].y);
        else this.redrawColumn(snapshot.items[0].x);
      }

      applyPreviewTransforms(axis, x0, y0, from, to, offsetPx) {
        this.clearPreviewTransforms();
        this.drag.previewCells = [];
        if (axis === 'x') {
          const y = y0;
          for (let x = from; x <= to; x++) {
            const el = this.getCellEl(x, y);
            if (el) {
              el.style.transform = `translate3d(${offsetPx}px, 0, 0)`;
              el.classList.add('dragging');
              this.drag.previewCells.push(el);
            }
          }
        } else {
          const x = x0;
          for (let y = from; y <= to; y++) {
            const el = this.getCellEl(x, y);
            if (el) {
              el.style.transform = `translate3d(0, ${offsetPx}px, 0)`;
              el.classList.add('dragging');
              this.drag.previewCells.push(el);
            }
          }
        }
      }

      clearPreviewTransforms() {
        if (!this.drag.previewCells) return;
        for (const el of this.drag.previewCells) {
          el.style.transform = '';
          el.classList.remove('dragging');
        }
        this.drag.previewCells = [];
        //this.centerAllBlocks(); ИЗБЫТОЧНО ?? 1509
      }

      highlightCross(x0, y0) {
        // обновить подсветку на новую позицию
        if (this._hlPrev) this.clearHighlightCross();
        this._hlPrev = { x: x0, y: y0 };
        for (let x = 0; x < this.width; x++) this.getCellEl(x, y0)?.classList.add('row-hl');
        for (let y = 0; y < this.height; y++) this.getCellEl(x0, y)?.classList.add('col-hl');
      }

      clearHighlightCross() {
        const all = document.querySelectorAll('.cell.row-hl, .cell.col-hl');
        all.forEach(el => el.classList.remove('row-hl', 'col-hl'));
        this._hlPrev = null;
      }


      moveChain(x0, y0, axis, steps) {
        const sign = Math.sign(steps);
        if (sign === 0) return { x: x0, y: y0 };

        const changed = []; // список изменённых координат

        if (axis === 'x') {
          const y = y0;
          if (sign > 0) {
            let chainEnd = x0;
            while (chainEnd + 1 < this.width && this.board[y][chainEnd + 1] !== null) chainEnd++;
            for (let x = chainEnd; x >= x0; x--) {
              this.board[y][x + steps] = this.board[y][x];
              this.board[y][x] = null;
              changed.push([x, y], [x + steps, y]);
            }
          } else {
            let chainStart = x0;
            while (chainStart - 1 >= 0 && this.board[y][chainStart - 1] !== null) chainStart--;
            for (let x = chainStart; x <= x0; x++) {
              this.board[y][x + steps] = this.board[y][x];
              this.board[y][x] = null;
              changed.push([x, y], [x + steps, y]);
            }
          }
          // точечная перерисовка
          changed.forEach(([cx, cy]) => this.updateCell(cx, cy));
          return { x: x0 + steps, y: y0 };
        } else {
          const x = x0;
          if (sign > 0) {
            let chainEnd = y0;
            while (chainEnd + 1 < this.height && this.board[chainEnd + 1][x] !== null) chainEnd++;
            for (let y = chainEnd; y >= y0; y--) {
              this.board[y + steps][x] = this.board[y][x];
              this.board[y][x] = null;
              changed.push([x, y], [x, y + steps]);
            }
          } else {
            let chainStart = y0;
            while (chainStart - 1 >= 0 && this.board[chainStart - 1][x] !== null) chainStart--;
            for (let y = chainStart; y <= y0; y++) {
              this.board[y + steps][x] = this.board[y][x];
              this.board[y][x] = null;
              changed.push([x, y], [x, y + steps]);
            }
          }
          // точечная перерисовка
          changed.forEach(([cx, cy]) => this.updateCell(cx, cy));
          return { x: x0, y: y0 + steps };
        }
      }



      updateCell(x, y) {
        const cell = this.getCellEl(x, y);
        if (!cell) return;

        const color = this.board[y][x];
        if (color !== null) {
          this.#applyColor(cell, color, true);
          this.applyImageBackgroundToCell(cell);
        } else {
          this.#clearCellImmediate(cell);
        }
      }

      redrawRow(y) {
        for (let x = 0; x < this.width; x++) {
          this.updateCell(x, y);
        }
      }

      redrawColumn(x) {
        for (let y = 0; y < this.height; y++) {
          this.updateCell(x, y);
        }
      }


      #clearCellImmediate(cell) {
        cell.removeAttribute('style');
        cell.classList.remove('filled', 'candidate', 'source', 'vanish');
      }

      redrawAll() {
        for (let y = 0; y < this.height; y++) this.redrawRow(y);
      }

      evaluateAfterMove(x, y) {
        const candidates = this.findNearestBlocksSameColor(x, y);
        if (candidates.length === 1) {
          const { x: tx, y: ty } = candidates[0];
          this.removePair(x, y, tx, ty);
          return;
        }
        if (candidates.length > 1) {
          const boardEl = document.getElementById('board');
          this.enterSelectionMode(x, y, candidates);
          boardEl.classList.add('dimmed');
        }
      }
      // === Обработка клика по клетке ===
      onCellClick(e, x, y) {
        const boardEl = document.getElementById('board');
        const cellEl = e.currentTarget;
        if (performance.now() < this._blockClicksUntil) return;
        const color = this.board[y][x];
        if (color === null) return; 
        // Центрируем все блоки при клике (на случай если они были слегка сдвинуты)
        //this.centerAllBlocks(); ИЗБЫТОЧНО ?? 1509
        // Если есть подсказка — мягко сбрасываем (и запускаем кулдаун), но не перехватываем действие
        if (this.superHint) { this.clearSuperHint(false); /*this.startHintCooldown(); расход подсказки при клике*/ }
        // Если ждём выбора среди кандидатов — принимаем клики только по ним
        if (this.state.locked) {
          const isCandidate = cellEl.classList.contains('candidate');
          if (!isCandidate) return; 
          // исполняем удаление пары: source + выбранный
          const s = this.state.source;
          this.removePair(s.x, s.y, x, y);
          this.exitSelectionMode();
          return;
        }
        // Иначе: обычный клик — поиск ближайших совпадений
        const candidates = this.findNearestBlocksSameColor(x, y);
        if (candidates.length === 0) {
          // Подсветить все блоки того же цвета мягким пульсом на 1 секунду
          this.pulseSameColor(x, y);
          // Центрируем все блоки при пульсации (нет кандидатов)
          //setTimeout(() => this.centerAllBlocks(), 100); ИЗБЫТОЧНО ?? 1509
          return;
        }
        if (candidates.length === 1) {
          const { x: tx, y: ty } = candidates[0];
          this.removePair(x, y, tx, ty);
          return;
        }
        // Несколько совпадений — если кликнули по блоку, который был в подсказке (и мы её только что сбросили), удалить супер-пару
        if (!this.superHint && this._hintCooldownUntil > performance.now()) {
          // мы знаем, что подсказка только что была активна; проверим, было ли начало на одном из её блоков
          // к сожалению, к этому моменту мы не знаем предыдущую пару, поэтому этот путь обрабатывается в onPointerDown
        }
        // Обычный режим выбора
        this.enterSelectionMode(x, y, candidates);
        boardEl.classList.add('dimmed');
      }


      pulseSameColor(x0, y0) {
        const colorId = this.board[y0][x0];
        if (colorId === null) return;

        const toPulse = [];
        for (let y = 0; y < this.height; y++) {
          for (let x = 0; x < this.width; x++) {
            if (this.board[y][x] === colorId) {
              const el = this.getCellEl(x, y);
              if (el && el.classList.contains('filled')) {
                toPulse.push(el);
              }
            }
          }
        }
        if (toPulse.length === 0) return;

        // --- Добавляем класс сразу всем элементам ---
        toPulse.forEach(el => el.classList.add('pulse-same'));

        // --- Убираем класс через 1 сек ---
        setTimeout(() => {
          toPulse.forEach(el => el.classList.remove('pulse-same'));
        }, 1500);
      }



      enterSelectionMode(x, y, candidates) {
        this.state.locked = true;
        this.state.source = { x, y, color: this.board[y][x] };
        this.state.candidates = candidates;
        // визуальная подсветка
        const srcEl = this.getCellEl(x, y);
        srcEl.classList.add('source');
        for (const {x: cx, y: cy} of candidates) {
          const el = this.getCellEl(cx, cy);
          el.classList.add('candidate');
        }
        this.updateHintButtonState();
        // Центрируем все блоки при входе в режим выбора
        this.centerAllBlocks();
      }

      exitSelectionMode() {
        const boardEl = document.getElementById('board');
        boardEl.classList.remove('dimmed');
        // снять классы
        if (this.state.source) this.getCellEl(this.state.source.x, this.state.source.y)?.classList.remove('source');
        for (const {x, y} of this.state.candidates) {
          this.getCellEl(x, y)?.classList.remove('candidate');
        }
        this.state.locked = false;
        this.state.source = null;
        this.state.candidates = [];
        this.updateHintButtonState();
        //this.centerAllBlocks(); ИЗБЫТОЧНО ??? 1509
      }
      // === Удаление пары ===
      removePair(x1, y1, x2, y2) {
        this.board[y1][x1] = null;
        this.board[y2][x2] = null;
        const a = this.getCellEl(x1, y1);
        const b = this.getCellEl(x2, y2);
        // Применяем случайную анимацию удаления для каждого блока
        this.animateCellRemoval(a);
        this.animateCellRemoval(b);
        // Фоновая проверка: есть ли доступные ходы, иначе перемешать
        setTimeout(() => this.checkAndReshuffleIfNoMoves(), 400);
      }
      // Функция для анимации удаления блока с случайным эффектом
      animateCellRemoval(cell) {
        if (!cell) return;
        // Массив доступных анимаций
        const animations = ['explode', 'fade-out', 'shrink', 'wave-out'];
        // Выбираем случайную анимацию
        const randomAnimation = animations[Math.floor(Math.random() * animations.length)];
        // Применяем анимацию
        cell.classList.add(randomAnimation);
        // Убираем анимацию и очищаем ячейку после завершения
        const animationDuration = this.getAnimationDuration(randomAnimation);
        setTimeout(() => {
          cell.classList.remove(randomAnimation);
          this.#clearCell(cell);
        }, animationDuration);
      }
      // Получение длительности анимации в миллисекундах
      getAnimationDuration(animationClass) {
        const durations = {
          'explode': 400,
          'fade-out': 300,
          'shrink': 250,
          'wave-out': 350
        };
        return durations[animationClass] || 300;
      }
      // === Сброс/перегенерация ===
      reset() {

        this.exitSelectionMode();
        this.clearSuperHint(true);
        const pinnedPaletteIndex = this.pinnedPaletteIndex;
        this.theme = this.getCurrentThemeColors();
        this.maxColors = Math.min(this.maxColors, this.theme.length);
        this.board = this.generateBoard();
        this.mount();
        // Центрируем все блоки после перезапуска //ЗАКОММЕНТИРОВАНО ДЛЯ ТЕСТИРОВАНИЯ ОПТИМИЗАЦИИ НАГРУЗКИ
        //setTimeout(() => this.centerAllBlocks(), 100);
        //setTimeout(() => this.checkAndReshuffleIfNoMoves(), 50);
        //setTimeout(() => this.updateSettingsDisplay(), 300);
        
        saveGameData();
      }


      // === Фоновая проверка доступных ходов (условия A и B) ===

      checkAndReshuffleIfNoMoves() {
        if (this._animatingReshuffle) return;
        if (this.hasAnyAvailablePair()) return;


      if (game.checkLevelCompleted()) {
        const finalTime = document.getElementById("timer").textContent;
        stopTimerOnly();

        if (challengeMode) {
          // 🎯 Отправляем событие для испытаний
          try {
            const elapsedSeconds = parseTimeToSeconds(finalTime);
            //console.warn("Отправлено challenge_completed");
            gtag('event', 'challenge_completed', {
              time_spent_sec: elapsedSeconds ?? 0,  // если null → 0
              time_spent_str: finalTime,            // строка на всякий случай
              board_height: CONFIG.height,
              color_count: CONFIG.maxColors,
              min_pairs: CONFIG.minPair,
              room: CONFIG.currentRoom 
            });
          } catch (err) {
           // console.warn("⚠️ Ошибка при отправке события challenge_completed");
          }

          showLevelCompleteMessage(finalTime);
        } else {
          // 🎯 Отправляем событие для простых уровней
          try {
            //console.warn("Отправлено level_completed");
            gtag('event', 'level_completed', {
              board_height: CONFIG.height,
              color_count: CONFIG.maxColors,
              min_pairs: CONFIG.minPair,
              room: CONFIG.currentRoom
            });
          } catch (err) {
           // console.warn("⚠️ Ошибка при отправке события level_completed");
          }

          game.reset();
          updateEventHandlers();
        }




          return;
        }





        this.showNoMovesMessage();
        setTimeout(() => {
          this.runWaveReshuffle();
        }, 500);
      }


      hasAnyAvailablePair() {
        // Условие A: есть прямая пара без перемещений
        for (let y = 0; y < this.height; y++) {
          for (let x = 0; x < this.width; x++) {
            if (this.board[y][x] === null) continue;
            if (this.findNearestBlocksSameColor(x, y).length > 0) return true;
          }
        }
        // Условие B: можно сделать пару после допустимого перемещения цепочки
        return this.canMakePairByMove();
      }

      canMakePairByMove() {
        const dirs = [
          { axis: 'x', step: +1 },
          { axis: 'x', step: -1 },
          { axis: 'y', step: +1 },
          { axis: 'y', step: -1 },
        ];
        for (let y = 0; y < this.height; y++) {
          for (let x = 0; x < this.width; x++) {
            if (this.board[y][x] === null) continue;
            for (const d of dirs) {
              const maxSteps = Math.abs(this.computeAllowedShiftOn(this.board, x, y, d.axis, d.step * 999));
              if (maxSteps <= 0) continue;
              for (let s = 1; s <= maxSteps; s++) {
                const { board: b2, nx, ny } = this.moveChainOn(this.board, x, y, d.axis, d.step * s);
                if (this.findNearestOn(b2, nx, ny).length > 0) return true;
              }
            }
          }
        }
        return false;
      }
      // === Чистые хелперы для проверки на копии поля ===
      computeAllowedShiftOn(board, x0, y0, axis, desiredSteps) {
        const width = this.width;
        const height = this.height;
        const sign = Math.sign(desiredSteps);
        if (sign === 0) return 0;
        
        if (x0 < 0 || x0 >= width || y0 < 0 || y0 >= height) return 0;
        
        const limit = Math.abs(desiredSteps);
        if (axis === 'x') {
          const y = y0;
          if (sign > 0) {
            let chainEnd = x0;
            while (chainEnd + 1 < width && board[y][chainEnd + 1] !== null) chainEnd++;
            let empty = 0; 
            let i = chainEnd + 1;
            while (i < width && board[y][i] === null) { 
              empty++; 
              i++; 
            }
            return Math.min(limit, empty) * sign;
          } else {
            let chainStart = x0;
            while (chainStart - 1 >= 0 && board[y][chainStart - 1] !== null) chainStart--;
            let empty = 0; 
            let i = chainStart - 1;
            while (i >= 0 && board[y][i] === null) { 
              empty++; 
              i--; 
            }
            return Math.min(limit, empty) * sign;
          }
        } else {
          const x = x0;
          if (sign > 0) {
            let chainEnd = y0;
            while (chainEnd + 1 < height && board[chainEnd + 1][x] !== null) chainEnd++;
            let empty = 0; 
            let i = chainEnd + 1;
            while (i < height && board[i][x] === null) { 
              empty++; 
              i++; 
            }
            return Math.min(limit, empty) * sign;
          } else {
            let chainStart = y0;
            while (chainStart - 1 >= 0 && board[chainStart - 1][x] !== null) chainStart--;
            let empty = 0; 
            let i = chainStart - 1;
            while (i >= 0 && board[i][x] === null) { 
              empty++; 
              i--; 
            }
            return Math.min(limit, empty) * sign;
          }
        }
      }


       moveChainOn(board, x0, y0, axis, steps) {
        const width = this.width;
        const height = this.height;
        const b = board.map(row => row.slice());
        const sign = Math.sign(steps);
        if (sign === 0) return { board: b, nx: x0, ny: y0, changed: [] };

        const changed = [];

        if (axis === 'x') {
          const y = y0;
          if (sign > 0) {
            let chainEnd = x0;
            while (chainEnd + 1 < width && b[y][chainEnd + 1] !== null) chainEnd++;
            for (let x = chainEnd; x >= x0; x--) {
              const newX = x + steps;
              if (newX < width) {
                b[y][newX] = b[y][x];
                b[y][x] = null;
                changed.push([x, y], [newX, y]);
              }
            }
          } else {
            let chainStart = x0;
            while (chainStart - 1 >= 0 && b[y][chainStart - 1] !== null) chainStart--;
            for (let x = chainStart; x <= x0; x++) {
              const newX = x + steps;
              if (newX >= 0) {
                b[y][newX] = b[y][x];
                b[y][x] = null;
                changed.push([x, y], [newX, y]);
              }
            }
          }
          return { board: b, nx: x0 + steps, ny: y0, changed };
        } else {
          const x = x0;
          if (sign > 0) {
            let chainEnd = y0;
            while (chainEnd + 1 < height && b[chainEnd + 1][x] !== null) chainEnd++;
            for (let y = chainEnd; y >= y0; y--) {
              const newY = y + steps;
              if (newY < height) {
                b[newY][x] = b[y][x];
                b[y][x] = null;
                changed.push([x, y], [x, newY]);
              }
            }
          } else {
            let chainStart = y0;
            while (chainStart - 1 >= 0 && b[chainStart - 1][x] !== null) chainStart--;
            for (let y = chainStart; y <= y0; y++) {
              const newY = y + steps;
              if (newY >= 0) {
                b[newY][x] = b[y][x];
                b[y][x] = null;
                changed.push([x, y], [x, newY]);
              }
            }
          }
          return { board: b, nx: x0, ny: y0 + steps, changed };
        }
      }


      findNearestOn(board, x, y) {
        const width = this.width;
        const height = this.height;
        const color = board[y][x];
        if (color === null) return [];
        
        const dirs = [ [1,0], [-1,0], [0,1], [0,-1] ];
        const found = [];
        
        for (const [dx, dy] of dirs) {
          let cx = x + dx, cy = y + dy;
          while (cx >= 0 && cx < width && cy >= 0 && cy < height) {
            const c = board[cy][cx];
            if (c !== null) {
              if (c === color) {
                found.push({ x: cx, y: cy });
              }
              break;
            }
            cx += dx; 
            cy += dy;
          }
        }
        return found;
      }
      // === Всплывающее сообщение ===
      showNoMovesMessage() {
        const boardEl = document.getElementById('board');
        const msg = document.createElement('div');
        msg.className = 'overlay-message';
        msg.textContent = 'Нет доступных ходов. Перемешиваю.';
        boardEl.appendChild(msg);
        setTimeout(() => { msg.remove(); }, 3000);
      }

 
      // === Волновая анимация в серый и перемешивание ===
      runWaveReshuffle() {
        if (this._animatingReshuffle) return;
        this._animatingReshuffle = true;
        this.state.locked = true;
        this.updateHintButtonState();

        // 1) Планируем новое расположение (сохранить кол-ва цветов)
        const newBoard = this.planReshufflePreserveCounts();

        // 2) Волна "в серый" из левого верхнего угла
        const steps = [];
        let lastDelay = 0;
        for (let y = 0; y < this.height; y++) {
          for (let x = 0; x < this.width; x++) {
            const el = this.getCellEl(x, y);
            if (!el) continue;
            el.classList.remove("candidate", "source"); // сразу чистим
            const delay = (x + y) * 14;
            steps.push({ el, x, y, delay });
            if (delay > lastDelay) lastDelay = delay;
          }
        }

        // 3) Применяем новую раскладку после завершения "серой волны"
        setTimeout(() => {
          this.board = newBoard;
          this.theme = this.getCurrentThemeColors();
          this.maxColors = Math.min(this.maxColors, this.theme.length);

          // Подготовить DOM: оставить серым (activated=0)
          for (let y = 0; y < this.height; y++) {
            for (let x = 0; x < this.width; x++) {
              const el = this.getCellEl(x, y);
              const color = this.board[y][x];
              if (color !== null) {
                el.classList.add("filled");
                el.dataset.colorId = String(color);
                el.dataset.activated = "0";
              } else {
                this.#clearCellImmediate(el);
              }
            }
          }

          // Волна включения (диагонали из левого верхнего)
          const revealDuration = 1000; // можно вынести в CONFIG
          this.runInitialReveal(revealDuration);

          // Разблокировать строго после завершения волны
          setTimeout(() => {
            this._animatingReshuffle = false;
            this.state.locked = false;
            this.updateHintButtonState();
            this.centerAllBlocks();
          }, revealDuration + 50);

        }, lastDelay + 30);
      }


      planReshufflePreserveCounts() {
        // Собрать список цветов
        const colors = [];
        for (let y = 0; y < this.height; y++) {
          for (let x = 0; x < this.width; x++) {
            const c = this.board[y][x];
            if (c !== null) colors.push(c);
          }
        }
        const total = this.width * this.height;
        const empties = total - colors.length;
        const cells = [...Array(total).keys()].map(i => ({ x: i % this.width, y: Math.floor(i / this.width) }));

        let attempt = 0;
        const maxAttempts = 300;
        while (attempt++ < maxAttempts) {
          // тасуем позиции и цвета
          const shuffledCells = cells.slice().sort(() => Math.random() - 0.5);
          const shuffledColors = colors.slice().sort(() => Math.random() - 0.5);
          const grid = Array.from({ length: this.height }, () => Array(this.width).fill(null));
          let ci = 0;
          for (let i = 0; i < shuffledCells.length; i++) {
            const { x, y } = shuffledCells[i];
            if (i < shuffledColors.length) grid[y][x] = shuffledColors[ci++];
          }
          // проверим на наличие доступных ходов
          if (this.hasAnyAvailablePairOn(grid)) return grid;
        }
        // fallback: если не нашли, просто сгенерировать новое поле, сохраняя конфиг
        console.warn('Не удалось быстро подобрать раскладку, генерирую новое поле.');



        return this.generateBoard();
      }

      hasAnyAvailablePairOn(board) {
        // Условие A
        for (let y = 0; y < this.height; y++) {
          for (let x = 0; x < this.width; x++) {
            if (board[y][x] === null) continue;
            if (this.findNearestOn(board, x, y).length > 0) return true;
          }
        }
        // Условие B (на копии)
        const dirs = [
          { axis: 'x', step: +1 },
          { axis: 'x', step: -1 },
          { axis: 'y', step: +1 },
          { axis: 'y', step: -1 },
        ];
        for (let y = 0; y < this.height; y++) {
          for (let x = 0; x < this.width; x++) {
            if (board[y][x] === null) continue;
            for (const d of dirs) {
              const maxSteps = Math.abs(this.computeAllowedShiftOn(board, x, y, d.axis, d.step * 999));
              if (maxSteps <= 0) continue;
              for (let s = 1; s <= maxSteps; s++) {
                const { board: b2, nx, ny } = this.moveChainOn(board, x, y, d.axis, d.step * s);
                if (this.findNearestOn(b2, nx, ny).length > 0) return true;
              }
            }
          }
        }
        return false;
      }
      // === Подсказка: вычисление пары и управление ===
      bindHintButton() {
        const btn = document.getElementById('hint');
        if (!btn) return;
        this._hintBtn = btn;
        btn.addEventListener('click', () => {
          if (this.state.locked) return; 
          if (performance.now() < this._hintCooldownUntil) return;
          if (this.superHint) return;
          const pair = this.computeHintPair();
          if (!pair) {
            this.checkAndReshuffleIfNoMoves();
            return;
          }
          this.showSuperHint(pair);
        });
        this.updateHintButtonState();
      }

      updateHintButtonState() {
        if (!this._hintBtn) return;
        const disabled = this.state.locked || (performance.now() < this._hintCooldownUntil) || this._animatingReshuffle;
        this._hintBtn.disabled = !!disabled;
        if (performance.now() < this._hintCooldownUntil) this._hintBtn.classList.add('cooldown');
        else this._hintBtn.classList.remove('cooldown');
      }

      startHintCooldown() {
        const cooldownMs = 5000; // 3 секунды
        this._hintCooldownUntil = performance.now() + cooldownMs;
        this.updateHintButtonState();
        setTimeout(() => {
          this.updateHintButtonState();
        }, cooldownMs);
      }


      clearSuperHint(skipBtnUpdate) {
        if (this.superHint) {
          const { a, b } = this.superHint;
          const toClear = [this.getCellEl(a.x, a.y), this.getCellEl(b.x, b.y)].filter(Boolean);

          let idx = 0;
          const batchSize = 8;
          const removeBatch = () => {
            let processed = 0;
            while (idx < toClear.length && processed < batchSize) {
              toClear[idx].classList.remove('hinted-super');
              idx++;
              processed++;
            }
            if (idx < toClear.length) {
              requestAnimationFrame(removeBatch);
            }
          };
          requestAnimationFrame(removeBatch);
        }

        this.superHint = null;

        if (this.state.locked) this.exitSelectionMode();
      }

      showSuperHint(pair) {
        this.clearSuperHint(true);
        this.superHint = pair;

        const toAdd = [this.getCellEl(pair.a.x, pair.a.y), this.getCellEl(pair.b.x, pair.b.y)].filter(Boolean);

        let idx = 0;
        const batchSize = 2;
        const addBatch = () => {
          let processed = 0;
          while (idx < toAdd.length && processed < batchSize) {
            toAdd[idx].classList.add('hinted-super');
            idx++;
            processed++;
          }
          if (idx < toAdd.length) {
            requestAnimationFrame(addBatch);
          }
        };
        requestAnimationFrame(addBatch);

         this.startHintCooldown(); //this.updateHintButtonState();
      }

      computeHintPair() {
        // 1) Сначала ищем прямую пару (условие A)
        for (let y = 0; y < this.height; y++) {
          for (let x = 0; x < this.width; x++) {
            const color = this.board[y][x];
            if (color === null) continue;
            const cands = this.findNearestBlocksSameColor(x, y);
            if (cands.length > 0) {
              const c = cands[0];
              return { a: { x, y }, b: { x: c.x, y: c.y } };
            }
          }
        }
        // 2) Если нет — ищем пару после допустимого перемещения (условие B)
        const dirs = [
          { axis: 'x', step: +1 },
          { axis: 'x', step: -1 },
          { axis: 'y', step: +1 },
          { axis: 'y', step: -1 },
        ];
        for (let y = 0; y < this.height; y++) {
          for (let x = 0; x < this.width; x++) {
            if (this.board[y][x] === null) continue;
            for (const d of dirs) {
              const maxSteps = Math.abs(this.computeAllowedShiftOn(this.board, x, y, d.axis, d.step * 999));
              if (maxSteps <= 0) continue;
              const sign = Math.sign(d.step);
              const rng = this.getChainRangeOn(this.board, x, y, d.axis, sign);
              for (let s = 1; s <= maxSteps; s++) {
                const { board: b2, nx, ny } = this.moveChainOn(this.board, x, y, d.axis, d.step * s);
                const near = this.findNearestOn(b2, nx, ny);
                if (near.length > 0) {
                  const p = near[0];
                  // Найти исходные координаты партнёра, если он принадлежал сдвигаемой цепочке
                  let bx = p.x, by = p.y;
                  if (d.axis === 'x' && p.y === y && p.x >= rng.from + s && p.x <= rng.to + s) {
                    bx = p.x - d.step * s;
                  }
                  if (d.axis === 'y' && p.x === x && p.y >= rng.from + s && p.y <= rng.to + s) {
                    by = p.y - d.step * s;
                  }
                  return { a: { x, y }, b: { x: bx, y: by } };
                }
              }
            }
          }
        }
        return null;
      }

      getChainRangeOn(board, x0, y0, axis, sign) {
        const width = this.width;
        const height = this.height;
        if (axis === 'x') {
          const y = y0;
          if (sign > 0) {
            let end = x0;
            while (end + 1 < width && board[y][end + 1] !== null) end++;
            return { from: x0, to: end };
          } else {
            let start = x0;
            while (start - 1 >= 0 && board[y][start - 1] !== null) start--;
            return { from: start, to: x0 };
          }
        } else {
          const x = x0;
          if (sign > 0) {
            let end = y0;
            while (end + 1 < height && board[end + 1][x] !== null) end++;
            return { from: y0, to: end };
          } else {
            let start = y0;
            while (start - 1 >= 0 && board[start - 1][x] !== null) start--;
            return { from: start, to: y0 };
          }
        }
      }

      checkLevelCompleted() {
        // Проверяем, остались ли какие-то блоки
        for (let y = 0; y < this.height; y++) {
          for (let x = 0; x < this.width; x++) {
            if (this.board[y][x] !== null) return false;
          }
        }
        return true;
      }


    }

    let game;
    
    const savedData = loadGameData();
    if (savedData) {
      Object.assign(CONFIG, savedData.config);
      
      THEMES_CUSTOM.length = 0;
      THEMES_CUSTOM.push(...savedData.customPalettes);
      
      game = new Game(CONFIG);
      
      if (savedData.gameState) {
        game.board = savedData.gameState.board;
        game.pinnedPaletteIndex = savedData.gameState.pinnedPaletteIndex;
        game.theme = savedData.gameState.theme;
        game.mount();
        showMessage('Игра восстановлена из сохранения', 'success');
      }
    } else {
      game = new Game(CONFIG);
    }
    
    document.addEventListener('fullscreenchange', handleFullscreenChange);
    document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
    document.addEventListener('msfullscreenchange', handleFullscreenChange);


let countdownTimeout = null; // id текущего таймера обратного отсчёта
let countdownToken = 0; // токен для защиты от "устаревших" запусков

function applyDim() {
  const boardEl = document.getElementById('board');
  boardEl.classList.add("dimmedclone");
  requestAnimationFrame(() => {
    boardEl.classList.add("active");
  });
}

function waitForBoardAnimation(boardEl) {
    return new Promise((resolve) => {
      const cells = boardEl.querySelectorAll(".cell");
      let remaining = cells.length;

      if (remaining === 0) {
        resolve();
        return;
      }

      cells.forEach((cell) => {
        cell.addEventListener("transitionend", function handler(e) {
          if (
            e.propertyName === "background-color" ||
            e.propertyName === "--color"
          ) {
            remaining--;
            cell.removeEventListener("transitionend", handler);
            if (remaining === 0) resolve();
          }
        });
      });
    });
  }
    // Обратный отсчёт
// Обратный отсчёт
function startCountdown() {
  const boardEl = document.getElementById("board");

  const overlay = document.createElement("div");
  overlay.id = "countdown-overlay";
  overlay.className = "overlay-countdown";
  boardEl.appendChild(overlay);

  const sequence = ["3", "2", "1", "Поехали!"];
  let index = 0;

  function showNext() {
    if (index >= sequence.length) {
      overlay.remove();
      boardEl.classList.remove("dimmedclone");

      // ✅ Разблокируем back по завершении отсчёта
      const backBtn = document.getElementById("back"); // ✅ получаем кнопку возврата
      backBtn.classList.remove("cooldown");

      startTimer();
      countdownTimeout = null; // очистили
      return;
    }

    overlay.textContent = sequence[index];
    overlay.classList.remove("animate"); 
    void overlay.offsetWidth;           
    overlay.classList.add("animate");   

    index++;
    countdownTimeout = setTimeout(showNext, 1000);
  }

  showNext();
}

    // ======== Инициализация состояния fullscreen ========
    function initFullscreenSetting() {
      const fullscreenSlider = document.getElementById('fullscreen-slider');
      if (!fullscreenSlider) return;

      // Установим текущий статус
      const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement);
      fullscreenSlider.value = isFullscreen ? 1 : 0;
      document.getElementById('settings-fullscreen').textContent = isFullscreen ? 'Включен' : 'Выключен';
      CONFIG.fullscreen = isFullscreen;

      // Обработчик изменения ползунка
      fullscreenSlider.addEventListener('input', () => {
        if (fullscreenSlider.value === "1") {
          enterFullscreen();
        } else {
          exitFullscreen();
        }
      });

      // Следим за изменением fullscreen извне (кнопки Esc, системные события и т.д.)
      document.addEventListener('fullscreenchange', handleFullscreenChange);
      document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
      document.addEventListener('msfullscreenchange', handleFullscreenChange);
    }

    function enterFullscreen() {
      const elem = document.documentElement; // можно заменить на контейнер игры
      if (elem.requestFullscreen) {
        elem.requestFullscreen();
      } else if (elem.webkitRequestFullscreen) {
        elem.webkitRequestFullscreen();
      } else if (elem.msRequestFullscreen) {
        elem.msRequestFullscreen();
      }
    }

    function exitFullscreen() {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
      } else if (document.msExitFullscreen) {
        document.msExitFullscreen();
      }
    }

    function handleFullscreenChange() { 
      const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement);
      CONFIG.fullscreen = isFullscreen;

      const fullscreenSlider = document.getElementById('fullscreen-slider');
      if (fullscreenSlider) {
        fullscreenSlider.value = isFullscreen ? 1 : 0;
        document.getElementById('settings-fullscreen').textContent = isFullscreen ? 'Включен' : 'Выключен';
      }
    }



    //Исправление отображения , Исправление масштабирования
    function updateBoardScale() {
      const root = document.documentElement;
      const styles = getComputedStyle(root);

      const width = parseInt(styles.getPropertyValue('--width'));      // количество колонок
      const height = parseInt(styles.getPropertyValue('--height'));    // количество строк
      const padding = parseInt(styles.getPropertyValue('--board-padding'));
      const outerMargin = 5; // внешний запас по краям

      const hud = document.querySelector('.hud');
      const hudHeight = hud ? hud.offsetHeight : 0;

      const game = document.querySelector('.game');
      const rowGap = game ? parseInt(getComputedStyle(game).rowGap) || 0 : 0;

      // доступная ширина
      const availW = window.innerWidth - 2 * padding - 2 * outerMargin;

      // доступная высота (минус hud, row-gap и внешние отступы)
      const availH = window.innerHeight - hudHeight - rowGap - 2 * padding - 2 * outerMargin;

      // соотношение: gap = cell / ratio
      const ratio = 12;

      // вычисляем возможные размеры
      const cellFromWidth  = availW / (width + (width - 1) / ratio);
      const cellFromHeight = availH / (height + (height - 1) / ratio);

      // выбираем минимальное (чтобы точно влезло)
      const cell = Math.min(cellFromWidth, cellFromHeight);
      const gap = cell / ratio;

      // применяем
      root.style.setProperty('--cell', cell + 'px');
      root.style.setProperty('--gap', gap + 'px');

      // внешний отступ по бокам
      const board = document.getElementById('board');
      board.style.margin = `${outerMargin}px auto`;
    }

    window.addEventListener('load', updateBoardScale);
    window.addEventListener('resize', updateBoardScale);




    const challengeBtn = document.getElementById("challenge-mode");

    function updateEventHandlers() {
      const resetBtn = document.getElementById("reset");
      const hintBtn = document.getElementById("hint");

      resetBtn.replaceWith(resetBtn.cloneNode(true));
      hintBtn.replaceWith(hintBtn.cloneNode(true));

      const newResetBtn = document.getElementById("reset");
      const newHintBtn = document.getElementById("hint");

      newResetBtn.addEventListener("click", () => {
        game.reset();
      });

      newHintBtn.addEventListener("click", () => {
        if (game.state.locked) return;
        if (performance.now() < game._hintCooldownUntil) return;
        if (game.superHint) return;

        const pair = game.computeHintPair();
        if (!pair) {
          game.checkAndReshuffleIfNoMoves();
          return;
        }
        game.showSuperHint(pair);

        const cooldownMs = 5000; // 5 секунд
        game._hintCooldownUntil = performance.now() + cooldownMs;

        // Кнопка hint — анимация кулдауна
        newHintBtn.classList.add("cooldown");
        newHintBtn.style.setProperty("--cooldown-time", cooldownMs + "ms");
        newHintBtn.style.animation = "none";
        newHintBtn.offsetHeight; // reflow
        newHintBtn.style.animation = null;

        // Challenge тоже в кулдаун
        challengeBtn.classList.add("cooldown");
        challengeBtn.style.setProperty("--cooldown-time", cooldownMs + "ms");
        challengeBtn.style.animation = "none";
        challengeBtn.offsetHeight;
        challengeBtn.style.animation = null;

        // 🚩 Кнопка challenge тоже в кулдаун
        challengeBtn.classList.add("cooldown");
        challengeBtn.disabled = true;

        setTimeout(() => {
          newHintBtn.classList.remove("cooldown");

          // Снимаем кулдаун с challenge
          challengeBtn.classList.remove("cooldown");
          challengeBtn.disabled = false;
        }, cooldownMs);
      });

      window.hintBtn = newHintBtn;
      window.resetBtn = newResetBtn;
    }




    updateEventHandlers();

    window.addEventListener('resize', () => {
      if (game) {
        const maxHeight = game.calculateMaxHeight();
        if (game.height > maxHeight) {
          const pinnedPaletteIndex = game.pinnedPaletteIndex;
          
          CONFIG.height = maxHeight - 1;
          game = new Game(CONFIG);
          
          if (pinnedPaletteIndex >= 0) {
            game.pinnedPaletteIndex = pinnedPaletteIndex;
            game.theme = game.getCurrentThemeColors();
            
            const maxColorsInPalette = game.theme.length;
            if (CONFIG.maxColors > maxColorsInPalette) {
              CONFIG.maxColors = maxColorsInPalette;
              game.maxColors = maxColorsInPalette;
            }
            
            game.board = game.generateBoard();
            game.mount();
            setTimeout(() => game.runInitialReveal(2000), 100);
            
            if (CONFIG.maxColors !== game.maxColors) {
              //showMessage(`Количество цветов изменено до ${game.maxColors}`, 'info');
            }
          }
          
          updateEventHandlers();
        }
      }
    });

    document.getElementById('settings').addEventListener('click', () => {
      openSettings();
    });

// ---------- openSettings (новая версия) ----------
function openSettings() {
  game.updateSettingsDisplay();

  const sizeSlider = document.getElementById('size-slider');
  const maxColorsSlider = document.getElementById('maxColors-slider');
  const minPairSlider = document.getElementById('minPair-slider');
  const fullscreenSlider = document.getElementById('fullscreen-slider');

  // === Размер поля ===
  sizeSlider.oninput = function () {
    const sizes = ['auto', '10×10', '10×15', '10×20'];
    document.getElementById('settings-size').textContent = sizes[this.value];
  };

  // ===== Вспомогательные для "Количество цветов" =====
  function computeColorsBounds() {
    const paletteColors = (game && game.getCurrentThemeColors) ? game.getCurrentThemeColors().length : 0;
    const currentRoomKey = document.getElementById('room-selector')?.value || 'room1';
    const roomImages = (AVAILABLE_ROOM[currentRoomKey]?.themes?.[0]?.length) || 0;

    const nmin = 15;
    const nmax = Math.max(nmin, Math.min(paletteColors || 0, roomImages || 0));
    return { nmin, nmax };
  }
  // --- УНИВЕРСАЛЬНЫЙ помощник: текущее числовое значение цветов
  function getCurrentColorsNumeric() {
    const bounds = computeColorsBounds();
    const nmin = parseInt(maxColorsSlider.dataset.nmin, 10) || bounds.nmin || 1;
    const nmax = parseInt(maxColorsSlider.dataset.nmax, 10) || bounds.nmax || nmin;
    const total = parseInt(maxColorsSlider.dataset.totalPositions, 10) || (nmax - nmin + 1);

    // если чекбокс "max" включён — возвращаем nmax
    if (document.getElementById('maxColors-maxCheck')?.checked) return nmax;

    // если есть сохранённое числовое значение — используем его (и проверяем диапазон)
    const cur = parseInt(maxColorsSlider.dataset.currentNumeric, 10);
    if (Number.isFinite(cur) && cur >= nmin && cur <= nmax) return cur;

    // иначе — по индексу (в новом формате индекс i -> nmin + i)
    const idx = Math.min(Math.max(parseInt(maxColorsSlider.value, 10) || 0, 0), Math.max(0, total - 1));
    return nmin + idx;
  }


  // --- Слайдер Количество цветов (только числа: nmin ... nmax)
  function setupColorsSlider() {
    const colorsValueEl = document.getElementById('settings-maxColors');
    const bounds = computeColorsBounds();
    const nmin = bounds.nmin;
    const nmax = bounds.nmax;

    const numericCount = Math.max(1, nmax - nmin + 1);
    const totalPositions = numericCount;

    maxColorsSlider.min = 0;
    maxColorsSlider.max = totalPositions - 1;
    maxColorsSlider.step = 1;
    maxColorsSlider.dataset.nmin = nmin;
    maxColorsSlider.dataset.nmax = nmax;
    maxColorsSlider.dataset.totalPositions = totalPositions;

    const colorsMaxCheck = document.getElementById('maxColors-maxCheck');

    // --- если чекбокс max активен — сразу прыгаем на максимум
    if (colorsMaxCheck?.checked) {
      maxColorsSlider.value = totalPositions - 1;
      maxColorsSlider.disabled = true;
      maxColorsSlider.dataset.mode = 'max';
      maxColorsSlider.dataset.currentNumeric = nmax;
      colorsValueEl.textContent = String(nmax);
    } else {
      // иначе — восстановление обычного значения
      const prevNumeric = Number.isFinite(parseInt(maxColorsSlider.dataset.currentNumeric, 10))
        ? parseInt(maxColorsSlider.dataset.currentNumeric, 10)
        : (CONFIG && CONFIG.maxColors ? CONFIG.maxColors : nmin);
      const clamped = Math.min(Math.max(prevNumeric, nmin), nmax);
      const initialIndex = clamped - nmin;
      maxColorsSlider.value = initialIndex;
      colorsValueEl.textContent = String(clamped);
      maxColorsSlider.disabled = false;
    }

    // подписи: только крайние
    const labelsContainer = maxColorsSlider.parentElement.querySelector('.slider-labels');
    if (labelsContainer) {
      labelsContainer.innerHTML = '';
      for (let i = 0; i < totalPositions; i++) {
        const span = document.createElement('span');
        if (i === 0) span.textContent = String(nmin);
        else if (i === totalPositions - 1) span.textContent = String(nmax);
        else span.textContent = '';
        labelsContainer.appendChild(span);
      }
    }

    // --- обработчик движения ползунка (если не заблокирован)
    maxColorsSlider.oninput = function () {
      if (colorsMaxCheck?.checked) return; // игнорируем при активном max
      const idx = Math.min(Math.max(parseInt(this.value, 10) || 0, 0), totalPositions - 1);
      const numericValue = nmin + idx;
      colorsValueEl.textContent = String(numericValue);
      maxColorsSlider.dataset.currentNumeric = numericValue;
      if (typeof setupPairSlider === 'function') setupPairSlider();
    };
  }



  // ===== Минимум пар =====
// --- Слайдер Минимум пар (только числа: nminPairs ... nmaxPairs)
function setupPairSlider() {
  const pairValueEl = document.getElementById('settings-minPair');
  const pairsMaxCheck = document.getElementById('minPair-maxCheck');

  // ----- расчёт ячеек -----
  let totalCells = 100;
  const sizeVal = parseInt(sizeSlider.value, 10);
  if (sizeVal === 0) {
    totalCells = game?.getCellCount?.() || (game?.cols * game?.rows) || 100;
  } else {
    const mapping = { 1: 100, 2: 150, 3: 200 };
    totalCells = mapping[sizeVal] || 100;
  }

  // ----- число цветов -----
  const colorsCount = Math.max(1, getCurrentColorsNumeric());

  // ----- диапазон пар -----
  const nminPairs = 1;
  let nmaxPairs = Math.max(1, Math.floor(totalCells / Math.max(colorsCount * 2, 1)));
  if (nmaxPairs < nminPairs) nmaxPairs = nminPairs;

  const numericCount = Math.max(1, nmaxPairs - nminPairs + 1);
  const totalPositions = numericCount;

  minPairSlider.min = 0;
  minPairSlider.max = totalPositions - 1;
  minPairSlider.step = 1;
  minPairSlider.dataset.nmin = nminPairs;
  minPairSlider.dataset.nmax = nmaxPairs;
  minPairSlider.dataset.totalPositions = totalPositions;

  // --- если max чекбокс активен — авто максимум
  if (pairsMaxCheck?.checked) {
    minPairSlider.value = totalPositions - 1;
    minPairSlider.disabled = true;
    minPairSlider.dataset.mode = 'max';
    minPairSlider.dataset.currentNumeric = nmaxPairs;
    pairValueEl.textContent = String(nmaxPairs);
  } else {
    const prevNumeric = Number.isFinite(parseInt(minPairSlider.dataset.currentNumeric, 10))
      ? parseInt(minPairSlider.dataset.currentNumeric, 10)
      : CONFIG.minPair || nminPairs;
    const clamped = Math.min(Math.max(prevNumeric, nminPairs), nmaxPairs);
    const initialIndex = clamped - nminPairs;
    minPairSlider.value = initialIndex;
    minPairSlider.dataset.currentNumeric = clamped;
    pairValueEl.textContent = String(clamped);
    minPairSlider.disabled = false;
  }

  // подписи
  const labelsContainer = minPairSlider.parentElement.querySelector('.slider-labels');
  if (labelsContainer) {
    labelsContainer.innerHTML = '';
    for (let i = 0; i < totalPositions; i++) {
      const span = document.createElement('span');
      if (i === 0) span.textContent = String(nminPairs);
      else if (i === totalPositions - 1) span.textContent = String(nmaxPairs);
      else span.textContent = '';
      labelsContainer.appendChild(span);
    }
  }

  // обработчик
  minPairSlider.oninput = function () {
    if (pairsMaxCheck?.checked) return; // блок при max
    const idx = Math.min(Math.max(parseInt(this.value, 10), 0), totalPositions - 1);
    const numeric = nminPairs + idx;
    pairValueEl.textContent = String(numeric);
    minPairSlider.dataset.currentNumeric = numeric;
  };



}

//////


  // запуск
  setupColorsSlider();
  setupPairSlider();

  // автоматическое обновление при изменении размера или количества цветов
sizeSlider.addEventListener('input', setupPairSlider);
maxColorsSlider.addEventListener('input', setupPairSlider);


  const roomSelector = document.getElementById('room-selector');
  if (roomSelector) {
    roomSelector.addEventListener('change', setupColorsSlider);
  }

  fullscreenSlider.oninput = function () {
    document.getElementById('settings-fullscreen').textContent = this.value == 1 ? 'Включен' : 'Выключен';
  };

  // Смена темы → пересчёт
  const themeSelector = document.getElementById('theme-selector');
  themeSelector.onchange = function () {
    const selectedTheme = this.value;
    const themeName = AVAILABLE_THEMES[selectedTheme]?.name || 'По умолчанию';
    document.getElementById('settings-theme').textContent = themeName;

    const customInput = document.getElementById('custom-theme-input');
    if (customInput) {
      customInput.style.display = selectedTheme === 'custom' ? 'block' : 'none';
    }

    if (game) {
      game.currentTheme = selectedTheme;
      game.pinnedPaletteIndex = -1;
      game.updateThemePreview();
    }

    setupColorsSlider();
  };

  document.querySelector('.settings-modal').classList.add('active');

  // === Привязка чекбоксов max ===
const sizeMaxCheck = document.getElementById('size-maxCheck');
const colorsMaxCheck = document.getElementById('maxColors-maxCheck');
const pairsMaxCheck = document.getElementById('minPair-maxCheck');

// === SIZE ===
sizeMaxCheck.onchange = function() {
  const slider = sizeSlider;
  if (this.checked) {
    slider.value = slider.max; // всегда в max
    slider.disabled = true;
    document.getElementById('settings-size').textContent = 'auto';
  } else {
    slider.disabled = false;
    const sizes = ['auto', '10×10', '10×15', '10×20'];
    document.getElementById('settings-size').textContent = sizes[slider.value];
  }
   // 👉 пересчёт при изменении чекбокса
  updateStats().catch(err => console.warn('updateStats error', err));
};

// === COLORS ===
colorsMaxCheck.onchange = function() {
  const slider = maxColorsSlider;
  if (this.checked) {
    slider.value = slider.max;
    slider.disabled = true;
    slider.dataset.mode = 'max';
    slider.dataset.currentNumeric = slider.dataset.nmax;
    document.getElementById('settings-maxColors').textContent = 'max';
  } else {
    slider.disabled = false;
  }
   // 👉 пересчёт при изменении чекбокса
  updateStats().catch(err => console.warn('updateStats error', err));
};

// === PAIRS ===
pairsMaxCheck.onchange = function() {
  const slider = minPairSlider;
  if (this.checked) {
    slider.value = slider.max;
    slider.disabled = true;
    slider.dataset.mode = 'max';
    slider.dataset.currentNumeric = slider.dataset.nmax;
    document.getElementById('settings-minPair').textContent = 'max';
  } else {
    slider.disabled = false;
  }
   // 👉 пересчёт при изменении чекбокса
  updateStats().catch(err => console.warn('updateStats error', err));
};

}

// ---------- applySettings ----------
function applySettings() {
  const sizeSlider = document.getElementById('size-slider');
  const maxColorsSlider = document.getElementById('maxColors-slider');
  const minPairSlider = document.getElementById('minPair-slider');
  const fullscreenSlider = document.getElementById('fullscreen-slider');

  let width = 10, height = 10;
  if (sizeSlider.value == 0) {
    width = game.width;
    height = game.height;
  } else if (sizeSlider.value == 1) {
    width = 10; height = 10;
  } else if (sizeSlider.value == 2) {
    width = 10; height = 15;
  } else if (sizeSlider.value == 3) {
    width = 10; height = 20;
  }

  const maxHeight = game.calculateMaxHeight();
  if (height > maxHeight) height = maxHeight - 1;

  const maxColorsNumeric = parseInt(maxColorsSlider.dataset.currentNumeric) || CONFIG.maxColors;
  const minPairNumeric = parseInt(minPairSlider.dataset.currentNumeric) || CONFIG.minPair;

  CONFIG.width = width;
  CONFIG.height = height;
  CONFIG.maxColors = maxColorsNumeric;
  CONFIG.minPair = minPairNumeric;
  CONFIG.theme = document.getElementById('theme-selector').value;
  CONFIG.fullscreen = fullscreenSlider.value == 1;
  CONFIG.currentRoom = document.getElementById('room-selector')?.value || 'room1';
  CONFIG.useImages = document.getElementById('useImages-slider')?.value === '1';

  if (game && game.clearImageUrlCache) game.clearImageUrlCache();

  const prevPinned = (game && typeof game.pinnedPaletteIndex !== 'undefined') ? game.pinnedPaletteIndex : -1;
  game = new Game(CONFIG);

  if (prevPinned >= 0) {
    game.pinnedPaletteIndex = prevPinned;
    game.theme = game.getCurrentThemeColors();

    const maxColorsInPalette = game.theme.length;
    if (CONFIG.maxColors > maxColorsInPalette) {
      CONFIG.maxColors = maxColorsInPalette;
      game.maxColors = maxColorsInPalette;
      showMessage(`Количество цветов ограничено ${game.maxColors}`, 'info');
    } else {
      game.maxColors = CONFIG.maxColors;
    }

    game.board = game.generateBoard();
    game.mount();
    game.redrawAll();
    setTimeout(() => game.runInitialReveal(2000), 100);
  }
// Инициализируем при загрузке настроек
initFullscreenSetting();

  updateEventHandlers();
  saveGameData();
  closeSettings();
}



/////////
    function closeSettings() {
      document.querySelector('.settings-modal').classList.remove('active');
    }

    document.querySelector('.settings-modal').addEventListener('click', (e) => {
      if (e.target.classList.contains('settings-modal')) {
        closeSettings();
      }
    });



// === Конфиги модели ===
const MODEL = {
  base_k: 0.0476,     // подогнанная базовая константа (сек/ячейка/коэффициент)
  sizeCoef: 1.0,      // насколько сильно увеличивается время при росте высоты > 10
  difficultyScale: 1.3, // масштаб для перехода суммарных факторов в сложность
  difficultyAdjustDiv: 25, // делитель для дополнительной коррекции времени по сложности
  recentRunsLimit: 50 // сколько элементов держать в recentRuns (можно увеличить)
};

// === IndexedDB: простая обёртка ===
const DB_NAME = 'gameStatsDB';
const DB_VERSION = 1;

function openDB() {
  return new Promise((resolve, reject) => {
    if (!('indexedDB' in window)) return reject(new Error('IndexedDB не поддерживается'));
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = (e) => {
      const db = e.target.result;
      if (!db.objectStoreNames.contains('runs')) {
        db.createObjectStore('runs', { keyPath: 'id' }); // id — хеш параметров
      }
      if (!db.objectStoreNames.contains('recentRuns')) {
        db.createObjectStore('recentRuns', { autoIncrement: true });
      }
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

async function dbGet(storeName, key) {
  const db = await openDB();
  return new Promise((res, rej) => {
    const tx = db.transaction(storeName, 'readonly');
    const store = tx.objectStore(storeName);
    const r = store.get(key);
    r.onsuccess = () => res(r.result);
    r.onerror = () => rej(r.error);
  });
}

async function dbPut(storeName, value, key) {
  const db = await openDB();
  return new Promise((res, rej) => {
    const tx = db.transaction(storeName, 'readwrite');
    const store = tx.objectStore(storeName);
    const r = store.put(value, key);
    r.onsuccess = () => res(r.result);
    r.onerror = () => rej(r.error);
  });
}

async function dbAdd(storeName, value) {
  const db = await openDB();
  return new Promise((res, rej) => {
    const tx = db.transaction(storeName, 'readwrite');
    const store = tx.objectStore(storeName);
    const r = store.add(value);
    r.onsuccess = () => res(r.result);
    r.onerror = () => rej(r.error);
  });
}

async function dbGetAll(storeName) {
  const db = await openDB();
  return new Promise((res, rej) => {
    const tx = db.transaction(storeName, 'readonly');
    const store = tx.objectStore(storeName);
    const r = store.getAll();
    r.onsuccess = () => res(r.result || []);
    r.onerror = () => rej(r.error);
  });
}

async function dbDeleteKey(storeName, key) {
  const db = await openDB();
  return new Promise((res, rej) => {
    const tx = db.transaction(storeName, 'readwrite');
    const store = tx.objectStore(storeName);
    const r = store.delete(key);
    r.onsuccess = () => res();
    r.onerror = () => rej(r.error);
  });
}

// === Помощники: нормализация настроек ===
function parseSizeInput(sizeInput) {
  // Возвращает { width, height }
  // Принимает: 'auto' | '10×15' | number index (0..3) | object {width,height}
  // === Новое: auto → текущее поле или max при активном чекбоксе ===

  const maxCheck = document.getElementById('size-maxCheck');
  const useMax = maxCheck && maxCheck.checked;

  if (typeof sizeInput === 'object' && sizeInput?.width && sizeInput?.height)
    return sizeInput;

  // auto = текущее значение игры
  if (sizeInput === 'auto' || sizeInput === 0) {
    if (useMax) return { width: 10, height: 20 };
    if (game && game.width && game.height)
      return { width: game.width, height: game.height };
    return { width: 10, height: 10 };
  }

  if (typeof sizeInput === 'string' && sizeInput.includes('×')) {
    const [w, h] = sizeInput.split('×').map(Number);
    return { width: w, height: h };
  }

  if (typeof sizeInput === 'number') {
    switch (sizeInput) {
      case 1: return { width: 10, height: 10 };
      case 2: return { width: 10, height: 15 };
      case 3: return { width: 10, height: 20 };
      default:
        if (useMax) return { width: 10, height: 20 };
        return { width: 10, height: 10 };
    }
  }

  return { width: 10, height: 10 };
}


function normalizeColorsInput(maxColors) {
  // может быть 'min' 'max' или число
  if (maxColors === 'min') return 5;
  if (maxColors === 'max') return 29;
  const n = Number(maxColors);
  return Number.isFinite(n) ? Math.max(1, Math.round(n)) : 20;
}

function normalizePairsInput(minPairs) {
  if (minPairs === 'min') return 1;
  if (minPairs === 'max') return 5;
  const n = Number(minPairs);
  return Number.isFinite(n) ? Math.min(5, Math.max(1, Math.round(n))) : 1;
}

// === Оценка сложности (обновлённая) ===
// === Оценка сложности (обновлённая) ===
function estimateDifficultyRaw({ width, height, maxColors, minPairs }) {
  const C = maxColors;
  const P = minPairs;
  const A = width * height;

  const baseColorsRef = 20;
  const basePairsRef = 1;
  const f1 = C / baseColorsRef;                   // влияние количества цветов (чем выше - тем сложнее)
  const f2 = P / Math.max(1, basePairsRef);       // влияние гарантированных пар
  const f3 = Math.sqrt(A) / 10;                   // влияние размера поля (10x10 -> 1)

  const sum = f1 * 1.0 + f2 * 0.6 + f3 * 1.0;     // веса подобраны эмпирически
  const D = sum * MODEL.difficultyScale;
  return Math.min(10, Math.max(1, +(D).toFixed(1)));
}

// Обёртка, принимающая различные форматы
function estimateDifficulty(settings) {
  const size = parseSizeInput(settings.size ?? settings);
  const C = normalizeColorsInput(settings.maxColors ?? settings);
  const P = normalizePairsInput(settings.minPairs ?? settings);
  return estimateDifficultyRaw({ width: size.width, height: size.height, maxColors: C, minPairs: P });
}

// === Подсчёт вариативности ===
// чем выше вариативность — тем больше свободы действий, и тем быстрее игрок проходит
function estimateVariability({ width, height, maxColors, minPairs }) {
  const A = width * height;
  const C = maxColors;
  const P = Math.max(1, minPairs);
  const variability = (C / P) * Math.sqrt(A); // базовая формула
  return variability;
}


// возвращает Promise<number> — сек.
// === Модель длительности + использование данных из IndexedDB ===
async function estimateDuration(settings) {
  const size = parseSizeInput(settings.size ?? settings);
  const C = normalizeColorsInput(settings.maxColors ?? settings);
  const P = normalizePairsInput(settings.minPairs ?? settings);
  const W = size.width;
  const H = size.height;
  const A = W * H;

  const variability = estimateVariability({ width: W, height: H, maxColors: C, minPairs: P });
  const difficulty = estimateDifficultyRaw({ width: W, height: H, maxColors: C, minPairs: P });

  // === 1. Базовая длительность от размера поля ===
  const base = Math.pow(A, 0.8) * 0.6; // немного сглаженный рост

  // === 2. Факторы сложности ===
  // Количество цветов — усиливаем влияние
  const colorFactor = 1 + Math.pow(C / 6, 1.25) * 0.2; 

  // Минимум гарантированных пар — чем больше, тем чуть легче
  const pairsFactor = 1 - 0.15 * Math.log2(1 + P / 10);

  // Вариативность и общая "хаотичность" поля
  const variabilityFactor = 1 + (1 / Math.max(1, variability)) * 0.25;

  // Общая вычислительная сложность (эмпирический множитель)
  const difficultyFactor = 1 + Math.min(1.5, difficulty / 4);

  let modelEstimate = base * colorFactor * pairsFactor * variabilityFactor * difficultyFactor;

  // === 3. Добавляем человеческие когнитивные задержки ===
  const reactionTime = 1.2;        // 300 мс
  const thinkingTimePerBlock = 0.048; // 12 мс
  const blocksProcessedPerMove = Math.round(A * 0.80); // игрок оценивает ~25% поля за ход
  const thinkingTime = blocksProcessedPerMove * thinkingTimePerBlock;

  const timePerPair = reactionTime + thinkingTime;
  const totalActionTime = timePerPair * P;

  // Добавляем когнитивное время
  modelEstimate += totalActionTime;

  // === 4. Коррекция диапазона (в секундах) ===
  modelEstimate = Math.min(Math.max(modelEstimate, 8), 300);
  modelEstimate = Math.round(modelEstimate);

  // === 5. Коррекция по данным IndexedDB (история прохождений) ===
  const paramsKey = JSON.stringify({ w: W, h: H, c: C, p: P });
  try {
    const record = await dbGet('runs', paramsKey);
    if (record?.runs?.length > 0) {
      const arr = record.runs.map(r => r.duration).slice(0, 3);
      const avg = Math.round(arr.reduce((s, v) => s + v, 0) / arr.length);
      const alpha = Math.min(0.75, arr.length / 3 * 0.75);
      return Math.round(modelEstimate * (1 - alpha) + avg * alpha);
    }

    const recent = await dbGetAll('recentRuns');
    if (recent?.length > 0) {
      const target = { A, C, P };
      const scored = recent.map(r => {
        const rW = r.params?.w ?? r.params?.width ?? 10;
        const rH = r.params?.h ?? r.params?.height ?? 10;
        const rA = rW * rH;
        const rC = r.params?.c ?? r.params?.colors ?? r.params?.maxColors ?? 20;
        const rP = r.params?.p ?? r.params?.pairs ?? r.params?.minPairs ?? 1;
        const dA = (target.A - rA) / Math.max(1, target.A);
        const dC = (target.C - rC) / Math.max(1, target.C);
        const dP = (target.P - rP) / Math.max(1, target.P);
        const dist = Math.sqrt(dA * dA + dC * dC + dP * dP);
        return { rec: r, dist };
      });
      scored.sort((a, b) => a.dist - b.dist);
      const top = scored.slice(0, 3).filter(x => typeof x.rec?.duration === 'number');
      if (top.length > 0) {
        const arr = top.map(x => x.rec.duration);
        const avg = Math.round(arr.reduce((s, v) => s + v, 0) / arr.length);
        const alpha = Math.min(0.6, top.length / 3 * 0.6);
        return Math.round(modelEstimate * (1 - alpha) + avg * alpha);
      }
    }
  } catch (err) {
    console.warn('estimateDuration: indexeddb error', err);
    return modelEstimate;
  }

  return modelEstimate;
}

// === Запись результата прохождения (вызывать при завершении уровня) ===
async function saveRunResult(settings, durationSeconds) {
  const size = parseSizeInput(settings.size ?? settings);
  const C = normalizeColorsInput(settings.maxColors ?? settings);
  const P = normalizePairsInput(settings.minPairs ?? settings);
  const key = JSON.stringify({ w: size.width, h: size.height, c: C, p: P });
  const ts = Date.now();
  // Обновляем runs (до 3 последних)
  try {
    const existing = await dbGet('runs', key);
    const newRun = { duration: Math.round(durationSeconds), ts };
    let runs = [];
    if (existing && Array.isArray(existing.runs)) {
      runs = [newRun].concat(existing.runs).slice(0, 3);
    } else runs = [newRun];
    await dbPut('runs', { id: key, runs });

    // Добавляем в recentRuns
    await dbAdd('recentRuns', { params: { w: size.width, h: size.height, c: C, p: P }, duration: Math.round(durationSeconds), ts });

    // Обрезаем recentRuns до лимита
    const all = await dbGetAll('recentRuns');
    if (all.length > MODEL.recentRunsLimit) {
      // удаляем самые старые — делаем это грубо: читаем все и удаляем (можно оптимизировать)
      // здесь удаление по ключам не реализовано — простая стратегия: реинициализируем store (удаление старого DB) не желает. 
      // Простая корректировка: удаляем первые N по cursor (реализовать, если нужно).
      // Для простоты пока ничего не делаем — recentRuns лимит служит предупреждением.
    }
  } catch (err) {
    console.warn('saveRunResult error', err);
  }
}

// === formatTime ===
function formatTime(seconds) {
  seconds = Math.max(0, Math.round(seconds));
  const m = Math.floor(seconds / 60);
  const s = seconds % 60;
  return `${m}:${s.toString().padStart(2, '0')}`; // формат M:SS (0:59)
}


// === Интерпретация сложности ===
function getDifficultyLevel(d) {
  if (d < 3.5) return { name: 'Лёгкая', class: 'easy' };
  if (d < 6.5) return { name: 'Средняя', class: 'normal' };
  if (d < 8.5) return { name: 'Сложная', class: 'hard' };
  return { name: 'Невозможная', class: 'extreme' };
}

// === Обновлённая функция updateStats (async) ===
async function updateStats(settings) {
  // settings может быть объектом со свойствами size/maxColors/minPairs или берём значения из UI
  let normalizedSettings = settings;
  if (!settings || typeof settings !== 'object' || (!('size' in settings) && !('maxColors' in settings))) {
    // читаем из UI
    const sizeSlider = document.getElementById('size-slider');
    const maxColorsSlider = document.getElementById('maxColors-slider');
    const minPairSlider = document.getElementById('minPair-slider');

    const sizeVal = sizeSlider ? Number(sizeSlider.value) : 'auto';
    const maxColorsVal = maxColorsSlider ? (maxColorsSlider.dataset.currentNumeric || maxColorsSlider.value) : CONFIG.maxColors;
    const minPairVal = minPairSlider ? (minPairSlider.dataset.currentNumeric || minPairSlider.value) : CONFIG.minPair;

    normalizedSettings = { size: sizeVal, maxColors: maxColorsVal, minPairs: minPairVal };
  }

  const difficultyValue = estimateDifficulty(normalizedSettings);
  const durationSeconds = await estimateDuration(normalizedSettings);
  const diff = getDifficultyLevel(difficultyValue);

  const diffElem = document.getElementById('difficulty-name');
  const durElem = document.getElementById('duration-value');

  if (diffElem) {
    diffElem.textContent = `${diff.name} (${difficultyValue})`;
    diffElem.className = `stat-value ${diff.class}`;
  }
  if (durElem) {
    durElem.textContent = formatTime(durationSeconds);
  }

  return { difficulty: difficultyValue, duration: durationSeconds };
}

// === Вставьте вместо вашего document.addEventListener('change'...) ===
// Пример: обновлять при изменении слайдеров
document.addEventListener('input', (e) => {
  if (e.target.matches('#size-slider, #maxColors-slider, #minPair-slider')) {
    // fire & forget
    updateStats().catch(err => console.warn('updateStats error', err));
  }
}); 

// === Пример использования: сохранять результат по окончании игры ===
// saveRunResult({ size: '10×10', maxColors: 20, minPairs: 1 }, 125);



    function addCustomColors() {
      const input = document.getElementById('custom-colors-input');
      const colorsText = input.value.trim();
      
      if (!colorsText) {
        showMessage('Введите цвета в формате #xxxxxx, #xxxxxx, ...', 'error');
        return;
      }
      
      const colorRegex = /#[0-9A-Fa-f]{6}/g;
      const colors = colorsText.match(colorRegex);
      
      if (!colors || colors.length === 0) {
        showMessage('Введите цвета в формате #xxxxxx, #xxxxxx, ...', 'error');
        return;
      }
      
      THEMES_CUSTOM.push(colors);
      
      if (game) {
        game.updateThemePreview();
      }
      
      input.value = '';
      
      const message = `Добавлено ${colors.length} цветов в палитру ${THEMES_CUSTOM.length}`;
      showMessage(message);
      
      saveGameData();
    }

    function clearCustomTheme() {
      const input = document.getElementById('custom-colors-input');
      if (input) {
        input.value = '';
      }
      
      showMessage('Поле ввода очищено');
    }

    function showMessage(text, type = 'success') {
      const message = document.createElement('div');
      let bgColor, textColor;
      
      switch (type) {
        case 'error':
          bgColor = '#ff4444';
          textColor = '#ffffff';
          break;
        case 'info':
          bgColor = '#4a90e2';
          textColor = '#ffffff';
          break;
        default: 
          bgColor = '#64e0d0';
          textColor = '#0f1522';
          break;
      }
      
      message.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: ${bgColor};
        color: ${textColor};
        padding: 12px 16px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 500;
        z-index: 10000;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        animation: slideIn 0.3s ease-out;
        max-width: 300px;
        word-wrap: break-word;
      `;
      message.textContent = text;
      
      const style = document.createElement('style');
      style.textContent = `
        @keyframes slideIn {
          from { transform: translateX(100%); opacity: 0; }
          to { transform: translateX(0); opacity: 1; }
        }
      `;
      document.head.appendChild(style);
      
      document.body.appendChild(message);
      
      setTimeout(() => {
        message.style.animation = 'slideOut 0.3s ease-in';
        message.style.transform = 'translateX(100%)';
        message.style.opacity = '0';
        setTimeout(() => {
          document.body.removeChild(message);
          document.head.removeChild(style);
        }, 300);
      }, 3000);
    }
document.addEventListener("DOMContentLoaded", () => {
    // --- элементы ---
  const boardEl = document.getElementById("board");
  const challengeBtn = document.getElementById("challenge-mode");
  const backBtn = document.getElementById("back");
  const hintBtn = document.getElementById("hint");

  const settingsBtn = document.getElementById("settings");
  const resetBtn = document.getElementById("reset");

  const timerEl = document.getElementById("timer");
  const startBtn = document.getElementById("start-challenge");

  const gameContainer = document.querySelector('.game'); // родитель, редко заменяется

    // Эти элементы могут быть клонированы/заменены функцией updateEventHandlers,
  // поэтому в местах, где критично, мы заново читаем их через getElementById.
  const settingsId = "settings";
  const resetId = "reset";
  const hintId = "hint";


// --- таймер ---
  let timerInterval = null;
  let startTime = 0;



function removeDim() {
  const boardEl = document.getElementById('board');
  boardEl.classList.remove("active");
  boardEl.classList.remove("dimmedclone");
}


    function activateChallengeMode() {
      settingsBtn.classList.add('hidden');
      resetBtn.classList.add('hidden');
      hintBtn.classList.add('hidden');
      document.getElementById("hint").classList.add('hidden');
      document.getElementById("reset").classList.add('hidden');
      challengeBtn.classList.add('hidden');
      backBtn.classList.remove('hidden');
      timerEl.classList.remove('hidden');

      challengeMode = true;
      game.reset();
      applyDim();
      updateEventHandlers();

      const myToken = ++countdownToken; // новый токен для этой попытки

      waitForBoardAnimation(document.getElementById("board")).then(() => {
        // запускаем только если токен не устарел и мы всё ещё в режиме испытания
        if (challengeMode && myToken === countdownToken) {
          startCountdown();
        }
      });
    }



 
    // Кнопка включения режима
    challengeBtn.addEventListener("click", () => {
      if (challengeBtn.classList.contains("cooldown")) return; // защита

      activateChallengeMode();

      const cooldownMs = 5000;

      // Challenge в кулдаун
      challengeBtn.classList.add("cooldown");
      challengeBtn.style.setProperty("--cooldown-time", cooldownMs + "ms");
      challengeBtn.style.animation = "none";
      challengeBtn.offsetHeight; // reflow
      challengeBtn.style.animation = null;

      // Back в кулдаун (заблокирован минимум на время отсчёта!)
      backBtn.classList.add("cooldown");
      backBtn.style.setProperty("--cooldown-time", cooldownMs + "ms");
      backBtn.style.animation = "none";
      backBtn.offsetHeight;
      backBtn.style.animation = null;

      // Снимаем кулдаун challenge через 5с
      setTimeout(() => {
        challengeBtn.classList.remove("cooldown");
        // backBtn НЕ снимаем тут — его снимает startCountdown()
      }, cooldownMs);
    });


    backBtn.addEventListener("click", () => {
      challengeMode = false;
      countdownToken++; // инвалидируем все запланированные отсчёты

      if (countdownTimeout) {
        clearTimeout(countdownTimeout);
        countdownTimeout = null;
      }

      // ✅ Проверяем, есть ли окно "Испытание пройдено"
      const levelCompleteOverlay = document.getElementById("level-complete");
      if (levelCompleteOverlay) {
        levelCompleteOverlay.remove();

        // Генерируем новую доску
        game.reset();
        updateEventHandlers();
      }

      // ✅ Закрываем оверлей обратного отсчёта, если был
      const countdownOverlay = document.getElementById("countdown-overlay");
      if (countdownOverlay) countdownOverlay.remove();

      settingsBtn.classList.remove("hidden");
      document.getElementById("reset").classList.remove("hidden");
      document.getElementById("hint").classList.remove("hidden");

      backBtn.classList.add("hidden");
      timerEl.classList.add("hidden");
      challengeBtn.classList.remove("hidden");

      const boardEl = document.getElementById("board");
      boardEl.classList.remove("dimmedclone");

      stopAndResetTimer();
    });


    });
let timerInterval = null;
let startTime = 0;


function startTimer() {
  if (timerInterval) return; // чтобы не запускать повторно

  startTime = performance.now();
  timerInterval = setInterval(updateTimer, 1000); // обновление каждую 1ms
}

function stopAndResetTimer() {
  clearInterval(timerInterval);
  timerInterval = null;
  document.getElementById("timer").textContent = "00:00";
}

function updateTimer() {
  const timerEl = document.getElementById("timer");
  const now = performance.now();
  const elapsed = now - startTime;

  const minutes = Math.floor(elapsed / 60000);
  const seconds = Math.floor((elapsed % 60000) / 1000);
  //const milliseconds = Math.floor(elapsed % 1000);

  timerEl.textContent =
    String(minutes).padStart(2, "0") +
    ":" +
    String(seconds).padStart(2, "0")// +
    //":" +
    //String(milliseconds).padStart(3, "0");
}




/* база данных для рекордов */
function openDB() {
  return new Promise((resolve, reject) => {
    if (!('indexedDB' in window)) return reject(new Error('IndexedDB не поддерживается'));
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = (e) => {
      const db = e.target.result;
      if (!db.objectStoreNames.contains('runs')) {
        db.createObjectStore('runs', { keyPath: 'id' });
      }
      if (!db.objectStoreNames.contains('recentRuns')) {
        db.createObjectStore('recentRuns', { autoIncrement: true });
      }
      if (!db.objectStoreNames.contains('records')) {
        db.createObjectStore('records', { keyPath: 'id' }); // хранит лучший результат
      }
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

/* закончено */

async function getRecord(settings) {
  const size = parseSizeInput(settings.size ?? settings);
  const C = normalizeColorsInput(settings.maxColors ?? settings);
  const P = normalizePairsInput(settings.minPairs ?? settings);
  const key = JSON.stringify({ w: size.width, h: size.height, c: C, p: P });
  try {
    const rec = await dbGet('records', key);
    return rec ? rec.bestTime : null;
  } catch (err) {
    console.warn('getRecord error', err);
    return null;
  }
}

async function saveRecord(settings, newTime) {
  const size = parseSizeInput(settings.size ?? settings);
  const C = normalizeColorsInput(settings.maxColors ?? settings);
  const P = normalizePairsInput(settings.minPairs ?? settings);
  const key = JSON.stringify({ w: size.width, h: size.height, c: C, p: P });
  try {
    const existing = await dbGet('records', key);
    if (!existing || newTime < existing.bestTime) {
      await dbPut('records', { id: key, bestTime: newTime, ts: Date.now() });
      return true; // новый рекорд!
    }
    return false; // не побит
  } catch (err) {
    console.warn('saveRecord error', err);
    return false;
  }
}




async function showLevelCompleteMessage(finalTime) {
  if (!challengeMode) return;

  const boardEl = document.getElementById("board");
  if (document.getElementById("level-complete")) return;

  const overlay = document.createElement("div");
  overlay.id = "level-complete";
  overlay.className = "overlay-level";

  const title = document.createElement("div");
  title.className = "overlay-level-title";
  title.textContent = "Испытание пройдено";

  const time = document.createElement("div");
  time.className = "overlay-level-time";
  time.textContent = `Время: ${finalTime}`;

  const info = document.createElement("div");
  info.className = "overlay-level-info";
  info.innerHTML = `
    <div>Размер поля: ${CONFIG.width} x ${CONFIG.height}</div>
    <div>Количество цветов: ${CONFIG.maxColors}</div>
    <div>Минимум пар: ${CONFIG.minPair}</div>
  `;

  const [m, s] = finalTime.split(":").map(Number);
  const duration = m * 60 + s;
  const prevRecord = await getRecord(CONFIG);
  const isRecord = await saveRecord(CONFIG, duration);

  if (prevRecord || isRecord) {
    const recordEl = document.createElement("div");
    recordEl.className = "overlay-level-record";

    if (isRecord) {
      recordEl.innerHTML = `🏆 <b>Новый рекорд!</b> ${finalTime}`;
      startConfettiAnimation(); // Запускаем только если новый рекорд
    } else {
      const bestFormatted = formatTime(prevRecord);
      recordEl.textContent = `Рекорд времени: ${bestFormatted}`;
    }

    overlay.appendChild(recordEl);
  }

  const okBtn = document.createElement("button");
  okBtn.className = "overlay-level-btn";
  okBtn.textContent = "ОК";

  okBtn.addEventListener("click", async () => {
    await saveRunResult(CONFIG, duration);

    overlay.remove();
    stopAndResetTimer();

    game.reset();
    updateEventHandlers();
    applyDim();

    const backBtn = document.getElementById("back");
    if (backBtn) {
      backBtn.classList.add("cooldown");
      backBtn.style.animation = "none";
      backBtn.offsetHeight;
      backBtn.style.animation = null;
    }

    waitForBoardAnimation(boardEl).then(() => {
      startCountdown();
    });
  });

  overlay.appendChild(title);
  overlay.appendChild(time);
  overlay.appendChild(info);
  overlay.appendChild(okBtn);
  boardEl.appendChild(overlay);
}
// запуск конфетти
function startConfettiAnimation() {
  const canvas = document.createElement("canvas");
  canvas.style.position = "fixed";
  canvas.style.top = 0;
  canvas.style.left = 0;
  canvas.style.width = "100%";
  canvas.style.height = "100%";
  canvas.style.pointerEvents = "none";
  canvas.style.zIndex = 9999;
  document.body.appendChild(canvas);

  const ctx = canvas.getContext("2d");

  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  resizeCanvas();
  window.addEventListener("resize", resizeCanvas);

  const confettiCount = 80;
  const pastelColors = [
    "#FFC1CC", // розовый
    "#B3E5FC", // голубой
    "#C8E6C9", // зелёный
    "#FFF9C4"  // жёлтый
  ];

  const confetti = [];

  for (let i = 0; i < confettiCount; i++) {
    confetti.push({
      x: Math.random() > 0.5 ? 0 : canvas.width,
      y: canvas.height,
      size: Math.random() * 8 + 8, // чуть крупнее
      color: pastelColors[Math.floor(Math.random() * pastelColors.length)],
      velocityX: (Math.random() * 4 + 2) * (Math.random() > 0.5 ? 1 : -1),
      velocityY: -(Math.random() * 8 + 6),
      rotation: Math.random() * 360,
      rotationSpeed: (Math.random() - 0.5) * 10,
      life: Math.random() * 80 + 60
    });
  }

  function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    confetti.forEach((c) => {
      c.x += c.velocityX;
      c.y += c.velocityY;
      c.velocityY += 0.2;
      c.rotation += c.rotationSpeed;

      c.life--;

      ctx.save();
      ctx.translate(c.x, c.y);
      ctx.rotate((c.rotation * Math.PI) / 180);

      ctx.fillStyle = c.color;
      ctx.fillRect(-c.size / 2, -c.size / 2, c.size, c.size / 2);

      ctx.restore();
    });

    if (confetti.some(c => c.life > 0)) {
      requestAnimationFrame(animate);
    } else {
      document.body.removeChild(canvas);
    }
  }

  animate();
}





function stopTimerOnly() {
  clearInterval(timerInterval);
  timerInterval = null;
}



  </script>
  

  <script> /*для загрузки на github.io */
if ("serviceWorker" in navigator) {
  navigator.serviceWorker.register("/onet/service-worker.js")
    .then(() => console.log("Service Worker зарегистрирован"))
    .catch(err => console.error("Ошибка регистрации SW:", err));
}



</script>

  <script> /*локальная проверка 
if ("serviceWorker" in navigator) {
  navigator.serviceWorker.register("/service-worker.js")
    .then(() => console.log("Service Worker зарегистрирован локально"))
    .catch(err => console.error("Ошибка лоальной регистрации SW:", err));
}

*/

</script>


</body>

</html>





