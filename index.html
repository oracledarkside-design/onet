<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <link rel="manifest" href="manifest.json">
  <link rel="icon" href="favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>–ì–æ–ª–æ–≤–æ–ª–æ–º–∫–∞</title> 

  <style>
  /* –ë–∞–∑–æ–≤—ã–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –∑–∞–≥—Ä—É–∑—á–∏–∫–∞ */
  #game-loader {
    position: fixed;
    inset: 0; /* top:0; right:0; bottom:0; left:0; */
    /*display: none; /* –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é —Å–∫—Ä—ã—Ç ‚Äî –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —á–µ—Ä–µ–∑ showLoader() */
    align-items: center;
    justify-content: center;
    background: rgba(10, 12, 14);
    z-index: 9999;
    -webkit-font-smoothing: antialiased;
    /*font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;*/
  }

  /* –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è —Ü–µ–Ω—Ç—Ä–æ–≤–∫–∏ –∏ –ø–æ–¥–ø–∏—Å–∏ */
  .loader-inner {
    display: flex;
    flex-direction: column;
    gap: 16px;
    align-items: center;
    justify-content: center;
  }

  /* –ë–µ–ª—ã–π "–∫—É–±–∏–∫" ‚Äî –∫–≤–∞–¥—Ä–∞—Ç —Å –ª—ë–≥–∫–æ–π 3D-–ø–æ–¥—Å–∫–∞–∑–∫–æ–π –∏ –º—è–≥–∫–æ–π –∞–Ω–∏–º–∞—Ü–∏–µ–π */
  .cube {
    width: 44px;
    height: 44px;
    background: linear-gradient(180deg, #ffffff 0%, #f0f0f0 100%);
    border-radius: 6px;
    box-shadow:
      0 10px 20px rgba(0,0,0,0.35),
      0 2px 6px rgba(0,0,0,0.18);
    transform: rotateX(18deg) rotateY(-18deg);
    /* –∞–Ω–∏–º–∞—Ü–∏—è: –ø–ª–∞–≤–Ω–æ–µ –ø–æ—è–≤–ª–µ–Ω–∏–µ/–∏—Å—á–µ–∑–∞–Ω–∏–µ + –ª—ë–≥–∫–æ–µ –∫–∞—á–∞–Ω–∏–µ/–º–∞—Å—à—Ç–∞–± */
    animation: cube-pulse 1.2s ease-in-out infinite;
    will-change: opacity, transform;
  }

  /* –ú–µ–ª–∫–∏–π –¥–µ–∫–æ—Ä–∞—Ç–∏–≤–Ω—ã–π –æ—Ç–±–ª–µ—Å–∫ –Ω–∞ –∫—É–±–∏–∫–µ */
  .cube::before {
    content: "";
    position: absolute;
    pointer-events: none;
    width: 44px;
    height: 44px;
    border-radius: 6px;
    background: linear-gradient(135deg, rgba(255,255,255,0.85) 0%, rgba(255,255,255,0.05) 50%);
    mix-blend-mode: screen;
    transform: translateZ(1px);
    opacity: 0.85;
  }

  /* –ü–æ–¥–ø–∏—Å—å (–Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –æ—Ç–æ–±—Ä–∞–∂–∞—Ç—å, –º–æ–∂–Ω–æ —Å–∫—Ä—ã—Ç—å –≤ –ø—Ä–æ–¥–∞–∫—à–Ω–µ) */
  .loader-label {
    color: #e6e7e9;
    font-size: 13px;
    letter-spacing: 0.2px;
    opacity: 1;
  }

  /* –ö–ª—é—á–µ–≤—ã–µ –∫–∞–¥—Ä—ã: –º—è–≥–∫–∏–π –ø—É–ª—å—Å –∏ –Ω–µ–±–æ–ª—å—à–∞—è —Ä–æ—Ç–∞—Ü–∏—è */
  @keyframes cube-pulse {
    0% {
      opacity: 0.18;
      transform: rotateX(16deg) rotateY(-16deg) scale(0.98);
    }
    25% {
      opacity: 0.9;
      transform: rotateX(18deg) rotateY(-18deg) scale(1.02);
    }
    50% {
      opacity: 1;
      transform: rotateX(20deg) rotateY(-20deg) scale(1.00);
    }
    75% {
      opacity: 0.9;
      transform: rotateX(18deg) rotateY(-18deg) scale(1.01);
    }
    100% {
      opacity: 0.18;
      transform: rotateX(16deg) rotateY(-16deg) scale(0.98);
    }
  }

  /* –ê–¥–∞–ø—Ç–∏–≤: —á—É—Ç—å –º–µ–Ω—å—à–µ –Ω–∞ —É–∑–∫–∏—Ö —ç–∫—Ä–∞–Ω–∞—Ö */
  @media (max-width: 420px) {
    .cube { width: 34px; height: 34px; border-radius: 5px; }
    .loader-label { font-size: 12px; }
  }
</style>
  <style> /*–≤—Ä–µ–º–µ–µ–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ –≤ –º–µ—Ç–∞ max-width=device-width, initial-scale=0.95, maximum-scale=0.99,*/
    :root {
      --width: 10;                /* —Ä–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º–æ: —à–∏—Ä–∏–Ω–∞ –ø–æ–ª—è */
      --height: 10;              /* —Ä–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º–æ: –≤—ã—Å–æ—Ç–∞ –ø–æ–ª—è */
      /*--cell: 56px;             /* —Ä–∞–∑–º–µ—Ä –∫–ª–µ—Ç–∫–∏ */
      /*--gap: 6px;                /* –æ—Ç—Å—Ç—É–ø –º–µ–∂–¥—É –∫–ª–µ—Ç–∫–∞–º–∏ */
      --hl: 120,180,255;        /* –±–∞–∑–æ–≤—ã–π —Ü–≤–µ—Ç –ø–æ–¥—Å–≤–µ—Ç–∫–∏ (RGB) */
        --board-padding: 10px; 
          --color-accent-1: #64e0d0;
          --color-accent-1-SCRLBR: #64e0d0 #1a2130;
          --color-accent-2: #4a4a4a;
          --color-accent-2-SCRLBR: #4a4a4a #1a2130;
    }

    body {
      margin: 0; padding: 0px; background: #0c0f14; color: #e9ecf1;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
     
    }

    html { height: 100%; overscroll-behavior: none; }
    body { overscroll-behavior: none; }
    * { -webkit-tap-highlight-color: transparent; }


    /*.pulse-same {will-change: background-color;}*/

    .game {
      display: grid; grid-template-columns: 1fr; row-gap: 5px; max-width: calc(
    var(--width) * var(--cell) +
    (var(--width) - 1) * var(--gap) +
    2 * var(--board-padding)
  );
     /* min-width: 100%; /*–£–ª—É—á—à–µ–Ω–∏–µ CLS*/ 
      margin: 0 auto; 
    }

    .hud { display:flex; align-items:center; justify-content:space-between; gap:12px; }
    .hud .badge { padding: 6px 10px; background:#1a2130; border:1px solid #283248; border-radius: 10px; font-size: 12px; opacity:.9; }

    #board {
      display: grid;
      grid-template-columns: repeat(var(--width), var(--cell));
      grid-auto-rows: var(--cell);
      gap: var(--gap);
      position: relative;
      padding: var(--board-padding); box-sizing: border-box;  border-radius: 16px; background: #0f1522; box-shadow: inset 0 0 0 1px #1f2940, 0 10px 30px rgba(0,0,0,.4);
      transition: filter .2s ease, opacity .2s ease; 
      width: fit-content; 
      
    }

    /* –û—Ç–∫–ª—é—á–∞–µ–º –ø—Ä–æ–∫—Ä—É—Ç–∫—É/—Ä–∞—Å—Ç—è–∂–µ–Ω–∏–µ –ø—Ä–∏ –∂–µ—Å—Ç–∞—Ö, –≤–∫–ª—é—á–∞–µ–º —Ç–æ—á–Ω—ã–µ pointer —Å–æ–±—ã—Ç–∏—è –Ω–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö */
    #board { touch-action: none; overscroll-behavior: contain; }

    #board.dimmed {
      pointer-events: none;     /* –±–ª–æ–∫–∏—Ä—É–µ—Ç –∫–ª–∏–∫–∏ */

    }



    #board.dimmed::after {
      content: '';
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,.4);
      pointer-events: none;
      border-radius: inherit;
      z-index: 5;

      transition: opacity 0.5s ease; /* –ø–ª–∞–≤–Ω–æ—Å—Ç—å */
    }

    #board.dimmedclone {
      pointer-events: none;     /* –±–ª–æ–∫–∏—Ä—É–µ—Ç –∫–ª–∏–∫–∏ */
    }


#board.dimmedclone::after {
  content: '';
  position: absolute;
  inset: 0;
  background: rgba(0,0,0,.4);
  pointer-events: none;
  border-radius: inherit;
  z-index: 5;

  opacity: 0;
  transition: opacity 0.5s ease; /* –ø–ª–∞–≤–Ω–æ—Å—Ç—å */
}

/* –ö–æ–≥–¥–∞ –∞–∫—Ç–∏–≤–µ–Ω dimmedclone ‚Äî –∑–∞—Ç–µ–º–Ω–µ–Ω–∏–µ –≤–∏–¥–Ω–æ */
#board.dimmedclone.active::after {
  opacity: 1;
}

    .cell {
      position: relative;
      border-radius: 9px;
      overflow: hidden;
      background: #121826; /* –¥–ª—è –ø—É—Å—Ç—ã—Ö */
      cursor: default;
      user-select: none;
      outline: none;
      transform: translateZ(0);
    }

    .cell { -webkit-user-select: none; -ms-user-select: none; }

    .cell.filled { cursor: pointer; }

    /* –ë–∞–∑–æ–≤—ã–π –∑–∞–ª–∏–≤–æ—á–Ω—ã–π —Ü–≤–µ—Ç –∫–ª–µ—Ç–∫–∏ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é —Å–µ—Ä—ã–π), –ø–ª–∞–≤–Ω–æ–µ –≤–∫–ª—é—á–µ–Ω–∏–µ —Ü–≤–µ—Ç–∞ */
    .cell { transform .06s linear; }
    /* —Ñ–æ–Ω –±–µ–∑ –ø–µ—Ä–µ—Ö–æ–¥–∞ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é ‚Äî —á—Ç–æ–±—ã "—Å–µ—Ä—ã–µ" –Ω–µ –∞–Ω–∏–º–∏—Ä–æ–≤–∞–ª–∏—Å—å */

.cell.filled {
  background-color: var(--color, #2b2f3a);
  /*transition: none;*/ /* –£–±–∏—Ä–∞–µ–º —Ä–µ–∑–∫—É—é –æ—Å—Ç–∞–Ω–æ–≤–∫—É –∞–Ω–∏–º–∞—Ü–∏–∏ */
  background-position: center center;
  /*background-size: 70%;*/
  background-repeat: no-repeat;
  background-origin: content-box;
  /* –Ω–∞ —Å–ª—É—á–∞–π, –µ—Å–ª–∏ —Ä–∞–Ω—å—à–µ background –∑–∞–¥–∞–≤–∞–ª—Å—è —á–µ—Ä–µ–∑ background shorthand */
  /*background-image: none;*/
  background-size: contain;   /* –º–∞—Å—à—Ç–∞–± –ø–æ –±–æ–ª—å—à–µ–π —Å—Ç–æ—Ä–æ–Ω–µ */
  padding: 15%;               /* ¬´—É–º–µ–Ω—å—à–∞–µ—Ç¬ª —Ä–∞–±–æ—á–µ–µ –ø–æ–ª–µ, –∫–∞—Ä—Ç–∏–Ω–∫–∞ —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –º–µ–Ω—å—à–µ –±–ª–æ–∫–∞ */
}

/* –ü–ª–∞–≤–Ω—ã–π –ø–µ—Ä–µ—Ö–æ–¥ –≤–∫–ª—é—á–∞–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –¥–ª—è –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –∫–ª–µ—Ç–æ–∫ */
.cell.filled[data-activated="1"] {
  transition: background-color .35s ease;
}

   

/* –ø—Å–µ–≤–¥–æ-—ç–ª–µ–º–µ–Ω—Ç –¥–ª—è –∫–∞—Ä—Ç–∏–Ω–∫–∏ */
.cell.filled::before {
  content: "";
  position: absolute;
  inset: 0; /* –∑–∞–ø–æ–ª–Ω—è–µ—Ç –≤—Å—é —è—á–µ–π–∫—É */
  background-position: center center;
  background-repeat: no-repeat;
  background-size: contain; /* —á—É—Ç—å –º–µ–Ω—å—à–µ —á–µ–º –±–ª–æ–∫ */
  margin: 15%;
  opacity: 0;
  transition: opacity .35s ease;
}

/* –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —è—á–µ–π–∫–∞ ‚Äî –∫–∞—Ä—Ç–∏–Ω–∫–∞ –ø–ª–∞–≤–Ω–æ –ø—Ä–æ—è–≤–ª—è–µ—Ç—Å—è */
.cell.filled[data-activated="1"]::before {
  opacity: 1;
}

.cell.filled::before {
  background-image: var(--img-url);
}


    /* –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –∏—Å—Ç–æ—á–Ω–∏–∫–∞ –∏ –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤ */
    .cell.source { box-shadow: 0 0 0 1.25px rgba(255,255,255,.8), 0 8px 20px rgba(255,255,255,.15), inset 0 0 10px rgba(255,255,255,.15); z-index: 990;}
    .cell.candidate { box-shadow: 0 0 0 1.25px rgba(130,200,255,.95), 0 10px 26px rgba(60,170,255,.25), inset 0 0 16px rgba(120,200,255,.25); z-index: 999;
      pointer-events: auto;}
    .cell.row-hl { box-shadow: 0 0 0 1.25px rgba(var(--hl),.6), 0 6px 18px rgba(var(--hl),.18), inset 0 0 0 rgba(0,0,0,0.0); }
    .cell.col-hl { box-shadow: 0 0 0 1.25px rgba(var(--hl),.6), 0 6px 18px rgba(var(--hl),.18), inset 0 0 0 rgba(0,0,0,0.0); }
    /* –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –æ–¥–∏–Ω–∞–∫–æ–≤—ã—Ö –±–ª–æ–∫–æ–≤ –ø—Ä–∏ –∫–ª–∏–∫–µ */
    .cell.filled.pulse-same { 
      background-color: rgba(var(--hl), .35) !important; 
      box-shadow: 0 0 0 1.25px rgba(64,224,208,1)/*, 
                  0 10px 26px rgba(64,224,208,.25)*/, 
                  inset 0 0 16px rgba(64,224,208,.25)/**/;
                  /* –ø–ª–∞–≤–Ω—ã–π –æ—Ç–∫–∞—Ç –∫ –∏—Å—Ö–æ–¥–Ω–æ–º—É —Å–æ—Å—Ç–æ—è–Ω–∏—é */
  transition-delay: 0s; /* —Å—Ç–∞—Ä—Ç —Å—Ä–∞–∑—É */
    }
    .cell.dragging { z-index: 999; }

    /* –ê–Ω–∏–º–∞—Ü–∏—è –∏—Å—á–µ–∑–Ω–æ–≤–µ–Ω–∏—è */
    .cell.vanish { animation: vanish .25s ease-in forwards; }
    @keyframes vanish {
      to { opacity: 0; transform: scale(.85); filter: blur(2px); }
    }

    /* –ê–Ω–∏–º–∞—Ü–∏—è —É–¥–∞–ª–µ–Ω–∏—è —Å —ç—Ñ—Ñ–µ–∫—Ç–æ–º –≤–∑—Ä—ã–≤–∞ */
    .cell.explode { animation: explode .4s ease-out forwards; }
    @keyframes explode {
      0% { 
        opacity: 1; 
        transform: scale(0.7) rotate(0deg); 
        filter: brightness(1) saturate(1);
      }
      50% { 
        opacity: 1; 
        transform: scale(0.7) rotate(180deg); 
        filter: brightness(1.5) saturate(1.5);
      }
      100% { 
        opacity: 0; 
        transform: scale(0.1) rotate(360deg); 
        filter: brightness(0) saturate(0);
      }
    }

    /* –ê–Ω–∏–º–∞—Ü–∏—è —É–¥–∞–ª–µ–Ω–∏—è —Å —ç—Ñ—Ñ–µ–∫—Ç–æ–º –∑–∞—Ç—É—Ö–∞–Ω–∏—è */
    .cell.fade-out { animation: fadeOut .3s ease-in forwards; }
    @keyframes fadeOut {
      0% { 
        opacity: 1; 
        transform: scale(1); 
        filter: hue-rotate(0deg);
      }
      100% { 
        opacity: 0; 
        transform: scale(0.8); 
        filter: hue-rotate(180deg) brightness(0.3);
      }
    }

    /* –ê–Ω–∏–º–∞—Ü–∏—è —É–¥–∞–ª–µ–Ω–∏—è —Å —ç—Ñ—Ñ–µ–∫—Ç–æ–º —Å–∂–∞—Ç–∏—è */
    .cell.shrink { animation: shrink .25s ease-in forwards; }
    @keyframes shrink {
      0% { 
        opacity: 1; 
        transform: scale(1); 
        border-radius: 12px;
      }
      100% { 
        opacity: 0; 
        transform: scale(0.1); 
        border-radius: 50%;
      }
    }

    /* –ê–Ω–∏–º–∞—Ü–∏—è —É–¥–∞–ª–µ–Ω–∏—è —Å —ç—Ñ—Ñ–µ–∫—Ç–æ–º –≤–æ–ª–Ω—ã */
    .cell.wave-out { animation: waveOut .35s ease-out forwards; }
    @keyframes waveOut {
      0% { 
        opacity: 1; 
        transform: scale(1) rotateY(0deg); 
      }
      50% { 
        opacity: 0.7; 
        transform: scale(1.1) rotateY(90deg); 
      }
      100% { 
        opacity: 0; 
        transform: scale(0.5) rotateY(180deg); 
      }
    }
    /* –ê–Ω–∏–º–∞—Ü–∏—è —É–¥–∞–ª–µ–Ω–∏—è –ø–æ—Å–ª–µ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è */
    .cell.move-remove {
      transition: all 0.3s ease-out;
    }


    /*  –ø–æ–¥—Å–∫–∞–∑–∫–∏ */
    .hint { font-size: 13px; opacity: .8; }
    button { background:#1c2335; color:#e9ecf1; border:1px solid #2a3550; border-radius:12px; padding:8px 12px; cursor:pointer; }
    button:hover { background:#222c44; }
    button { transition: filter .25s linear, background-color .25s linear, color .25s linear, opacity .25s linear; }
    #hint.cooldown, #challenge-mode.cooldown  { filter: brightness(0.7) saturate(0.7); opacity: 0.7; pointer-events: none; }
    /* –ü–æ–¥—Å–≤–µ—Ç–∫–∞ —Å—É–ø–µ—Ä-–ø–∞—Ä—ã (–∏—Å–∫–ª—é—á–∏—Ç–µ–ª—å–Ω—ã–π –∫—Ä–∞—Å–Ω—ã–π) */


    .cell.filled.hinted-super {
      background-color: rgba(255, 60, 60, .35) !important;
      box-shadow: 0 0 0 1.25px rgba(255,80,80,.95), 0 10px 26px rgba(255,60,60,.25), inset 0 0 16px rgba(255,120,120,.25);
    }
    /* –¶–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –≤—Å–ø–ª—ã–≤–∞—é—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ */
    .overlay-message {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%) scale(.8);
      pointer-events: none;
      padding: 10px 14px;
      border-radius: 12px;
      background: rgba(20,26,40,.8);
      border: 1px solid #2a3550;
      color: #e9ecf1;
      font-weight: 600;
      text-align: center;
      opacity: 0;
      animation: msg-pop 900ms ease-out forwards;
      z-index: 1000;
      white-space: nowrap;
    }
    @keyframes msg-pop {
      10% { opacity: 1; transform: translate(-50%, -50%) scale(1.06); }
      40% { opacity: 1; transform: translate(-50%, -50%) scale(1.0); }
      100% { opacity: 0; transform: translate(-50%, -50%) scale(1.05); }
    }





    .settings-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    .settings-modal.active {
      display: flex;
    }

    .settings-content {
      background: #0f1522;
      border: 1px solid #1f2940;
      border-radius: 16px;
      padding: 24px;
      max-width: 400px;
      width: 90vw;
      max-height: 80vh;
      overflow-y: auto;
      
 
      scrollbar-width: thin;
      scrollbar-color:  var(--color-accent-1-SCRLBR);
    }
    

    .settings-content::-webkit-scrollbar {
      width: 6px;
    }
    
    .settings-content::-webkit-scrollbar-track {
      background: #1a2130;
      border-radius: 3px;
    }
    
    .settings-content::-webkit-scrollbar-thumb {
      background: #64e0d0;
      border-radius: 3px;
      transition: background 0.2s ease;
    }
    
    .settings-content::-webkit-scrollbar-thumb:hover {
      background: #7aebe0;
    }

    .settings-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .settings-title {
      font-size: 18px;
      font-weight: 600;
      color: #e9ecf1;
    }

    .settings-close {
      background: none;
      border: none;
      color: #e9ecf1;
      font-size: 24px;
      cursor: pointer;
      padding: 0;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: background-color 0.2s;
    }

    .settings-close:hover {
      background: #1a2130;
    }

    .setting-group {
      margin-bottom: 20px;
    }

    .setting-label {
      display: block;
      margin-bottom: 8px;
      font-size: 14px;
      color: #e9ecf1;
      font-weight: 500;
    }

    .setting-value {
      display: inline-block;
      margin-left: 10px;
      color: #64e0d0;
      font-weight: 600;
    }
    /* ===== –ê–¥–∞–ø—Ç–∞—Ü–∏—è –ø–æ–¥ –º–æ–±–∏–ª—å–Ω—ã–µ (—Å—Ç—Ä–∞–Ω–∏—Ü–∞ –ø–æ–ª–Ω–æ—Å—Ç—å—é –ø–æ–º–µ—â–∞–µ—Ç—Å—è –Ω–∞ —ç–∫—Ä–∞–Ω) ===== */
      @media (min-width: 769px) {
      :root { /*--cell: 56px; /*--gap: 3px;*/ } /* –≤–æ—Ç —Å —ç—Ç–∏–º –Ω–µ–±–æ–ª—å—à–µ –ø—Ä–æ–±–ª–µ–º–∫–∏. –±—ã–ª–æ --gap: 6 —Ç.–µ. –≤ 2 —Ä–∞–∑–∞ –±–æ–ª—å—à–µ; */
      body { padding:inherit; }
      .hud { flex-wrap: wrap; gap: 8px; padding-top: var(--board-padding);}
      .settings-content {max-height: 80vh;}
      #board .cell {border-radius: 7px; }
    }
    @media (max-width: 768px) {
      :root { /*--cell: 44px; /*--gap: 3px;*/ }
      body { padding:inherit; }
      .hud { flex-wrap: wrap; gap: 8px; padding-top: var(--board-padding);}
      .settings-content {max-height: 80vh;}
      #board .cell {border-radius: 7px; }
    }
    @media (max-width: 480px) {
      :root { /*--cell: 34px; /*--gap: 2px;*/ }
      body { padding:inherit; }
      .hint { font-size: 12px; }
      .hud {padding-top: var(--board-padding);}
      .settings-content {max-height: 80vh;}
      #board .cell {border-radius: 6px;}
    }
    @media (max-width: 380px) {
      :root { /*--cell: 30px; /*--gap: 1.5px;*/ }
      body { padding: inherit; }
      .hud {padding-top: var(--board-padding);}
      .settings-content {max-height: 80vh;}
      #board .cell {border-radius: 5px;}
    }

    .slider-container {
      position: relative;
      margin-top: 8px;
    }

    .slider {
      width: 100%;
      height: 6px;
      background: #1a2130;
      border-radius: 3px;
      outline: none;
      -webkit-appearance: none;
      appearance: none;
    }

    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      background: #64e0d0;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(100, 224, 208, 0.3);
      transition: all 0.2s;
    }

    .slider::-webkit-slider-thumb:hover {
      background: #7aebe0;
      transform: scale(1.1);
    }

    .slider::-moz-range-thumb {
      width: 18px;
      height: 18px;
      background: #64e0d0;
      border-radius: 50%;
      cursor: pointer;
      border: none;
      box-shadow: 0 2px 6px rgba(100, 224, 208, 0.3);
    }

    .slider-labels {
      display: flex;
      justify-content: space-between;
      margin-top: 8px;
      font-size: 12px;
      color: #8b9bb4;
    }

    .size-slider-labels {
      display: flex;
      justify-content: space-between;
      margin-top: 8px;
      font-size: 12px;
      color: #8b9bb4;
    }

    .size-slider-labels .auto {
      color: #64e0d0;
      font-weight: 600;
    }

    .settings-actions {
      display: flex;
      gap: 12px;
      margin-top: 24px;
    }

    .settings-actions button {
      flex: 1;
      padding: 10px 16px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn-apply {
      background: #64e0d0;
      color: #0f1522;
      border: none;
    }

    .btn-apply:hover {
      background: #7aebe0;
    }

    .btn-cancel {
      background: #1a2130;
      color: #e9ecf1;
      border: 1px solid #2a3550;
    }

    .btn-cancel:hover {
      background: #222c44;
    }


    .btn-settings {
      background: #1c2335;
      color: #e9ecf1;
      border: 1px solid #2a3550;
      border-radius: 12px;
      padding: 8px 12px;
      cursor: pointer;
      transition: all 0.25s linear;
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
    }

    .btn-settings:hover {
      background: #222c44;
    }

    .btn-settings svg {
      width: 14px;
      height: 14px;
      fill: currentColor;
    }

    .theme-selector {
      margin-top: 8px;
    }

    .theme-select {
      width: 100%;
      padding: 8px 12px;
      background: #1a2130;
      color: #e9ecf1;
      border: 1px solid #2a3550;
      border-radius: 8px;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .theme-select:hover {
      background: #222c44;
      border-color: #64e0d0;
    }

    .theme-select:focus {
      outline: none;
      border-color: #64e0d0;
      box-shadow: 0 0 0 2px rgba(100, 224, 208, 0.2);
    }

    .theme-preview {
      margin-top: 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 12px;
      background: #0a0f1a;
      border: 1px solid #1f2940;
      border-radius: 8px;
      max-height: 300px;
      overflow-y: auto;
      

      scrollbar-width: thin;
      scrollbar-color: #64e0d0 #1a2130;
    }
    
  
    .theme-preview::-webkit-scrollbar {
      width: 6px;
    }
    
    .theme-preview::-webkit-scrollbar-track {
      background: #1a2130;
      border-radius: 3px;
    }
    
    .theme-preview::-webkit-scrollbar-thumb {
      background: #64e0d0;
      border-radius: 3px;
      transition: background 0.2s ease;
    }
    
    .theme-preview::-webkit-scrollbar-thumb:hover {
      background: #7aebe0;
    }

    .color-preview {
      width: 20px;
      height: 20px;
      border-radius: 3px;
      border: 1px solid #2a3550;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }

    .color-preview:hover {
      transform: scale(1.15);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
    }

    .color-preview.selected {
      border: 2px solid #64e0d0;
      box-shadow: 0 0 0 2px rgba(100, 224, 208, 0.3);
    }

    .theme-preview.empty {
      display: flex;
      align-items: center;
      justify-content: center;
      color: #8b9bb4;
      font-size: 12px;
      font-style: italic;
      min-height: 60px;
    }


    .palette-header {
      transition: all 0.2s ease;
      border-radius: 4px;
      padding: 2px 4px;
    }

    .palette-header:hover {
      background: rgba(100, 224, 208, 0.1);
      color: #64e0d0 !important;
    }

    .palette-header:active {
      background: rgba(100, 224, 208, 0.2);
      transform: scale(0.98);
    }

    .custom-theme-input {
      margin-top: 16px;
      padding: 16px;
      background: #0a0f1a;
      border: 1px solid #1f2940;
      border-radius: 8px;
    }

    .input-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .btn-clear-custom {
      background: #2a3550;
      color: #e9ecf1;
      border: 1px solid #3a4560;
      border-radius: 6px;
      padding: 6px 12px;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn-clear-custom:hover {
      background: #3a4560;
      border-color: #64e0d0;
    }

    #custom-colors-input {
      width: 100%;
      width: -webkit-fill-available;
      background: #1a2130;
      color: #e9ecf1;
      border: 1px solid #2a3550;
      border-radius: 6px;
      padding: 10px;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      resize: vertical;
      min-height: 80px;
      transition: all 0.2s;
      
 
      scrollbar-width: thin;
      scrollbar-color: #64e0d0 #1a2130;
    }
    
  
    #custom-colors-input::-webkit-scrollbar {
      width: 6px;
    }
    
    #custom-colors-input::-webkit-scrollbar-track {
      background: #1a2130;
      border-radius: 3px;
    }
    
    #custom-colors-input::-webkit-scrollbar-thumb {
      background: #64e0d0;
      border-radius: 3px;
      transition: background 0.2s ease;
    }
    
    #custom-colors-input::-webkit-scrollbar-thumb:hover {
      background: #7aebe0;
    }

    #custom-colors-input:focus {
      outline: none;
      border-color: #64e0d0;
      box-shadow: 0 0 0 2px rgba(100, 224, 208, 0.2);
    }

    #custom-colors-input::placeholder {
      color: #8b9bb4;
      opacity: 0.7;
    }

    .input-actions {
      margin-top: 12px;
      display: flex;
      gap: 8px;
    }

    .btn-add-custom {
      background: #64e0d0;
      color: #0f1522;
      border: none;
      border-radius: 6px;
      padding: 8px 16px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn-add-custom:hover {
      background: #7aebe0;
    }

    .btn-add-custom:disabled {
      background: #2a3550;
      color: #8b9bb4;
      cursor: not-allowed;
    }


    .palette-container.swipeable {
      position: relative;
      overflow: hidden;
      min-height: fit-content;
    }

    .palette-container.swipeable .swipe-overlay {
      position: absolute;
      top: 0;
      right: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent 0%, rgba(255, 0, 0, 0.25) 50%, rgba(255, 0, 0, 1) 100%);
      display: flex;
      align-items: center;
      justify-content: flex-end;
      padding-right: 12px;
      color: #ffffff #ff4444;
      font-size: 12px;
      font-weight: 600;
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
      z-index: 2;
    }

    .palette-container.swipeable.swiping .swipe-overlay {
      opacity: 1;
    }

    .palette-container.swipeable.deleting {
      transform: translateX(-100%);
      opacity: 0;
      transition: all 0.3s ease-out;
    }
    .hud-right {
  display: flex;
  gap: 6px; 
}

/* –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä —Ç–æ–≥–≥–ª–∞ */
.toggle {
  position: relative;
  display: inline-block;
  width: 70px;
  height: 34px;
  cursor: pointer;
}

/* –°–∫—Ä—ã—Ç—ã–π input */
.toggle input {
  opacity: 0;
  width: 0;
  height: 0;
}

/* –°–ª–∞–π–¥–µ—Ä */
.toggle-slider {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #ccc;
  border-radius: 12px; /* –∑–∞–∫—Ä—É–≥–ª–µ–Ω–Ω—ã–µ —É–≥–ª—ã */
  transition: 0.3s;
  font-size: 14px;
  font-family: sans-serif;
  color: white;
  text-align: center;
  line-height: 34px;
}

/* –ö–æ–≥–¥–∞ –≤–∫–ª—é—á–µ–Ω */
.toggle input:checked + .toggle-slider {
  background-color: #4caf50;
}

/* –¢–µ–∫—Å—Ç –≤–Ω—É—Ç—Ä–∏ */
.toggle-slider::before {
  content: "–í—ã–∫–ª";
  position: absolute;
  left: 0;
  width: 100%;
  transition: 0.3s;
}

.toggle input:checked + .toggle-slider::before {
  content: "–í–∫–ª";
}

* { box-sizing: border-box; }

.hidden {
  display: none;
}

.start-btn {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 4rem;
  background: none;
  border: none;
  color: white;
  text-shadow: 0 0 10px black;
  cursor: pointer;
  opacity: 0.9;
  transition: opacity 0.3s ease;
  z-index: 20;
}

.start-btn:hover {
  opacity: 1;
}


.overlay-message {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(0,0,0,0.8);
  color: white;
  padding: 20px;
  border-radius: 12px;
  text-align: center;
  z-index: 30;
}

.overlay-message button {
  margin-top: 15px;
  padding: 8px 16px;
  font-size: 1rem;
  border: none;
  border-radius: 8px;
  cursor: pointer;
}

.overlay-level {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: #0a0f1a;
  border: 1px solid #1f2940;
  border-radius: 12px;
  padding: 20px 28px;
  color: #e0e6f0;
  text-align: center;
  z-index: 50;
  width: 90%;
  box-shadow: 0 0 25px rgba(0,0,0,0.8);
}

.overlay-level-title {
  font-size: 1.6rem;
  font-weight: bold;
  margin-bottom: 16px;
  color: #ffffff;
}

.overlay-level-time {
  font-size: 1.2rem;
  margin-bottom: 16px;
  color: #ffffff;
}

.overlay-level-info {
  display: flex;
  flex-direction: column;
  gap: 6px;
  padding: 12px;
  margin-bottom: 20px;
  background: #111a2c;
  border: 1px solid #1f2940;
  border-radius: 8px;
  font-size: 0.95rem;
  text-align: left;
}

.overlay-level-btn {
  padding: 10px 22px;
  font-size: 1rem;
  background: #64e0d0;
  border: none;
  border-radius: 8px;
  color: #0a0f1a;
  font-weight: 600;
  cursor: pointer;
  transition: background 0.2s ease;
}

.overlay-level-btn:hover {
  background: #7aebe0;
}



.overlay-countdown {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 80px;
  font-weight: bold;
  color: #fff;
  text-shadow: 2px 2px 10px rgba(0,0,0,0.7);
  pointer-events: none;
  z-index: 9999;
  opacity: 0;
}

/* –ê–Ω–∏–º–∞—Ü–∏—è –ø–æ—è–≤–ª–µ–Ω–∏—è –∏ –∏—Å—á–µ–∑–Ω–æ–≤–µ–Ω–∏—è */
.overlay-countdown.animate {
  animation: countdownPop 1s ease forwards;
}

@keyframes countdownPop {
  0% {
    transform: translate(-50%, -50%) scale(2);
    opacity: 0;
  }
  30% {
    transform: translate(-50%, -50%) scale(1);
    opacity: 1;
  }
  70% {
    transform: translate(-50%, -50%) scale(1);
    opacity: 1;
  }
  100% {
    transform: translate(-50%, -50%) scale(0.5);
    opacity: 0;
  }
}

#hint.cooldown,
#challenge-mode.cooldown,
#back.cooldown {
  filter: brightness(0.7) saturate(0.7);
  /*opacity: 0.7;*/
  pointer-events: none;
  animation: cooldown var(--cooldown-time) linear;
}




  </style>
</head>
<body>
  <!-- Loader -->
<div id="game-loader" aria-hidden="true" role="status" aria-live="polite">
  <div class="loader-inner" aria-hidden="true">
    <div class="cube" aria-hidden="true"></div>
    <div class="loader-label">–ó–∞–≥—Ä—É–∑–∫–∞...</div>
  </div>
</div>


  <div class="game">
    <div class="hud">
     <div class="hud-left">
      <button id="hint" class="btn-settings" style="margin-left: 10px;">–ü–æ–¥—Å–∫–∞–∑–∫–∞</button>
      <button id="back" class="btn-settings hidden" style="margin-left: 10px;">
        <svg viewBox="0 0 24 24">
          <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
        </svg>
      </button>

      </div>
      <!-- –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è –∑–æ–Ω–∞ -->
      <div class="hud-center">



        
      </div>

      <div class="hud-right">
        <!-- –ö–Ω–æ–ø–∫–∞ –¥–ª—è –≤–∫–ª—é—á–µ–Ω–∏—è —Ä–µ–∂–∏–º–∞ –∏—Å–ø—ã—Ç–∞–Ω–∏—è -->

        <button id="challenge-mode" class="btn-settings">
          <svg viewBox="0 0 24 24" width="24" height="24">
            <!-- –∫—Ä—É–≥ —Ü–∏—Ñ–µ—Ä–±–ª–∞—Ç–∞ -->
            <circle cx="12" cy="12" r="9" stroke="currentColor" stroke-width="2" fill="none"/>
            <!-- —Å—Ç—Ä–µ–ª–∫–∞ —á–∞—Å–æ–≤ -->
            <line x1="12" y1="12" x2="12" y2="7" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
            <!-- —Å—Ç—Ä–µ–ª–∫–∞ –º–∏–Ω—É—Ç -->
            <line x1="12" y1="12" x2="16" y2="12" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
          </svg>
        </button>
        <!-- –¢–∞–π–º–µ—Ä (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é —Å–∫—Ä—ã—Ç) -->
        <span id="timer" class="btn-settings hidden" style="margin-right: 10px; max-height: 32px;">00:00</span>
      <button id="reset" class="btn-settings">
        <svg viewBox="0 0 24 24" width="12" height="12" fill="white">
          <path d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.11-.3 2.15-.82 3.05l1.46 1.46C19.24 14.88 20 13.5 20 12c0-4.42-3.58-8-8-8zm-6.64 3.05L3.9 5.59C2.76 7.12 2 9.06 2 11c0 4.42 3.58 8 8 8v3l4-4-4-4v3c-3.31 0-6-2.69-6-6 0-1.11.3-2.15.82-3.05z"/>
        </svg>
        
      </button>
     
      <button id="settings" class="btn-settings" style="margin-right: 10px;">
        <svg viewBox="0 0 24 24">
          <path d="M12,15.5A3.5,3.5 0 0,1 8.5,12A3.5,3.5 0 0,1 12,8.5A3.5,3.5 0 0,1 15.5,12A3.5,3.5 0 0,1 12,15.5M19.43,12.97C19.47,12.65 19.5,12.33 19.5,12C19.5,11.67 19.47,11.34 19.43,11L21.54,9.37C21.73,9.22 21.78,8.95 21.66,8.73L19.66,5.27C19.54,5.05 19.27,4.96 19.05,5.05L16.56,6.05C16.04,5.66 15.5,5.32 14.87,5.07L14.5,2.42C14.46,2.18 14.25,2 14,2H10C9.75,2 9.54,2.18 9.5,2.42L9.13,5.07C8.5,5.32 7.96,5.66 7.44,6.05L4.95,5.05C4.73,4.96 4.46,5.05 4.34,5.27L2.34,8.73C2.22,8.95 2.27,9.22 2.46,9.37L4.57,11C4.53,11.34 4.5,11.67 4.5,12C4.5,12.33 4.53,12.65 4.57,12.97L2.46,14.63C2.27,14.78 2.22,15.05 2.34,15.27L4.34,18.73C4.46,18.95 4.73,19.03 4.95,18.95L7.44,17.94C7.96,18.34 8.5,18.68 9.13,18.93L9.5,21.58C9.54,21.82 9.75,22 10,22H14C14.25,22 14.46,21.82 14.5,21.58L14.87,18.93C15.5,18.68 16.04,18.34 16.56,17.94L19.05,18.95C19.27,19.03 19.54,18.95 19.66,18.73L21.66,15.27C21.78,15.05 21.73,14.78 21.54,14.63L19.43,12.97Z"/>
        </svg>
        
      </button></div>
    </div>
    <div id="board" aria-label="–ò–≥—Ä–æ–≤–æ–µ –ø–æ–ª–µ"></div>

  </div>

  <div class="settings-modal">
    <div class="settings-content">
      <div class="settings-header">
        <h2 class="settings-title">–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–≥—Ä—ã</h2>
        <button class="settings-close" onclick="closeSettings()">√ó</button>
      </div>
      
      <div class="setting-group">
        <label class="setting-label">
          –†–∞–∑–º–µ—Ä –ø–æ–ª—è: <span class="setting-value" id="settings-size">10√ó10</span>
        </label>
        <div class="slider-container">
          <input type="range" min="0" max="3" value="0" class="slider" id="size-slider">
          <div class="size-slider-labels">
            <span class="auto">auto</span>
            <span>10√ó10</span>
            <span>10√ó15</span>
            <span>10√ó20</span>
          </div>
        </div>
      </div>
      
      <div class="setting-group">
        <label class="setting-label">
          –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ü–≤–µ—Ç–æ–≤: <span class="setting-value" id="settings-maxColors">20</span>
        </label>
        <div class="slider-container">
          <input type="range" min="15" max="29" value="20" class="slider" id="maxColors-slider">
          <div class="slider-labels">
            <span>15</span>
            <span>29</span>
          </div>
        </div>
      </div>
      
      <div class="setting-group">
        <label class="setting-label">
          –ú–∏–Ω–∏–º—É–º –ø–∞—Ä: <span class="setting-value" id="settings-minPair">1</span>
        </label>
        <div class="slider-container">
          <input type="range" min="1" max="5" value="1" class="slider" id="minPair-slider">
          <div class="slider-labels">
            <span>1</span>
            <span>2</span>
            <span>3</span>
            <span>4</span>
            <span>5</span>
          </div>
        </div>
      </div>

      <div class="setting-group">
        <label class="setting-label">
          –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ä–∏—Å—É–Ω–∫–∏: <span class="setting-value" id="settings-useImages">–í–∫–ª—é—á–µ–Ω–æ</span>
        </label>
        <div class="slider-container">
          <input type="range" min="0" max="1" value="1" class="slider" id="useImages-slider">
          <div class="slider-labels">
            <span>–í—ã–∫–ª—é—á–µ–Ω–æ</span>
            <span>–í–∫–ª—é—á–µ–Ω–æ</span>
          </div>
        </div>
      </div>

      <div class="setting-group">
        <label class="setting-label">
          –ì–∞–ª–µ—Ä–µ—è —Ä–∏—Å—É–Ω–∫–æ–≤: <span class="setting-value" id="settings-room">–ö–æ–º–Ω–∞—Ç–∞ 1</span>
        </label>
        <div class="theme-selector">
          <select id="room-selector" class="theme-select">
            <option value="room1">–ö–æ–º–Ω–∞—Ç–∞ 1</option>
            <option value="room2">–ö–æ–º–Ω–∞—Ç–∞ 2</option>
            <!--option value="future">–°–∫–æ—Ä–æ..</option-->
          </select>
        </div>
      </div>

      
      <div class="setting-group">
        <label class="setting-label">
          –¢–µ–º–∞ –ø–∞–ª–∏—Ç—Ä—ã: <span class="setting-value" id="settings-theme">–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é</span>
        </label>
        <div class="theme-selector">
          <select id="theme-selector" class="theme-select">
            <option value="default">–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é</option>
            <option value="mononight">–û–¥–Ω–æ—Ü–≤–µ—Ç–Ω–∞—è –Ω–æ—á—å</option>
            <option value="bright">–î—Ä—É–≥–∏–µ —Ç–µ–º—ã</option>
            <option value="custom">–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∞—è</option>
          </select>
        </div>
        <div class="theme-preview" id="theme-preview">

        </div>
        

        <div class="custom-theme-input" id="custom-theme-input" style="display: none;">
          <div class="input-header">
            <label class="setting-label">–í–≤–µ–¥–∏—Ç–µ —Ü–≤–µ—Ç–∞</label>
            <button class="btn-clear-custom" onclick="clearCustomTheme()">–û—á–∏—Å—Ç–∏—Ç—å</button>
          </div>
          <textarea id="custom-colors-input" placeholder="#ff0000, #00ff00, #0000ff" rows="3"></textarea>
          <div class="input-actions">
            <button class="btn-add-custom" onclick="addCustomColors()">–î–æ–±–∞–≤–∏—Ç—å —Ü–≤–µ—Ç–∞</button>
          </div>
        </div>
      </div>
      
      <div class="setting-group">
        <label class="setting-label">
          –ü–æ–ª–Ω–æ—ç–∫—Ä–∞–Ω–Ω—ã–π —Ä–µ–∂–∏–º: <span class="setting-value" id="settings-fullscreen">–í—ã–∫–ª—é—á–µ–Ω</span>
        </label>
        <div class="slider-container">
          <input type="range" min="0" max="1" value="0" class="slider" id="fullscreen-slider">
          <div class="slider-labels">
            <span>–í—ã–∫–ª—é—á–µ–Ω</span>
            <span>–í–∫–ª—é—á–µ–Ω</span>
          </div>
        </div>
      </div>
      
      <div class="settings-actions">
        <button class="btn-apply" onclick="applySettings()">–ü—Ä–∏–º–µ–Ω–∏—Ç—å</button>
        <button class="btn-cancel" onclick="closeSettings()">–û—Ç–º–µ–Ω–∞</button>
      </div>
    </div>
  </div>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-PYJ5SM4Z1Y"></script>

<script>
  let loaderStartTime = 0;

  window.showLoader = function() {
    const loader = document.getElementById('game-loader');
    if (!loader) return;
    loader.style.display = 'flex';
    loader.style.opacity = "1";
    loader.setAttribute('aria-hidden', 'false');
    loaderStartTime = Date.now();
  };

    // hideLoader —Ç–µ–ø–µ—Ä—å —É–º–µ–µ—Ç –ø—Ä–∏–Ω–∏–º–∞—Ç—å callback
  window.hideLoader = function(callback) {
    const loader = document.getElementById('game-loader');
    if (!loader || loader.style.display === 'none') {
      // –µ—Å–ª–∏ —Å–∫—Ä—ã–≤–∞—Ç—å –Ω–µ—á–µ–≥–æ ‚Äî –≤—ã–∑—ã–≤–∞–µ–º callback —Å—Ä–∞–∑—É
      if (typeof callback === "function") callback();
      return;
    }

    const elapsed = Date.now() - loaderStartTime;
    const minDuration = 500; // –º–∏–Ω–∏–º—É–º 0,5 —Å–µ–∫—É–Ω–¥

    const remaining = Math.max(0, minDuration - elapsed);
    setTimeout(() => {
      loader.style.transition = "opacity 0.5s ease";
      loader.style.opacity = "0";

      setTimeout(() => {
        loader.style.display = 'none';
        loader.style.transition = "";
        loader.setAttribute('aria-hidden', 'true');

        if (typeof callback === "function") {
          callback();
        }
      }, 500); // —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å transition
    }, remaining);
  };

</script>
<script>

  //ImageDB.cleanup().catch(console.error);–∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –Ω–∞ —Å–ª—É—á–∞–π –æ—á–∏—Å—Ç–∫–∏ imagedb

// indexeddb.js
const ImageDB = {
  db: null,

  async open() {
    if (this.db) return this.db;

    return new Promise((resolve, reject) => {
      const request = indexedDB.open("GameImagesDB", 2); // –≤–µ—Ä—Å–∏—è –ë–î

      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        if (db.objectStoreNames.contains("images")) {
          db.deleteObjectStore("images");
        }
        const store = db.createObjectStore("images"); // key = url
        store.createIndex("timestamp", "timestamp");
      };

      request.onsuccess = (event) => {
        this.db = event.target.result;
        resolve(this.db);
      };

      request.onerror = (event) => reject(event.target.error);
    });
  },

  async put(key, blob) {
    const db = await this.open();
    const record = { blob, timestamp: Date.now() };

    return new Promise((resolve, reject) => {
      const tx = db.transaction("images", "readwrite");
      tx.objectStore("images").put(record, key);
      tx.oncomplete = () => resolve();
      tx.onerror = (e) => reject(e.target.error);
    });
  },

  async get(key) {
    const db = await this.open();
    return new Promise((resolve, reject) => {
      const tx = db.transaction("images", "readonly");
      const request = tx.objectStore("images").get(key);
      request.onsuccess = () => resolve(request.result);
      request.onerror = (e) => reject(e.target.error);
    });
  },

  async delete(key) {
    const db = await this.open();
    return new Promise((resolve, reject) => {
      const tx = db.transaction("images", "readwrite");
      tx.objectStore("images").delete(key);
      tx.oncomplete = () => resolve();
      tx.onerror = (e) => reject(e.target.error);
    });
  },

  async cleanup(olderThanMs = 7 * 24 * 60 * 60 * 1000) {
    const db = await this.open();
    return new Promise((resolve, reject) => {
      const tx = db.transaction("images", "readwrite");
      const store = tx.objectStore("images");
      const req = store.openCursor();

      req.onsuccess = (e) => {
        const cursor = e.target.result;
        if (cursor) {
          const { timestamp } = cursor.value;
          if (Date.now() - timestamp > olderThanMs) {
            cursor.delete();
          }
          cursor.continue();
        }
      };

      tx.oncomplete = () => resolve();
      tx.onerror = (e) => reject(e.target.error);
    });
  }
};


</script>


</script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-PYJ5SM4Z1Y');
</script>
  <script>
    
    const CONFIG = {
      width: 10,         // —à–∏—Ä–∏–Ω–∞ –ø–æ–ª—è (—Ä–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º–æ)
      height: 10,       // –≤—ã—Å–æ—Ç–∞ –ø–æ–ª—è (—Ä–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º–æ)
      maxColors: 20,      // MAXID_color ‚Äî –º–∞–∫—Å–∏–º—É–º —Ä–∞–∑–Ω—ã—Ö —Ü–≤–µ—Ç–æ–≤ (—Ä–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º–æ)
      minPair: 1,       // MIN_pair ‚Äî –º–∏–Ω–∏–º—É–º –ø–∞—Ä –∫–∞–∂–¥–æ–≥–æ —Ü–≤–µ—Ç–∞ (—Ä–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º–æ)
      theme: 'default', 
      fullscreen: false,    
      useImages: true,       // <-- –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é —Ä–∏—Å—É–Ω–∫–∏ –≤—ã–∫–ª—é—á–µ–Ω—ã
      currentRoom: 'room1', // –∫–ª—é—á –∏–∑ AVAILABLE_ROOM
    };


    // –ø—Ä–∏–º–µ—Ä—ã –º–∞—Å—Å–∏–≤–æ–≤ (—Ñ–∞–π–ª—ã –ª–µ–∂–∞—Ç –≤ /img)
    const ROOM1 = [
      // –æ–¥–Ω–∞ ¬´—Ç–µ–º–∞¬ª (–Ω–∞–ø—Ä., –Ω–∞–±–æ—Ä –∫–∞—Ä—Ç–∏–Ω–æ–∫ –¥–ª—è –∫–æ–º–Ω–∞—Ç—ã)
      ['1.png', '2.png', '3.png', '4.png', '5.png', '6.png', '7.png', '8.png', '9.png', '10.png', '11.png', '12.png', '13.png', '14.png', '15.png', '16.png', '17.png', '18.png', '19.png', '20.png', '21.png', '22.png','23.png','24.png'/*,'25.png'*/]
    ];

    const ROOM2 = [
      ['1.png','2.png','3.png','4.png','5.png','6.png','7.png','8.png','9.png', '10.png', '11.png', '12.png', '13.png', '13a.png', '14.png', '15.png', '16.png', '17.png', '18.png', '19.png', '13a.png', '20.png', '21.png', '22.png', '23.png', '24.png', '25.png',  '26.png', '27.png', '28.png']
    ];

    const AVAILABLE_ROOM = {
      room1: { name: '–ö–æ–º–Ω–∞—Ç–∞ 1', folder: 'img', themes: ROOM1 },
      room2: { name: '–ö–æ–º–Ω–∞—Ç–∞ 2', folder: 'img2', themes: ROOM2 }
    };

    // –¢–µ–º—ã —Ü–≤–µ—Ç–æ–≤
    const THEMES = [

      ['#D16F6F', '#e2a73d', '#3EA084', '#4B79B0', '#7A5EA0',
       '#B36D8C', '#246e5f', '#C07A3F', '#794b4b', '#6FAF7A',
        '#B05B4A', '#B78E62', '#3e5553', '#213D45', '#BFAF56',
         '#675250', '#426b37', '#6B8B2E', '#867a30', '#af3e33',
          '#74717d', '#D26947', '#0E7A78', '#C6A200', '#5A4970', '#0E7A78', '#C6A200', '#5A4970', '#5A4970'],

    ];


   
    const THEMES_MONONIGHT = [
      
      ['#5a1830','#6f1e3a','#7e2346','#8b2d59','#a33b6b','#b24c79','#c25a89','#d06a95','#7a2048','#9a3a69'],
      
      ['#0b3134','#0d3d40','#0e5054','#0f6b69','#0e6062','#136c6f','#1a7f82','#259499','#2aa9ad','#34b7ba'],
  
      ['#2a2440','#2b2a49','#3b2f6e','#494a83','#5c4fb3','#6e65c8','#575aa0','#646ab8','#7a7bd0','#8a8ae0'],

      ['#1c2734','#203040','#243244','#2a3e54','#2d3e55','#34506a','#3e6280','#405677','#487496','#4f80a4'],

      ['#163021','#1d3b2a','#1f4330','#25503a','#285740','#2e664a','#316b50','#377c5a','#3a7f60','#41926a'],

      ['#4a2f15','#5a3a1a','#5e3d1b','#6f4a21','#724b21','#845a28','#865a27','#996a30','#9a682d','#ae7a37']
    ];

        const THEMES_BRIGHT = [
          ['#ff0000','#ff7f00','#ffff00','#7fff00','#00ff00',
       '#00ff7f','#00ffff','#007fff','#0000ff','#7f00ff',
       '#ff00ff','#ff007f','#bf3030','#bf6f30','#bfbf30',
       '#6fbf30','#30bf30','#30bf6f','#30bfbf','#306fbf',
       '#3030bf','#6f30bf','#bf30bf','#bf306f','#bf3030'],

        [   "#5a0f0f",
  "#7a1b1b",
  "#8b2e2e",
  "#a14418",
  "#b36a1f",
  "#8c6c1a",
  "#6b4f16",
  "#4d3812",
  "#1e3a1e",
  "#2d572c",
  "#3c7040",
  "#496d5a",
  "#355b57",
  "#2a4d4a",
  "#1f3b3a",
  "#2e3e5c",
  "#1d2f4d",
  "#243a6b",
  "#162236",
  "#301d4a",
  "#42295f",
  "#532f73",
  "#3d2557",
  "#2b193f",
  "#5a2b4b",
  "#6c3558",
  "#472d20",
  "#3b2a1d",
  "#5c442f",
  "#6a5a48" ] 

    ];

    
    const THEMES_CUSTOM = [];

   
    const AVAILABLE_THEMES = {
      'default': { name: '–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é', themes: THEMES },
      'mononight': { name: '–û–¥–Ω–æ—Ü–≤–µ—Ç–Ω–∞—è –Ω–æ—á—å', themes: THEMES_MONONIGHT },
      'bright': { name: '–Ø—Ä–∫–∏–µ', themes: THEMES_BRIGHT },
      'custom': { name: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∞—è', themes: THEMES_CUSTOM }
    };

    // –£—Ç–∏–ª–∏—Ç—ã –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
    const idx = (x, y, width) => y * width + x;
    
    
    const STORAGE_KEY = 'blockGameData';
    //let challengeModeToken = 0;
      let challengeMode = false;
    
    function saveGameData() {
      if (!CONFIG.saveData) return;
      
      try {
        const gameData = {
         

          config: {
            width: game.width,
            height: game.height,
            maxColors: game.maxColors,
            minPair: game.minPair,
            theme: game.currentTheme,
            fullscreen: CONFIG.fullscreen,
            saveData: CONFIG.saveData,
            useImages: CONFIG.useImages,
            currentRoom: CONFIG.currentRoom
          },

         
          gameState: {
            board: game.board,
            pinnedPaletteIndex: game.pinnedPaletteIndex,
            theme: game.theme
          },
          
          customPalettes: THEMES_CUSTOM,
          
          lastSaved: Date.now()
        };
        
        localStorage.setItem(STORAGE_KEY, JSON.stringify(gameData));
        console.log('–î–∞–Ω–Ω—ã–µ –∏–≥—Ä—ã —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã');
      } catch (error) {
        console.error('–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö:', error);
        showMessage('–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö', 'error');
      }
    }
    
    function loadGameData() {
      if (!CONFIG.saveData) return null;
      
      try {
        const savedData = localStorage.getItem(STORAGE_KEY);
        if (!savedData) return null;
        
        const gameData = JSON.parse(savedData);
        

        const thirtyDaysAgo = Date.now() - (30 * 24 * 60 * 60 * 1000);
        if (gameData.lastSaved < thirtyDaysAgo) {
          console.log('–°–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ —É—Å—Ç–∞—Ä–µ–ª–∏, –∏—Å–ø–æ–ª—å–∑—É–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é');
          return null;
        }
        
        console.log('–î–∞–Ω–Ω—ã–µ –∏–≥—Ä—ã –∑–∞–≥—Ä—É–∂–µ–Ω—ã');
        return gameData;
      } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö:', error);
        return null;
      }
    }
    
    function clearGameData() {
      try {
        localStorage.removeItem(STORAGE_KEY);

      } catch (error) {

      }
    }



function parseTimeToSeconds(timeStr) {
  try {
    const [minutes, seconds] = timeStr.split(":").map(Number);
    return minutes * 60 + seconds;
  } catch (err) {
    console.warn("‚è± –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞–∑–±–æ—Ä–µ –≤—Ä–µ–º–µ–Ω–∏:", err);
    return null;
  }
}


function sendChallengeCompletedEvent(finalTime) {
  try {
    const elapsedSeconds = parseTimeToSeconds(finalTime);

    gtag('event', 'challenge_completed', {
      time_spent_sec: elapsedSeconds ?? 0,  // –µ—Å–ª–∏ null ‚Üí –ø–æ–¥—Å—Ç–∞–≤–∏–º 0
      time_spent_str: finalTime,            // –æ—Å—Ç–∞–≤–∏–º –∏ —Å—Ç—Ä–æ–∫—É –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
      board_height: CONFIG.height,
      color_count: CONFIG.maxColors,
      min_pairs: CONFIG.minPair
    });
  } catch (err) {
    console.warn("‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Å–æ–±—ã—Ç–∏—è challenge_completed:", err);
  }
}


    class Game {

      constructor({ width, height, maxColors, minPair, theme = 'default' }) {
        this.width = width;
        this.height = height;
        this.size = Math.max(width, height);
        this.currentTheme = theme;
        this.pinnedPaletteIndex = -1;

        this.useImages = CONFIG.useImages;
        this.currentRoom = CONFIG.currentRoom || 'room1';


        // üîπ –≤–æ—Ç —Ç—É—Ç –≤—ã–±–∏—Ä–∞–µ–º –∫–∞—Ä—Ç–∏–Ω–∫–∏ –¥–ª—è —Ç–µ–∫—É—â–µ–π –∫–æ–º–Ω–∞—Ç—ã
        this.roomImages = AVAILABLE_ROOM[this.currentRoom] || [];

       this.imageUrlCache = new Map(); // –∫–ª—é—á -> –≥–æ—Ç–æ–≤—ã–π blobUrl

        this.theme = this.getCurrentThemeColors();
        this.maxColors = Math.min(maxColors, this.theme.length);
        this.minPair = minPair;

        this.state = {
          locked: false,
          source: null,
          candidates: []
        };

        this.palette = this.getCurrentThemeColors();
        this.roomImages = this.getCurrentRoomImages();
        this.ensureImageModeLimits();

        this.superHint = null;
        this._hintCooldownUntil = 0;
        this.drag = {
          active: false,
          startX: null,
          startY: null,
          axis: null,
          startClientX: 0,
          startClientY: 0,
          thresholdPx: 8,
        };
        this._blockClicksUntil = 0;

        // –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∑–∞–≥—Ä—É–∑—á–∏–∫ (–¥–µ–ª–µ–≥–∏—Ä–æ–≤–∞–Ω–æ –≥–ª–æ–±–∞–ª—å–Ω–æ)
        window.showLoader();

        // >>> –æ–∂–∏–¥–∞–Ω–∏–µ –∑–∞–≥—Ä—É–∑–∫–∏ –∫–∞—Ä—Ç–∏–Ω–æ–∫ <<<
        if (this.useImages && this.roomImages.length > 0) {
          this.preloadImages(this.roomImages).then(() => {
            this.initGame();
          });
        } else {
          this.initGame();
        }
      }

      // –∑–∞–ø—É—Å–∫ –ø–æ—Å–ª–µ –≤—Å–µ—Ö –ø–æ–¥–≥–æ—Ç–æ–≤–æ–∫
      async initGame() {

        // üîπ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º loader —Å—Ä–∞–∑—É
        if (typeof window.showLoader === "function") window.showLoader();

        // 1Ô∏è‚É£ –ø—Ä–µ–ª–æ–∞–¥–∏–º –∫–∞—Ä—Ç–∏–Ω–∫–∏ (–µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω—ã)
        if (this.useImages && this.roomImages.length > 0) {
          await this.preloadImages(this.roomImages);
          // —Ç—É—Ç –≤—Å–µ –∫–∞—Ä—Ç–∏–Ω–∫–∏ —É–∂–µ –∑–∞–≥—Ä—É–∂–µ–Ω—ã –∏ –≤ IndexedDB
        }

        // 2Ô∏è‚É£ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º –¥–æ—Å–∫—É
        this.board = this.generateBoard();

        // 3Ô∏è‚É£ –º–æ–Ω—Ç–∏—Ä—É–µ–º –¥–æ—Å–∫—É –≤ DOM
        this.mount();

        // 4Ô∏è‚É£ –±–∏–Ω–¥–∏–º –∫–Ω–æ–ø–∫—É –ø–æ–¥—Å–∫–∞–∑–∫–∏
        this.bindHintButton();

        // üîπ —Å–∫—Ä—ã–≤–∞–µ–º loader —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ –æ—Ç—Ä–∏—Å–æ–≤–∫–∏ –¥–æ—Å–∫–∏
        if (typeof window.hideLoader === "function") window.hideLoader();
      }


      getImageBasePath() {
        // –µ—Å–ª–∏ ensureImageModeLimits() —É—Å—Ç–∞–Ω–æ–≤–∏–ª this.roomFolder ‚Äî –∏—Å–ø–æ–ª—å–∑—É–µ–º –µ–≥–æ
        if (this.roomFolder && this.roomFolder.length > 0) return this.roomFolder;
        // fallback –ø–æ —Ç–µ–º–µ (—Ç–µ–∫—É—â–µ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ)
        return this.currentTheme === 'adventure' ? 'img2' : 'img';
      }


    clearImageUrlCache() {
      for (const url of this.imageUrlCache.values()) {
        URL.revokeObjectURL(url);
      }
      this.imageUrlCache.clear();
    }

      // –ø—Ä–µ–ª–æ–∞–¥–µ—Ä –¥–ª—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π

        async preloadImages(files) {
          const basePath = this.getImageBasePath();

          const promises = files.map(async (filename) => {
            const key = `${basePath}/${filename}`;

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º blobUrl –≤ –ø–∞–º—è—Ç–∏
            if (this.imageUrlCache.has(key)) {
              return this.imageUrlCache.get(key);
            }

            // –ë–µ—Ä—ë–º –∏–∑ IndexedDB
            let record = await ImageDB.get(key);
            let blob;

            if (record && record.blob) {
              blob = record.blob;
            } else {
              // –ù–µ—Ç –≤ IndexedDB ‚Üí –∫–∞—á–∞–µ–º
              const response = await fetch(key);
              blob = await response.blob();
              await ImageDB.put(key, blob);
            }

            // –°–æ–∑–¥–∞—ë–º blobUrl
            const blobUrl = URL.createObjectURL(blob);
            this.imageUrlCache.set(key, blobUrl);

            return blobUrl;
          });

          return Promise.all(promises);
        }



      getCurrentThemeColors() {
        const themeConfig = AVAILABLE_THEMES[this.currentTheme];
        if (!themeConfig || !themeConfig.themes || themeConfig.themes.length === 0) {
         
          return THEMES[Math.floor(Math.random() * THEMES.length)];
        }
        
      
        const themes = themeConfig.themes;
        let selectedPaletteIndex;
        
        if (this.pinnedPaletteIndex >= 0 && this.pinnedPaletteIndex < themes.length) {
         
          selectedPaletteIndex = this.pinnedPaletteIndex;
        } else {
       
          selectedPaletteIndex = Math.floor(Math.random() * themes.length);
        }
        
        const selectedPalette = themes[selectedPaletteIndex];
        
      
        const shuffledPalette = [...selectedPalette].sort(() => Math.random() - 0.5);
        
        return shuffledPalette;
      }

  
      updateTheme(newTheme) {
        this.currentTheme = newTheme;
        
      
        const themeConfig = AVAILABLE_THEMES[newTheme];
        if (themeConfig && themeConfig.themes && this.pinnedPaletteIndex >= 0) {
          if (this.pinnedPaletteIndex >= themeConfig.themes.length) {
          
            this.pinnedPaletteIndex = -1;
            showMessage('–ó–∞–∫—Ä–µ–ø–ª–µ–Ω–Ω–∞—è –ø–∞–ª–∏—Ç—Ä–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞ –≤ –Ω–æ–≤–æ–π —Ç–µ–º–µ', 'info');
          }
        }
        
        this.theme = this.getCurrentThemeColors();
        this.maxColors = Math.min(this.maxColors, this.theme.length);
        this.redrawAll();
      }

 

      togglePalettePin(paletteIndex) {
        if (this.pinnedPaletteIndex === paletteIndex) {
          this.pinnedPaletteIndex = -1; // —Å–Ω—è—Ç—å –∑–∞–∫—Ä–µ–ø–ª–µ–Ω–∏–µ
          showMessage('–ü–∞–ª–∏—Ç—Ä–∞ –æ—Ç–∫—Ä–µ–ø–ª–µ–Ω–∞', 'success');
        } else {
          this.pinnedPaletteIndex = paletteIndex; // –∑–∞–∫—Ä–µ–ø–∏—Ç—å
          showMessage(`–ü–∞–ª–∏—Ç—Ä–∞ ${paletteIndex + 1} –∑–∞–∫—Ä–µ–ø–ª–µ–Ω–∞`, 'success');
        }

        this.updateThemePreview();
      }

    
      getCurrentPaletteIndex() {
        const themeConfig = AVAILABLE_THEMES[this.currentTheme];
        if (!themeConfig || !themeConfig.themes) return -1;
        
       
        const palettes = themeConfig.themes;
        for (let i = 0; i < palettes.length; i++) {
          const palette = palettes[i];
        
          const currentColors = new Set(this.theme);
          const paletteColors = new Set(palette);
          
          if (this.theme.every(color => paletteColors.has(color))) {
            return i;
          }
        }
        return -1; 
    }


    updateSettingsDisplay() {
      const sizeSlider = document.getElementById('size-slider');
      const maxColorsSlider = document.getElementById('maxColors-slider');
      const minPairSlider = document.getElementById('minPair-slider');
      
      if (sizeSlider && maxColorsSlider && minPairSlider) {
        const currentSize = `${this.width}x${this.height}`;
        const sizeMap = { '10x10': 1, '10x15': 2, '10x20': 3 };
        sizeSlider.value = sizeMap[currentSize] || 0;
        document.getElementById('settings-size').textContent = currentSize;
        
        maxColorsSlider.value = this.maxColors;
        document.getElementById('settings-maxColors').textContent = this.maxColors;
        
        minPairSlider.value = this.minPair;
        document.getElementById('settings-minPair').textContent = this.minPair;
        
        const fullscreenSlider = document.getElementById('fullscreen-slider');
        if (fullscreenSlider) {
          const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement);
          fullscreenSlider.value = isFullscreen ? 1 : 0;
          document.getElementById('settings-fullscreen').textContent = isFullscreen ? '–í–∫–ª—é—á–µ–Ω' : '–í—ã–∫–ª—é—á–µ–Ω';
        }
        

        
        const themeSelector = document.getElementById('theme-selector');
        if (themeSelector) {
          themeSelector.value = this.currentTheme;
          const themeName = AVAILABLE_THEMES[this.currentTheme]?.name || '–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é';
          document.getElementById('settings-theme').textContent = themeName;
          
          const customInput = document.getElementById('custom-theme-input');
          if (customInput) {
            customInput.style.display = this.currentTheme === 'custom' ? 'block' : 'none';
          }
          
          this.updateThemePreview();

        }
      }

      // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–ª–∞–π–¥–µ—Ä–∞ "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ä–∏—Å—É–Ω–∫–∏"
      const useImagesSlider = document.getElementById('useImages-slider');
      const useImagesLabel = document.getElementById('settings-useImages');

      useImagesSlider.addEventListener('input', (e) => {
        useImagesLabel.textContent = e.target.value === '1' ? '–í–∫–ª—é—á–µ–Ω–æ' : '–í—ã–∫–ª—é—á–µ–Ω–æ';
      });

      // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–µ–ª–µ–∫—Ç–æ—Ä–∞ "–ì–∞–ª–µ—Ä–µ—è —Ä–∏—Å—É–Ω–∫–æ–≤"
      const roomSelector = document.getElementById('room-selector');
      const roomLabel = document.getElementById('settings-room');

      roomSelector.addEventListener('change', (e) => {
        const selectedText = roomSelector.options[roomSelector.selectedIndex].text;
        roomLabel.textContent = selectedText;
      });

    }


    updateThemePreview() {
      const previewContainer = document.getElementById('theme-preview');
      if (!previewContainer) return;
      
      previewContainer.innerHTML = '';
      
      const themeConfig = AVAILABLE_THEMES[this.currentTheme];
      if (!themeConfig || !themeConfig.themes || themeConfig.themes.length === 0) {
        previewContainer.innerHTML = '<div class="theme-preview empty">–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ü–≤–µ—Ç–æ–≤</div>';
        return;
      }
      
      const palettes = themeConfig.themes;
      
      palettes.forEach((palette, paletteIndex) => {
        const headerWrapper = document.createElement('div');
        headerWrapper.style.cssText = 'display: flex; align-items: center; justify-content: space-between; margin: 8px 0 4px;';

        const paletteHeader = document.createElement('div');
        paletteHeader.className = 'palette-header';

        const currentPaletteIndex = this.getCurrentPaletteIndex();
        const isCurrentPalette = currentPaletteIndex === paletteIndex;
        const isPinnedPalette = this.pinnedPaletteIndex === paletteIndex;

        // —Ç–µ–∫—Å—Ç –∑–∞–≥–æ–ª–æ–≤–∫–∞
        const headerLabel = document.createElement('span');
        headerLabel.textContent = `–ü–∞–ª–∏—Ç—Ä–∞ ${paletteIndex + 1}${isCurrentPalette ? ' (—Ç–µ–∫—É—â–∞—è)' : ''}`;

        // –∏–∫–æ–Ω–∫–∞ üìå
        const pinIcon = document.createElement('span');
        pinIcon.textContent = ' üìå';
        pinIcon.style.marginLeft = '6px';
        pinIcon.style.filter = isPinnedPalette ? 'grayscale(0)' : 'grayscale(100%)';
        pinIcon.style.transition = 'filter 0.2s ease';

        paletteHeader.appendChild(headerLabel);
        paletteHeader.appendChild(pinIcon);

        paletteHeader.style.cssText = `
          font-size: 12px;
          color: ${isCurrentPalette ? '#64e0d0' : '#8b9bb4'};
          font-weight: ${isCurrentPalette ? '600' : '400'};
          cursor: pointer;
          user-select: none;
        `;

        paletteHeader.addEventListener('click', () => {
          this.togglePalettePin(paletteIndex);
        });

        // –∫–Ω–æ–ø–∫–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è üìã
        const copyBtn = document.createElement('button');
        copyBtn.innerHTML = 'üìã';
        copyBtn.title = '–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –≤—Å–µ —Ü–≤–µ—Ç–∞';
        copyBtn.style.cssText = 'background: none; border: none; cursor: pointer; font-size: 14px; padding: 0; color: #8b9bb4;';
        
        copyBtn.addEventListener('click', (e) => {
          e.stopPropagation(); // –Ω–µ —Ç—Ä–∏–≥–≥–µ—Ä–∏–º togglePalettePin
          const text = palette.join(', ');
          navigator.clipboard.writeText(text).then(() => {
            copyBtn.innerHTML = '‚úÖ'; // –≤—Ä–µ–º–µ–Ω–Ω–æ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –≥–∞–ª–æ—á–∫—É
            setTimeout(() => { copyBtn.innerHTML = 'üìã'; }, 1000);
          });
        });

        headerWrapper.appendChild(paletteHeader);
        headerWrapper.appendChild(copyBtn);
        previewContainer.appendChild(headerWrapper);

        const paletteContainer = document.createElement('div');
        paletteContainer.className = 'palette-container';
        const borderColor = isCurrentPalette ? '#64e0d0' : (isPinnedPalette ? '#ffaa00' : '#1f2940');
        const bgColor = isCurrentPalette ? '#1a2130' : (isPinnedPalette ? '#2a1f0a' : '#0a0f1a');
        paletteContainer.style.cssText = `display: flex; flex-wrap: wrap; gap: 4px; margin-bottom: 12px; padding: 6px; background: ${bgColor}; border-radius: 6px; border: 1px solid ${borderColor};`;

        if (this.currentTheme === 'custom') {
          paletteContainer.classList.add('swipeable');
          paletteContainer.dataset.paletteIndex = paletteIndex;

          const swipeOverlay = document.createElement('div');
          swipeOverlay.className = 'swipe-overlay';
          swipeOverlay.textContent = '–£–¥–∞–ª–∏—Ç—å';

          // –≤—Å—Ç–∞–≤–ª—è–µ–º overlay –≤ –Ω–∞—á–∞–ª–æ, —á—Ç–æ–±—ã –æ–Ω –±—ã–ª "–ø–æ–¥–ª–æ–∂–∫–æ–π"
          paletteContainer.insertBefore(swipeOverlay, paletteContainer.firstChild);

          this.addSwipeHandlers(paletteContainer, paletteIndex);
        }


        palette.forEach((color, colorIndex) => {
          const colorPreview = document.createElement('div');
          colorPreview.className = 'color-preview';
          colorPreview.style.backgroundColor = color;
          colorPreview.title = `–ü–∞–ª–∏—Ç—Ä–∞ ${paletteIndex + 1}, –¶–≤–µ—Ç ${colorIndex + 1}: ${color}`;
          paletteContainer.appendChild(colorPreview);
        });

        previewContainer.appendChild(paletteContainer);
      });
    }


    addSwipeHandlers(element, paletteIndex) {
      let startX = 0;
      let currentX = 0;
      let isSwiping = false;

      const softThreshold = 60;   // ¬´–≤–∏–∑—É–∞–ª—å–Ω—ã–π —Å–≤–∞–π–ø¬ª (–ø–æ–¥–≤–∏–Ω—É—Ç—å, –Ω–æ –Ω–µ —É–¥–∞–ª–∏—Ç—å)
      const deleteThreshold = 200; // —è–≤–Ω—ã–π –¥–ª–∏–Ω–Ω—ã–π —Å–≤–∞–π–ø –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è

      const onTouchStart = (e) => {
        startX = e.touches[0].clientX;
        currentX = startX;
        isSwiping = true;
        element.classList.add('swiping');
        element.style.transition = 'none';
      };

      const onTouchMove = (e) => {
        if (!isSwiping) return;
        currentX = e.touches[0].clientX;
        const deltaX = currentX - startX;

        if (deltaX < 0) {
          element.style.transform = `translateX(${deltaX}px)`;
          element.style.opacity = Math.max(0.4, 1 + deltaX / deleteThreshold);
        }
      };

      const onTouchEnd = () => {
        if (!isSwiping) return;
        isSwiping = false;
        element.classList.remove('swiping');
        element.style.transition = 'transform 0.25s ease, opacity 0.25s ease';

        const deltaX = currentX - startX;

        if (deltaX < -deleteThreshold) {
          // –¥–ª–∏–Ω–Ω—ã–π –∏ —è–≤–Ω—ã–π —Å–≤–∞–π–ø ‚Üí —É–¥–∞–ª—è–µ–º
          this.deleteCustomPalette(paletteIndex);
        } else {
          // –∏–Ω–∞—á–µ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –Ω–∞–∑–∞–¥
          element.style.transform = '';
          element.style.opacity = '';
        }
      };

      element.addEventListener('touchstart', onTouchStart);
      element.addEventListener('touchmove', onTouchMove);
      element.addEventListener('touchend', onTouchEnd);
    }


    deleteCustomPalette(paletteIndex) {
      const paletteContainer = document.querySelector(`[data-palette-index="${paletteIndex}"]`);
      if (paletteContainer) {
        paletteContainer.classList.add('deleting');
        setTimeout(() => {
          paletteContainer.remove();
          THEMES_CUSTOM.splice(paletteIndex, 1);
          this.updateThemePreview();
        }, 300);
      }
    }

    calculateMaxHeight() {
      const viewportHeight = window.innerHeight;

      const root = document.documentElement;
      const styles = getComputedStyle(root);

      const cellHeight = parseFloat(styles.getPropertyValue('--cell')) || 56;
      const gapHeight  = parseFloat(styles.getPropertyValue('--gap')) || 6;

      const hud = document.querySelector('.hud');
      const hudHeight = hud ? hud.offsetHeight : 0;

      const game = document.querySelector('.game');
      const rowGap = game ? parseFloat(getComputedStyle(game).rowGap) || 0 : 0;

      const outerMargin = 5; // —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∑–∞–ø–∞—Å

      // –¥–æ—Å—Ç—É–ø–Ω–∞—è –≤—ã—Å–æ—Ç–∞ = —ç–∫—Ä–∞–Ω - hud - gap –º–µ–∂–¥—É hud –∏ board - –æ—Ç—Å—Ç—É–ø—ã
      const availableHeight = viewportHeight - hudHeight - rowGap - 2 * outerMargin;

      // —Ñ–æ—Ä–º—É–ª–∞: cell*N + gap*(N-1) <= availableHeight
      const maxCells = Math.floor((availableHeight + gapHeight) / (cellHeight + gapHeight));

      // –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–∏–∞–ø–∞–∑–æ–Ω (–Ω–∞–ø—Ä–∏–º–µ—Ä 8‚Äì20)
      return Math.max(8, Math.min(20, maxCells));
    }


      // === –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø–æ–ª—è —Å –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ –ø–∞—Ä–∞–º–∏ ===
      generateBoard() {
        const total = this.width * this.height;
        const flat = Array(total).fill(null);

        // –ö–æ—Ä—Ä–µ–∫—Ü–∏—è MIN_pair –Ω–∞ —Å–ª—É—á–∞–π, –µ—Å–ª–∏ –Ω–µ –ø–æ–º–µ—â–∞–µ—Ç—Å—è
        const maxPairsPossible = Math.floor(total / (2 * this.maxColors));
        const effectiveMinPair = Math.min(this.minPair, maxPairsPossible);
        if (effectiveMinPair !== this.minPair) {
          this.minPair = effectiveMinPair;
          CONFIG.minPair = effectiveMinPair;
        }

        // –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ –∏–Ω–¥–µ–∫—Å—ã –∏ –ø–µ—Ä–µ–º–µ—à–∏–≤–∞–µ–º –æ–¥–∏–Ω —Ä–∞–∑
        const indices = Array.from({ length: total }, (_, i) => i);
        for (let i = indices.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [indices[i], indices[j]] = [indices[j], indices[i]];
        }

        let pos = 0;

        // 1) –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–∞—Ä—ã –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ü–≤–µ—Ç–∞
        for (let color = 0; color < this.maxColors; color++) {
          for (let p = 0; p < effectiveMinPair; p++) {
            flat[indices[pos++]] = color;
            flat[indices[pos++]] = color;
          }
        }

        // 2) –æ—Å—Ç–∞–≤—à–∏–µ—Å—è –∫–ª–µ—Ç–∫–∏ ‚Äî —Å–ª—É—á–∞–π–Ω—ã–º–∏ –ø–∞—Ä–∞–º–∏
        while (pos < indices.length) {
          const color = Math.floor(Math.random() * this.maxColors);
          flat[indices[pos++]] = color;
          flat[indices[pos++]] = color;
        }

        // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ 2D
        const grid = [];
        for (let y = 0; y < this.height; y++) {
          grid[y] = [];
          for (let x = 0; x < this.width; x++) {
            grid[y][x] = flat[idx(x, y, this.width)];
          }
        }

        return grid;
      }


      #placeRandomPair(flat, color) {
        const a = this.#randomEmptyIndex(flat);
        flat[a] = color;
        const b = this.#randomEmptyIndex(flat);
        flat[b] = color;
      }
      #randomEmptyIndex(flat) {
        let i = Math.floor(Math.random() * flat.length);
        while (flat[i] !== null) i = Math.floor(Math.random() * flat.length);
        return i;
      }
      // === –û—Ç—Ä–∏—Å–æ–≤–∫–∞ ===

      mount(cell) {
      const boardEl = document.getElementById('board');
      boardEl.innerHTML = '';
      boardEl.style.setProperty('--width', this.width);
      boardEl.style.setProperty('--height', this.height);

      // –û—Ç–º–µ–Ω—è–µ–º –ø—Ä–µ–¥—ã–¥—É—â–µ–µ –∞–Ω–∏–º–∏—Ä–æ–≤–∞–Ω–∏–µ (–∏ timeouts, –Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π)
      if (this._revealTimer) {
        cancelAnimationFrame(this._revealTimer);
        this._revealTimer = null;
      }
      if (this._revealTimers && this._revealTimers.length) {
        for (const t of this._revealTimers) clearTimeout(t);
      }
      this._revealTimers = [];

      for (let y = 0; y < this.height; y++) {
        for (let x = 0; x < this.width; x++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.tabIndex = -1;
          cell.dataset.x = x;
          cell.dataset.y = y;

          const color = this.board[y][x];
          if (color !== null && color !== undefined) {
            // –ø–æ–∫–∞ –Ω–µ –∑–∞–¥–∞—ë–º CSS-–ø–µ—Ä–µ–º–µ–Ω–Ω—É—é --color ‚Äî –∫–ª–µ—Ç–∫–∞ –æ—Å—Ç–∞—ë—Ç—Å—è —Å–µ—Ä–æ–π,
            // –∏ —É –Ω–µ—ë data-activated = '0' => –ø–µ—Ä–µ—Ö–æ–¥—ã/–±–ª–∏–∫ –±—É–¥—É—Ç –æ—Ç–∫–ª—é—á–µ–Ω—ã –ø–æ CSS

            cell.classList.add('filled');
            cell.dataset.colorId = String(color);
            cell.dataset.activated = '0';
          } else {
            cell.dataset.activated = '0';

          }

          cell.addEventListener('click', (e) => this.onCellClick(e, x, y));
          cell.addEventListener('pointerdown', (e) => this.onPointerDown(e, x, y));

          boardEl.appendChild(cell);

        }
      }

      // –∑–∞–ø—É—Å–∫ ¬´–≤–∫–ª—é—á–µ–Ω–∏—è –ª–∞–º–ø–æ—á–µ–∫¬ª
      //this.runInitialReveal(2500);
              window.hideLoader(() => {
          this.runInitialReveal(2500);
        });

    }


    #applyColor(cell, colorId, instant = false) {
      const colorHex = this.theme[colorId % this.theme.length];
      // –æ–±—â–∞—è —á–∞—Å—Ç—å
      cell.classList.add('filled');
      cell.classList.remove('vanish');
      cell.dataset.colorId = String(colorId);

      if (instant) {
        // –º–≥–Ω–æ–≤–µ–Ω–Ω–æ: –≤—Ä–µ–º–µ–Ω–Ω–æ –æ—Ç–∫–ª—é—á–∞–µ–º inline transition –∏ —Å—Ä–∞–∑—É –ø—Ä–∏–º–µ–Ω—è–µ–º —Ü–≤–µ—Ç
        const prevTransition = cell.style.transition;
        cell.style.transition = 'none';
        cell.dataset.activated = '1';
        cell.style.setProperty('--color', colorHex);

        // —Ñ–æ—Ä—Å —Ä–µ—Ñ–ª–æ—É, –∑–∞—Ç–µ–º –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏–º transition
        void cell.offsetWidth;
        cell.style.transition = prevTransition;
      } else {
        // –æ–±—ã—á–Ω—ã–π (–∞–Ω–∏–º–∞—Ü–∏–æ–Ω–Ω—ã–π) –ø—É—Ç—å: —Å—Ç–∞–≤–∏–º activated, –∑–∞—Ç–µ–º –º–µ–Ω—è–µ–º —Ü–≤–µ—Ç
        // ‚Äî —ç—Ç–æ –∞–∫—Ç–∏–≤–∏—Ä—É–µ—Ç CSS-–ø–µ—Ä–µ—Ö–æ–¥—ã, –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–µ –≤ .cell.filled[data-activated="1"]
        cell.dataset.activated = '1';
        cell.style.setProperty('--color', colorHex);

      }
    }


    // –≤–µ—Ä–Ω—É—Ç—å –º–∞—Å—Å–∏–≤ —Ñ–∞–π–ª–æ–≤ –¥–ª—è —Ç–µ–∫—É—â–µ–π –∫–æ–º–Ω–∞—Ç—ã (–æ–¥–Ω–æ –∏–∑–º–µ—Ä–µ–Ω–∏–µ ‚Äî —Å–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤)
    getCurrentRoomImages() {
      const roomConfig = AVAILABLE_ROOM[this.currentRoom]; // <-- use this.currentRoom
      if (!roomConfig || !Array.isArray(roomConfig.themes) || roomConfig.themes.length === 0) {
        return { folder: '', files: [] };
      }

      const themes = roomConfig.themes;
      const idx = (this.pinnedPaletteIndex >= 0 && this.pinnedPaletteIndex < themes.length)
        ? this.pinnedPaletteIndex
        : Math.floor(Math.random() * themes.length);

      const selected = themes[idx] || [];
      // roomConfig.folder –æ–±—è–∑–∞–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å 'img' –∏–ª–∏ 'img2' –∏–ª–∏ –ª—é–±–æ–π –ø—É—Ç—å, –∫–æ—Ç–æ—Ä—ã–π –≤—ã –∏—Å–ø–æ–ª—å–∑—É–µ—Ç–µ
      return { folder: roomConfig.folder, files: Array.isArray(selected) ? selected.slice() : [] };
    }



    // –≤—ã–∑—ã–≤–∞–µ–º –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ –∏ –ø—Ä–∏ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–∏ —Ç–µ–º—ã/–≤–∫–ª—é—á–µ–Ω–∏–∏ —Ä–µ–∂–∏–º–æ–≤

    ensureImageModeLimits() {
      this.palette = this.getCurrentThemeColors();
      const roomData = this.getCurrentRoomImages();
      this.roomFolder = roomData.folder;
      this.roomImages = roomData.files;

      if (CONFIG.useImages && this.roomImages.length > 0) {
        const available = this.roomImages.length;
        if (CONFIG.maxColors > available) {
          CONFIG.maxColors = available;
          this.maxColors = available;
          const slider = document.getElementById('maxColors-slider');
          if (slider) {
            slider.value = available;
            document.getElementById('settings-maxColors').textContent = available;
          }
        } else {
          this.maxColors = Math.min(this.maxColors, CONFIG.maxColors);
        }
        this.useImages = true;
      } else {
        this.useImages = false;
        this.maxColors = Math.min(this.maxColors, this.palette.length);
      }
    }


    // –≥–ª–∞–≤–Ω—ã–π —Ö–µ–ª–ø–µ—Ä: –Ω–∞–∑–Ω–∞—á–∏—Ç—å background-image –¥–ª—è –æ–¥–Ω–æ–π .cell –Ω–∞ –æ—Å–Ω–æ–≤–µ data-color-id

applyImageBackgroundToCell(cell) {
  const id = Number(cell.dataset.colorId);

  if (!this.useImages || !Array.isArray(this.roomImages) || this.roomImages.length === 0) {
    cell.style.setProperty('--img-url', '');
    return;
  }

  const idx = Math.max(0, Math.min(id, this.roomImages.length - 1));
  const filename = this.roomImages[idx];
  const basePath = this.getImageBasePath();
  const key = `${basePath}/${filename}`;

  // –ë–µ—Ä—ë–º blobUrl –∏–∑ –∫—ç—à–∞
  let blobUrl = this.imageUrlCache.get(key);

  if (!blobUrl) {
    // –ø–æ–∫–∞ —Å—Ç–∞–≤–∏–º –ø—É—Å—Ç–æ–π —Ñ–æ–Ω
    cell.style.setProperty('--img-url', '');

    // —Ñ–æ–Ω–æ–≤–∞—è –ø–æ–¥–≥—Ä—É–∑–∫–∞
    this.preloadImages([filename]).then(() => {
      const readyUrl = this.imageUrlCache.get(key);
      if (readyUrl) {
        cell.style.setProperty('--img-url', `url("${readyUrl}")`);
      }
    });
    return;
  }

  cell.style.setProperty('--img-url', `url("${blobUrl}")`);
}









      runInitialReveal(totalMs = 2500, batchSize = 16, cell) {
        const cellsToReveal = [];
        for (let y = 0; y < this.height; y++) {
          for (let x = 0; x < this.width; x++) {
            const el = this.getCellEl(x, y);
            if (!el) continue;
            if (el.classList.contains('filled') && el.dataset.activated !== '1') {
              const colorId = Number(el.dataset.colorId);
              if (!Number.isNaN(colorId)) {
                cellsToReveal.push({ x, y, el, colorId, diag: x + y });
              }
            }
          }
        }
        if (cellsToReveal.length === 0) return;

        // —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ –¥–∏–∞–≥–æ–Ω–∞–ª—è–º
        cellsToReveal.sort((a, b) => a.diag - b.diag || a.x - b.x);

        // –æ—Ç–º–µ–Ω—è–µ–º —Å—Ç–∞—Ä—ã–π rAF
        if (this._revealTimer) {
          cancelAnimationFrame(this._revealTimer);
          this._revealTimer = null;
        }

        const lastIndex = cellsToReveal.length - 1;
        const startTime = performance.now();
        this._revealIndex = 0;

        const animate = (now) => {
          const elapsed = now - startTime;
          const progress = Math.min(elapsed / totalMs, 1);
          const targetIndex = Math.floor(progress * (lastIndex + 1));

          // –≤–º–µ—Å—Ç–æ —Ç–æ–≥–æ, —á—Ç–æ–±—ã –æ—Ç–∫—Ä—ã–≤–∞—Ç—å —Å—Ä–∞–∑—É –≤—Å–µ targetIndex,
          // –æ—Ç–∫—Ä–æ–µ–º —Ç–æ–ª—å–∫–æ batchSize –∑–∞ –∫–∞–¥—Ä
          let processed = 0;
          while (this._revealIndex < targetIndex && processed < batchSize) {
            const { el, colorId } = cellsToReveal[this._revealIndex];
            if (el.dataset.activated !== '1') {
              const colorHex = this.theme[colorId % this.theme.length];
              el.dataset.activated = '1';
              el.style.setProperty('--color', colorHex);

              // –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –∫–∞—Ä—Ç–∏–Ω–∫–∏, –µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω–æ
              this.applyImageBackgroundToCell(el);

            }
            this._revealIndex++;
            processed++;
          }

          if (progress < 1 || this._revealIndex < cellsToReveal.length) {
            this._revealTimer = requestAnimationFrame(animate);
          } else {
            this._revealTimer = null;
            this._revealIndex = 0;
          }
        };

        this._revealTimer = requestAnimationFrame(animate);
      }



      #clearCell(cell) {
        cell.removeAttribute('style');
        cell.classList.remove('filled', 'candidate', 'source');
        cell.classList.add('vanish');
        delete cell.dataset.colorId;
        cell.dataset.activated = '0';
        setTimeout(() => { cell.classList.remove('vanish'); }, 260);
      }


      getCellEl(x, y) {
        return document.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`);
      }
      // === –ü–æ–∏—Å–∫ –±–ª–∏–∂–∞–π—à–∏—Ö –ø–æ 4 –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è–º –¥–æ –ø–µ—Ä–≤–æ–π –ø—Ä–µ–≥—Ä–∞–¥—ã ===
      findNearestBlocksSameColor(x, y) {
        const color = this.board[y][x];
        if (color === null) return [];

        const dirs = [ [1,0], [-1,0], [0,1], [0,-1] ];
        const found = [];
        for (const [dx, dy] of dirs) {
          let cx = x + dx, cy = y + dy;
          while (cx >= 0 && cx < this.width && cy >= 0 && cy < this.height) {
            const c = this.board[cy][cx];
            if (c !== null) { 
              if (c === color) found.push({ x: cx, y: cy });
              break;
            }
            cx += dx; cy += dy;
          }
        }
        return found; // –º–∞—Å—Å–∏–≤ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤
      }
      // === Drag & Move Mechanics ===
      onPointerDown(e, x, y) {
        // –ï—Å–ª–∏ –µ—Å—Ç—å –ø–æ–¥—Å–∫–∞–∑–∫–∞ ‚Äî –∑–∞–ø–æ–º–Ω–∏–º –µ—ë –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è –∏ —Å–±—Ä–æ—Å–∏–º –≤–∏–∑—É–∞–ª—å–Ω–æ
        let hintForThisAction = null;
        let isHintedStart = false;
        if (this.superHint) {
          isHintedStart = (this.superHint.a.x === x && this.superHint.a.y === y) || (this.superHint.b.x === x && this.superHint.b.y === y);
          hintForThisAction = this.superHint;
          // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –ø–æ–¥—Å–∫–∞–∑–∫—É –∏ –∑–∞–ø—É—Å–∫–∞–µ–º –∫—É–ª–¥–∞—É–Ω, –Ω–æ –Ω–µ –ø–µ—Ä–µ—Ö–≤–∞—Ç—ã–≤–∞–µ–º –¥–µ–π—Å—Ç–≤–∏—è
          this.clearSuperHint(false);
          /*this.startHintCooldown();*/ //—Ä–∞—Å—Ö–æ–¥ –ø–æ–¥—Å–∫–∞–∑–∫–∏ –ø—Ä–∏ –∫–ª–∏–∫–µ
        }
        if (this.state.locked) return;
        const color = this.board[y][x];
        if (color === null) return;
        e.preventDefault();
        // –ü—Ä–µ–¥–¥–≤–∏–∂–µ–Ω–∏–µ: –ø–µ—Ä–≤–∏—á–Ω—ã–π –ø–æ–∏—Å–∫ –ø–∞—Ä –Ω–∞ –∏—Å—Ö–æ–¥–Ω–æ–π –ø–æ–∑–∏—Ü–∏–∏
        const preCandidates = this.findNearestBlocksSameColor(x, y);
        if (preCandidates.length === 1) {
          const { x: tx, y: ty } = preCandidates[0];
          // –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –≤—Å–µ –±–ª–æ–∫–∏ –ø–µ—Ä–µ–¥ —É–¥–∞–ª–µ–Ω–∏–µ–º –ø–∞—Ä—ã
          this.centerAllBlocks();
          this.removePair(x, y, tx, ty);
          return;
        }
        if (preCandidates.length > 1) {
          // –ï—Å–ª–∏ —Å—Ç–∞—Ä—Ç–æ–≤–∞–ª–∏ –ø–æ –ø–æ–¥—Å–≤–µ—á–µ–Ω–Ω–æ–º—É –±–ª–æ–∫—É ‚Äî –æ–±–æ–π—Ç–∏ —Ä–µ–∂–∏–º –≤—ã–±–æ—Ä–∞ –∏ —É–¥–∞–ª–∏—Ç—å —Å—É–ø–µ—Ä-–ø–∞—Ä—É
          if (hintForThisAction && isHintedStart) {
            const other = (hintForThisAction.a.x === x && hintForThisAction.a.y === y) ? hintForThisAction.b : hintForThisAction.a;
            // –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –≤—Å–µ –±–ª–æ–∫–∏ –ø–µ—Ä–µ–¥ —É–¥–∞–ª–µ–Ω–∏–µ–º —Å—É–ø–µ—Ä-–ø–∞—Ä—ã
            //this.centerAllBlocks(); –ò–ó–ë–´–¢–û–ß–ù–û 1509
            this.removePair(x, y, other.x, other.y);
            return;
          }
          const boardEl = document.getElementById('board');
          // –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –≤—Å–µ –±–ª–æ–∫–∏ –ø–µ—Ä–µ–¥ –≤—Ö–æ–¥–æ–º –≤ —Ä–µ–∂–∏–º –≤—ã–±–æ—Ä–∞
          //this.centerAllBlocks(); –ò–ó–ë–´–¢–û–ß–ù–û 1509
          this.enterSelectionMode(x, y, preCandidates);
          boardEl.classList.add('dimmed');
          return;
        }
        this.drag.active = true;
        this.drag.startX = x;
        this.drag.startY = y;
        this.drag.axis = null;
        this.drag.startClientX = e.clientX;
        this.drag.startClientY = e.clientY;
        this.drag.stepPx = this.#getStepPixels();
        this.drag.previewCells = [];
        this.drag.previewOffset = 0;
        // –∑–∞–ø–æ–º–Ω–∏–º –ø–æ–¥—Å–∫–∞–∑–∫—É –¥–ª—è –≤–æ–∑–º–æ–∂–Ω–æ–π –ª–æ–≥–∏–∫–∏ –ø–æ—Å–ª–µ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è
        this.drag.hintForThisAction = hintForThisAction;
        this.drag.startedOnHinted = !!isHintedStart;
        this.highlightCross(x, y);
        this._bindPointerListeners();
      }

      _bindPointerListeners() {
        this._onPointerMove = this._onPointerMove || ((ev) => this.onPointerMove(ev));
        this._onPointerUp = this._onPointerUp || ((ev) => this.onPointerUp(ev));
        window.addEventListener('pointermove', this._onPointerMove);
        window.addEventListener('pointerup', this._onPointerUp, { once: true });
        window.addEventListener('pointercancel', this._onPointerUp, { once: true });
      }

      _unbindPointerListeners() {
        window.removeEventListener('pointermove', this._onPointerMove);
      }

      onPointerMove(e) {
        if (!this.drag.active) return;
        const dx = e.clientX - this.drag.startClientX;
        const dy = e.clientY - this.drag.startClientY;
        if (this.drag.axis === null) {
          if (Math.abs(dx) < this.drag.thresholdPx && Math.abs(dy) < this.drag.thresholdPx) return;
          this.drag.axis = Math.abs(dx) >= Math.abs(dy) ? 'x' : 'y';
        }
        const axis = this.drag.axis;
        const stepPx = this.drag.stepPx;
        const delta = axis === 'x' ? dx : dy;
        if (delta === 0) { this.clearPreviewTransforms(); return; }
        const sign = Math.sign(delta);
        // –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –¥–æ–ø—É—Å—Ç–∏–º–æ–µ —á–∏—Å–ª–æ —à–∞–≥–æ–≤ (–≤ –∫–ª–µ—Ç–∫–∞—Ö) –ø–æ —Ç–µ–∫—É—â–µ–º—É –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—é
        const allowedSteps = Math.abs(this.computeAllowedShift(this.drag.startX, this.drag.startY, axis, sign * 999));
        if (allowedSteps === 0) { this.clearPreviewTransforms(); return; }
        const desiredStepsFloat = delta / stepPx;
        const clampedStepsFloat = Math.max(-allowedSteps, Math.min(allowedSteps, desiredStepsFloat));
        const offsetPx = clampedStepsFloat * stepPx;
        const { from, to } = this.getChainRange(this.drag.startX, this.drag.startY, axis, sign);
        this.applyPreviewTransforms(axis, this.drag.startX, this.drag.startY, from, to, offsetPx);
        // –æ–±–Ω–æ–≤–∏—Ç—å –ø–æ–¥—Å–≤–µ—Ç–∫—É —Ç–µ–∫—É—â–µ–≥–æ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è –ø–æ –±–ª–∏–∂–∞–π—à–µ–π –∫–ª–µ—Ç–∫–µ –∫ –ø–æ–ª–æ–∂–µ–Ω–∏—é –∫—É—Ä—Å–æ—Ä–∞
        const roundedSteps = Math.round(clampedStepsFloat);
        const hx = axis === 'x' ? Math.max(0, Math.min(this.width - 1, this.drag.startX + roundedSteps)) : this.drag.startX;
        const hy = axis === 'y' ? Math.max(0, Math.min(this.height - 1, this.drag.startY + roundedSteps)) : this.drag.startY;
        this.highlightCross(hx, hy);
      }

      onPointerUp(e) {
        if (!this.drag.active) return;
        const dx = e.clientX - this.drag.startClientX;
        const dy = e.clientY - this.drag.startClientY;
        const axis = this.drag.axis;
        this.drag.active = false;
        this._unbindPointerListeners();
        this.clearHighlightCross();
        const stepPx = this.drag.stepPx;

        if (!axis) {
          // treat as click - —Ü–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –±–ª–æ–∫–∏ –ø—Ä–∏ –∫–ª–∏–∫–µ
          //this.centerAllBlocks(); –ò–ó–ë–´–¢–û–ß–ù–û ?? 1509
          return;
        }
        const desiredSteps = axis === 'x' ? Math.round(dx / stepPx) : Math.round(dy / stepPx);
        if (desiredSteps === 0) {
          // no move - —Ü–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –±–ª–æ–∫–∏ –ø—Ä–∏ –∫–ª–∏–∫–µ –±–µ–∑ –¥–≤–∏–∂–µ–Ω–∏—è
          this.centerAllBlocks();
          return;
        }
        const actualSteps = this.computeAllowedShift(this.drag.startX, this.drag.startY, axis, desiredSteps);
        if (actualSteps === 0) return;
        const sign = Math.sign(actualSteps);
        const range = this.getChainRange(this.drag.startX, this.drag.startY, axis, sign);
        const snapshot = this.captureChainSnapshot(this.drag.startX, this.drag.startY, axis, range.from, range.to);

        const { x: nx, y: ny } = this.moveChain(this.drag.startX, this.drag.startY, axis, actualSteps);
        this._blockClicksUntil = performance.now() + 200;
        // –Ω–æ–≤–æ–µ –ø—Ä–∞–≤–∏–ª–æ: –µ—Å–ª–∏ –ø–∞—Ä –Ω–µ—Ç, –æ—Ç–∫–∞—Ç–∏—Ç—å –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ
        const candidates = this.findNearestBlocksSameColor(nx, ny);
        const boardEl = document.getElementById('board');

        if (candidates.length === 0) {
          // –û—Ç–∫–∞—Ç—ã–≤–∞–µ–º –≤–∏–∑—É–∞–ª—å–Ω–æ (—É–±–∏—Ä–∞–µ–º preview transform), –∏ –≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º snapshot.
          // clearPreviewTransforms –Ω—É–∂–Ω–æ –≤—ã–∑–≤–∞—Ç—å –¥–æ restore, —á—Ç–æ–±—ã —è—á–µ–π–∫–∏ –Ω–µ –æ—Å—Ç–∞–≤–∞–ª–∏—Å—å —Å translate.
          this.clearPreviewTransforms();
          // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Ü–µ–ø–æ—á–∫–∏. (–í–∞–∂–Ω–æ: captureChainSnapshot –Ω–µ –¥–æ–ª–∂–µ–Ω –≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—Ç—å —è—á–µ–π–∫–∏, –∫–æ—Ç–æ—Ä—ã–µ
          // –Ω–∞–º–µ—Ä–µ–Ω–Ω–æ –¥–æ–ª–∂–Ω—ã –∏—Å—á–µ–∑–Ω—É—Ç—å ‚Äî –Ω–æ —Ç—É—Ç –Ω–µ—Ç –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤, —Ç–∞–∫ —á—Ç–æ –æ–±—ã—á–Ω—ã–π –æ—Ç–∫–∞—Ç –∫–æ—Ä—Ä–µ–∫—Ç–µ–Ω.)
          this.restoreChainSnapshot(snapshot, axis, actualSteps);
          // –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –≤—Å–µ –±–ª–æ–∫–∏ –ø–æ—Å–ª–µ –æ—Ç–∫–∞—Ç–∞
          //this.centerAllBlocks(); –ò–ó–ë–´–¢–û–ß–ù–û ?? 1509
          return;
        }
        // –ï—Å–ª–∏ –Ω–∞—à–ª–∏ –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤ ‚Äî –Ω–µ –æ—Ç–∫–∞—Ç—ã–≤–∞–µ–º transform: –ø—É—Å—Ç—å –±–ª–æ–∫ –æ—Å—Ç–∞–Ω–µ—Ç—Å—è –≤–∏–∑—É–∞–ª—å–Ω–æ –Ω–∞ –º–µ—Å—Ç–µ –æ—Ç–ø—É—Å–∫–∞–Ω–∏—è.
        // –ó–∞—Ç–µ–º —É–¥–∞–ª—è–µ–º –ø–∞—Ä—É –∏ –ø–ª–∞–≤–Ω–æ —É–±–∏—Ä–∞–µ–º –∏—Ö –≤–∏–∑—É–∞–ª—å–Ω–æ (fade-out).
        const scheduleClearPreview = () => {
          // –Ω–µ–±–æ–ª—å—à–æ–π —Ç–∞–π–º–∞—É—Ç ‚Äî –¥–∞—ë–º –≤—Ä–µ–º—è –∞–Ω–∏–º–∞—Ü–∏–∏ fade-out –≤—ã–ø–æ–ª–Ω–∏—Ç—å—Å—è, –∑–∞—Ç–µ–º —á–∏—Å—Ç–∏–º preview transforms.
          setTimeout(() => {
            this.clearPreviewTransforms();
            // —Ç–∞–∫–∂–µ –º–æ–∂–Ω–æ –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –æ—á–∏—Å—Ç–∏—Ç—å –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ –∫–ª–∞—Å—Å—ã
            if (boardEl) boardEl.classList.remove('noreturn');
            // –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –≤—Å–µ –±–ª–æ–∫–∏ –ø–æ—Å–ª–µ –æ—á–∏—Å—Ç–∫–∏ preview transforms
            //this.centerAllBlocks();
          }, 0);
        };
        // --- 1 –∫–∞–Ω–¥–∏–¥–∞—Ç: —É–¥–∞–ª—è–µ–º –Ω–∞–ø—Ä—è–º—É—é ---
        if (candidates.length === 1) {
          const { x: tx, y: ty } = candidates[0];
          // –í–∏–∑—É–∞–ª—å–Ω–æ: –æ—Ç–∫–ª—é—á–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é –≤–æ–∑–≤—Ä–∞—â–µ–Ω–∏—è (—á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ —ç—Ñ—Ñ–µ–∫—Ç–∞ "–æ—Ç–∫–∞—Ç–∞")
          if (boardEl) boardEl.classList.add('noreturn');

          this.removePair(nx, ny, tx, ty);
          scheduleClearPreview();
          // –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –≤—Å–µ –±–ª–æ–∫–∏ –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–≥–æ —É–¥–∞–ª–µ–Ω–∏—è
          //setTimeout(() => this.centerAllBlocks(), 100); –ò–ó–ë–´–¢–û–ß–ù–û ?? 1509
          return;
        }
        // --- –Ω–µ—Å–∫–æ–ª—å–∫–æ –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤ ‚Äî –µ—Å–ª–∏ —Ç—è–Ω—É–ª–∏, –Ω–∞—á–∞–≤ —Å –ø–æ–¥—Å–∫–∞–∑–∞–Ω–Ω–æ–≥–æ –±–ª–æ–∫–∞, —É–¥–∞–ª–∏—Ç—å —Å—É–ø–µ—Ä-–ø–∞—Ä—É ---
        if (this.drag.hintForThisAction && this.drag.startedOnHinted) {
          const { a, b } = this.drag.hintForThisAction;
          const isStartA = a.x === this.drag.startX && a.y === this.drag.startY;
          const partner = isStartA ? b : a;
          // —É—á—Ç—ë–º, —á—Ç–æ –ø–∞—Ä—Ç–Ω—ë—Ä –º–æ–≥ –±—ã—Ç—å —á–∞—Å—Ç—å—é —Å–¥–≤–∏–≥–∞–µ–º–æ–π —Ü–µ–ø–æ—á–∫–∏ –∏ —Å–º–µ—Å—Ç–∏–ª—Å—è
          let px = partner.x, py = partner.y;
          if (axis === 'x' && partner.y === this.drag.startY) {
            const rng = this.getChainRange(this.drag.startX, this.drag.startY, axis, sign);
            if (partner.x >= rng.from && partner.x <= rng.to) px = partner.x + actualSteps;
          }
          if (axis === 'y' && partner.x === this.drag.startX) {
            const rng = this.getChainRange(this.drag.startX, this.drag.startY, axis, sign);
            if (partner.y >= rng.from && partner.y <= rng.to) py = partner.y + actualSteps;
          }

          if (boardEl) boardEl.classList.add('noreturn');

          this.removePair(nx, ny, px, py);
          scheduleClearPreview();
          // –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –≤—Å–µ –±–ª–æ–∫–∏ –ø–æ—Å–ª–µ —É–¥–∞–ª–µ–Ω–∏—è —Å—É–ø–µ—Ä-–ø–∞—Ä—ã
          //setTimeout(() => this.centerAllBlocks(), 100); –ò–ó–ë–´–¢–û–ß–ù–û 1509
          return;
        }
        // –∏–Ω–∞—á–µ ‚Äî —Ä–µ–∂–∏–º –≤—ã–±–æ—Ä–∞ (selection mode)
        this.enterSelectionMode(nx, ny, candidates);
        if (boardEl) boardEl.classList.add('dimmed');
        //this.centerAllBlocks(); –ò–ó–ë–´–¢–û–ß–ù–û
        // –ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: –≤ —Ä–µ–∂–∏–º–µ –≤—ã–±–æ—Ä–∞ –º—ã –æ—Å—Ç–∞–≤–ª—è–µ–º preview-transform, —á—Ç–æ–±—ã –∏–≥—Ä–æ–∫ –≤–∏–¥–µ–ª, –≥–¥–µ –æ–Ω –æ—Ç–ø—É—Å—Ç–∏–ª –±–ª–æ–∫.
      }



      #getStepPixels() {
        const rootStyles = getComputedStyle(document.documentElement);
        const cell = parseFloat(rootStyles.getPropertyValue('--cell')) || 56;
        const gap = parseFloat(rootStyles.getPropertyValue('--gap')) || 6;
        return cell + gap;
      }
      // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏—è –≤—Å–µ—Ö –±–ª–æ–∫–æ–≤ –Ω–∞ –∏–≥—Ä–æ–≤–æ–º –ø–æ–ª–µ
      centerAllBlocks() {
        for (let y = 0; y < this.height; y++) {
          for (let x = 0; x < this.width; x++) {
            const cell = this.getCellEl(x, y);
            if (cell) {
              // –£–±–∏—Ä–∞–µ–º –≤—Å–µ transform —Å—Ç–∏–ª–∏, —á—Ç–æ–±—ã –±–ª–æ–∫–∏ –≤–µ—Ä–Ω—É–ª–∏—Å—å –≤ –∏—Å—Ö–æ–¥–Ω–æ–µ –ø–æ–ª–æ–∂–µ–Ω–∏–µ
              cell.style.transform = '';
              cell.classList.remove('dragging');
            }
          }
        }
      }

      computeAllowedShift(x0, y0, axis, desiredSteps) {
        const sign = Math.sign(desiredSteps);
        if (sign === 0) return 0;
        const limit = Math.abs(desiredSteps);
        if (axis === 'x') {
          const y = y0;
          if (sign > 0) {
            let chainEnd = x0;
            while (chainEnd + 1 < this.width && this.board[y][chainEnd + 1] !== null) chainEnd++;
            let empty = 0; let i = chainEnd + 1;
            while (i < this.width && this.board[y][i] === null) { empty++; i++; }
            return Math.min(limit, empty) * sign;
          } else {
            let chainStart = x0;
            while (chainStart - 1 >= 0 && this.board[y][chainStart - 1] !== null) chainStart--;
            let empty = 0; let i = chainStart - 1;
            while (i >= 0 && this.board[y][i] === null) { empty++; i--; }
            return Math.min(limit, empty) * sign;
          }
        } else {
          const x = x0;
          if (sign > 0) {
            let chainEnd = y0;
            while (chainEnd + 1 < this.height && this.board[chainEnd + 1][x] !== null) chainEnd++;
            let empty = 0; let i = chainEnd + 1;
            while (i < this.height && this.board[i][x] === null) { empty++; i++; }
            return Math.min(limit, empty) * sign;
          } else {
            let chainStart = y0;
            while (chainStart - 1 >= 0 && this.board[chainStart - 1][x] !== null) chainStart--;
            let empty = 0; let i = chainStart - 1;
            while (i >= 0 && this.board[i][x] === null) { empty++; i--; }
            return Math.min(limit, empty) * sign;
          }
        }
      }

      getChainRange(x0, y0, axis, sign) {
        if (axis === 'x') {
          const y = y0;
          if (sign > 0) {
            let end = x0;
            while (end + 1 < this.width && this.board[y][end + 1] !== null) end++;
            return { from: x0, to: end };
          } else {
            let start = x0;
            while (start - 1 >= 0 && this.board[y][start - 1] !== null) start--;
            return { from: start, to: x0 };
          }
        } else {
          const x = x0;
          if (sign > 0) {
            let end = y0;
            while (end + 1 < this.height && this.board[end + 1][x] !== null) end++;
            return { from: y0, to: end };
          } else {
            let start = y0;
            while (start - 1 >= 0 && this.board[start - 1][x] !== null) start--;
            return { from: start, to: y0 };
          }
        }
      }

      captureChainSnapshot(x0, y0, axis, from, to) {
        const items = [];
        if (axis === 'x') {
          const y = y0;
          for (let x = from; x <= to; x++) {
            items.push({ x, y, color: this.board[y][x] });
          }
        } else {
          const x = x0;
          for (let y = from; y <= to; y++) {
            items.push({ x, y, color: this.board[y][x] });
          }
        }
        return { axis, items };
      }

      restoreChainSnapshot(snapshot, axis, steps) {
        const sign = Math.sign(steps);
        if (snapshot.axis !== axis) return;
        for (const it of snapshot.items) {
          const dx = axis === 'x' ? it.x + steps : it.x;
          const dy = axis === 'y' ? it.y + steps : it.y;
          if (dy >= 0 && dy < this.height && dx >= 0 && dx < this.width) {
            this.board[dy][dx] = null;
          }
        }
        for (const it of snapshot.items) {
          this.board[it.y][it.x] = it.color;
        }
        if (axis === 'x') this.redrawRow(snapshot.items[0].y);
        else this.redrawColumn(snapshot.items[0].x);
      }

      applyPreviewTransforms(axis, x0, y0, from, to, offsetPx) {
        this.clearPreviewTransforms();
        this.drag.previewCells = [];
        if (axis === 'x') {
          const y = y0;
          for (let x = from; x <= to; x++) {
            const el = this.getCellEl(x, y);
            if (el) {
              el.style.transform = `translate3d(${offsetPx}px, 0, 0)`;
              el.classList.add('dragging');
              this.drag.previewCells.push(el);
            }
          }
        } else {
          const x = x0;
          for (let y = from; y <= to; y++) {
            const el = this.getCellEl(x, y);
            if (el) {
              el.style.transform = `translate3d(0, ${offsetPx}px, 0)`;
              el.classList.add('dragging');
              this.drag.previewCells.push(el);
            }
          }
        }
      }

      clearPreviewTransforms() {
        if (!this.drag.previewCells) return;
        for (const el of this.drag.previewCells) {
          el.style.transform = '';
          el.classList.remove('dragging');
        }
        this.drag.previewCells = [];
        //this.centerAllBlocks(); –ò–ó–ë–´–¢–û–ß–ù–û ?? 1509
      }

      highlightCross(x0, y0) {
        // –æ–±–Ω–æ–≤–∏—Ç—å –ø–æ–¥—Å–≤–µ—Ç–∫—É –Ω–∞ –Ω–æ–≤—É—é –ø–æ–∑–∏—Ü–∏—é
        if (this._hlPrev) this.clearHighlightCross();
        this._hlPrev = { x: x0, y: y0 };
        for (let x = 0; x < this.width; x++) this.getCellEl(x, y0)?.classList.add('row-hl');
        for (let y = 0; y < this.height; y++) this.getCellEl(x0, y)?.classList.add('col-hl');
      }

      clearHighlightCross() {
        const all = document.querySelectorAll('.cell.row-hl, .cell.col-hl');
        all.forEach(el => el.classList.remove('row-hl', 'col-hl'));
        this._hlPrev = null;
      }


      moveChain(x0, y0, axis, steps) {
        const sign = Math.sign(steps);
        if (sign === 0) return { x: x0, y: y0 };

        const changed = []; // —Å–ø–∏—Å–æ–∫ –∏–∑–º–µ–Ω—ë–Ω–Ω—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç

        if (axis === 'x') {
          const y = y0;
          if (sign > 0) {
            let chainEnd = x0;
            while (chainEnd + 1 < this.width && this.board[y][chainEnd + 1] !== null) chainEnd++;
            for (let x = chainEnd; x >= x0; x--) {
              this.board[y][x + steps] = this.board[y][x];
              this.board[y][x] = null;
              changed.push([x, y], [x + steps, y]);
            }
          } else {
            let chainStart = x0;
            while (chainStart - 1 >= 0 && this.board[y][chainStart - 1] !== null) chainStart--;
            for (let x = chainStart; x <= x0; x++) {
              this.board[y][x + steps] = this.board[y][x];
              this.board[y][x] = null;
              changed.push([x, y], [x + steps, y]);
            }
          }
          // —Ç–æ—á–µ—á–Ω–∞—è –ø–µ—Ä–µ—Ä–∏—Å–æ–≤–∫–∞
          changed.forEach(([cx, cy]) => this.updateCell(cx, cy));
          return { x: x0 + steps, y: y0 };
        } else {
          const x = x0;
          if (sign > 0) {
            let chainEnd = y0;
            while (chainEnd + 1 < this.height && this.board[chainEnd + 1][x] !== null) chainEnd++;
            for (let y = chainEnd; y >= y0; y--) {
              this.board[y + steps][x] = this.board[y][x];
              this.board[y][x] = null;
              changed.push([x, y], [x, y + steps]);
            }
          } else {
            let chainStart = y0;
            while (chainStart - 1 >= 0 && this.board[chainStart - 1][x] !== null) chainStart--;
            for (let y = chainStart; y <= y0; y++) {
              this.board[y + steps][x] = this.board[y][x];
              this.board[y][x] = null;
              changed.push([x, y], [x, y + steps]);
            }
          }
          // —Ç–æ—á–µ—á–Ω–∞—è –ø–µ—Ä–µ—Ä–∏—Å–æ–≤–∫–∞
          changed.forEach(([cx, cy]) => this.updateCell(cx, cy));
          return { x: x0, y: y0 + steps };
        }
      }



      updateCell(x, y) {
        const cell = this.getCellEl(x, y);
        if (!cell) return;

        const color = this.board[y][x];
        if (color !== null) {
          this.#applyColor(cell, color, true);
          this.applyImageBackgroundToCell(cell);
        } else {
          this.#clearCellImmediate(cell);
        }
      }

      redrawRow(y) {
        for (let x = 0; x < this.width; x++) {
          this.updateCell(x, y);
        }
      }

      redrawColumn(x) {
        for (let y = 0; y < this.height; y++) {
          this.updateCell(x, y);
        }
      }


      #clearCellImmediate(cell) {
        cell.removeAttribute('style');
        cell.classList.remove('filled', 'candidate', 'source', 'vanish');
      }

      redrawAll() {
        for (let y = 0; y < this.height; y++) this.redrawRow(y);
      }

      evaluateAfterMove(x, y) {
        const candidates = this.findNearestBlocksSameColor(x, y);
        if (candidates.length === 1) {
          const { x: tx, y: ty } = candidates[0];
          this.removePair(x, y, tx, ty);
          return;
        }
        if (candidates.length > 1) {
          const boardEl = document.getElementById('board');
          this.enterSelectionMode(x, y, candidates);
          boardEl.classList.add('dimmed');
        }
      }
      // === –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–ª–∏–∫–∞ –ø–æ –∫–ª–µ—Ç–∫–µ ===
      onCellClick(e, x, y) {
        const boardEl = document.getElementById('board');
        const cellEl = e.currentTarget;
        if (performance.now() < this._blockClicksUntil) return;
        const color = this.board[y][x];
        if (color === null) return; 
        // –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –≤—Å–µ –±–ª–æ–∫–∏ –ø—Ä–∏ –∫–ª–∏–∫–µ (–Ω–∞ —Å–ª—É—á–∞–π –µ—Å–ª–∏ –æ–Ω–∏ –±—ã–ª–∏ —Å–ª–µ–≥–∫–∞ —Å–¥–≤–∏–Ω—É—Ç—ã)
        //this.centerAllBlocks(); –ò–ó–ë–´–¢–û–ß–ù–û ?? 1509
        // –ï—Å–ª–∏ –µ—Å—Ç—å –ø–æ–¥—Å–∫–∞–∑–∫–∞ ‚Äî –º—è–≥–∫–æ —Å–±—Ä–∞—Å—ã–≤–∞–µ–º (–∏ –∑–∞–ø—É—Å–∫–∞–µ–º –∫—É–ª–¥–∞—É–Ω), –Ω–æ –Ω–µ –ø–µ—Ä–µ—Ö–≤–∞—Ç—ã–≤–∞–µ–º –¥–µ–π—Å—Ç–≤–∏–µ
        if (this.superHint) { this.clearSuperHint(false); /*this.startHintCooldown(); —Ä–∞—Å—Ö–æ–¥ –ø–æ–¥—Å–∫–∞–∑–∫–∏ –ø—Ä–∏ –∫–ª–∏–∫–µ*/ }
        // –ï—Å–ª–∏ –∂–¥—ë–º –≤—ã–±–æ—Ä–∞ —Å—Ä–µ–¥–∏ –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤ ‚Äî –ø—Ä–∏–Ω–∏–º–∞–µ–º –∫–ª–∏–∫–∏ —Ç–æ–ª—å–∫–æ –ø–æ –Ω–∏–º
        if (this.state.locked) {
          const isCandidate = cellEl.classList.contains('candidate');
          if (!isCandidate) return; 
          // –∏—Å–ø–æ–ª–Ω—è–µ–º —É–¥–∞–ª–µ–Ω–∏–µ –ø–∞—Ä—ã: source + –≤—ã–±—Ä–∞–Ω–Ω—ã–π
          const s = this.state.source;
          this.removePair(s.x, s.y, x, y);
          this.exitSelectionMode();
          return;
        }
        // –ò–Ω–∞—á–µ: –æ–±—ã—á–Ω—ã–π –∫–ª–∏–∫ ‚Äî –ø–æ–∏—Å–∫ –±–ª–∏–∂–∞–π—à–∏—Ö —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π
        const candidates = this.findNearestBlocksSameColor(x, y);
        if (candidates.length === 0) {
          // –ü–æ–¥—Å–≤–µ—Ç–∏—Ç—å –≤—Å–µ –±–ª–æ–∫–∏ —Ç–æ–≥–æ –∂–µ —Ü–≤–µ—Ç–∞ –º—è–≥–∫–∏–º –ø—É–ª—å—Å–æ–º –Ω–∞ 1 —Å–µ–∫—É–Ω–¥—É
          this.pulseSameColor(x, y);
          // –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –≤—Å–µ –±–ª–æ–∫–∏ –ø—Ä–∏ –ø—É–ª—å—Å–∞—Ü–∏–∏ (–Ω–µ—Ç –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤)
          //setTimeout(() => this.centerAllBlocks(), 100); –ò–ó–ë–´–¢–û–ß–ù–û ?? 1509
          return;
        }
        if (candidates.length === 1) {
          const { x: tx, y: ty } = candidates[0];
          this.removePair(x, y, tx, ty);
          return;
        }
        // –ù–µ—Å–∫–æ–ª—å–∫–æ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π ‚Äî –µ—Å–ª–∏ –∫–ª–∏–∫–Ω—É–ª–∏ –ø–æ –±–ª–æ–∫—É, –∫–æ—Ç–æ—Ä—ã–π –±—ã–ª –≤ –ø–æ–¥—Å–∫–∞–∑–∫–µ (–∏ –º—ã –µ—ë —Ç–æ–ª—å–∫–æ —á—Ç–æ —Å–±—Ä–æ—Å–∏–ª–∏), —É–¥–∞–ª–∏—Ç—å —Å—É–ø–µ—Ä-–ø–∞—Ä—É
        if (!this.superHint && this._hintCooldownUntil > performance.now()) {
          // –º—ã –∑–Ω–∞–µ–º, —á—Ç–æ –ø–æ–¥—Å–∫–∞–∑–∫–∞ —Ç–æ–ª—å–∫–æ —á—Ç–æ –±—ã–ª–∞ –∞–∫—Ç–∏–≤–Ω–∞; –ø—Ä–æ–≤–µ—Ä–∏–º, –±—ã–ª–æ –ª–∏ –Ω–∞—á–∞–ª–æ –Ω–∞ –æ–¥–Ω–æ–º –∏–∑ –µ—ë –±–ª–æ–∫–æ–≤
          // –∫ —Å–æ–∂–∞–ª–µ–Ω–∏—é, –∫ —ç—Ç–æ–º—É –º–æ–º–µ–Ω—Ç—É –º—ã –Ω–µ –∑–Ω–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â—É—é –ø–∞—Ä—É, –ø–æ—ç—Ç–æ–º—É —ç—Ç–æ—Ç –ø—É—Ç—å –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è –≤ onPointerDown
        }
        // –û–±—ã—á–Ω—ã–π —Ä–µ–∂–∏–º –≤—ã–±–æ—Ä–∞
        this.enterSelectionMode(x, y, candidates);
        boardEl.classList.add('dimmed');
      }


      pulseSameColor(x0, y0) {
        const colorId = this.board[y0][x0];
        if (colorId === null) return;

        const toPulse = [];
        for (let y = 0; y < this.height; y++) {
          for (let x = 0; x < this.width; x++) {
            if (this.board[y][x] === colorId) {
              const el = this.getCellEl(x, y);
              if (el && el.classList.contains('filled')) {
                toPulse.push(el);
              }
            }
          }
        }
        if (toPulse.length === 0) return;

        // --- –î–æ–±–∞–≤–ª—è–µ–º –∫–ª–∞—Å—Å —Å—Ä–∞–∑—É –≤—Å–µ–º —ç–ª–µ–º–µ–Ω—Ç–∞–º ---
        toPulse.forEach(el => el.classList.add('pulse-same'));

        // --- –£–±–∏—Ä–∞–µ–º –∫–ª–∞—Å—Å —á–µ—Ä–µ–∑ 1 —Å–µ–∫ ---
        setTimeout(() => {
          toPulse.forEach(el => el.classList.remove('pulse-same'));
        }, 1500);
      }



      enterSelectionMode(x, y, candidates) {
        this.state.locked = true;
        this.state.source = { x, y, color: this.board[y][x] };
        this.state.candidates = candidates;
        // –≤–∏–∑—É–∞–ª—å–Ω–∞—è –ø–æ–¥—Å–≤–µ—Ç–∫–∞
        const srcEl = this.getCellEl(x, y);
        srcEl.classList.add('source');
        for (const {x: cx, y: cy} of candidates) {
          const el = this.getCellEl(cx, cy);
          el.classList.add('candidate');
        }
        this.updateHintButtonState();
        // –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –≤—Å–µ –±–ª–æ–∫–∏ –ø—Ä–∏ –≤—Ö–æ–¥–µ –≤ —Ä–µ–∂–∏–º –≤—ã–±–æ—Ä–∞
        this.centerAllBlocks();
      }

      exitSelectionMode() {
        const boardEl = document.getElementById('board');
        boardEl.classList.remove('dimmed');
        // —Å–Ω—è—Ç—å –∫–ª–∞—Å—Å—ã
        if (this.state.source) this.getCellEl(this.state.source.x, this.state.source.y)?.classList.remove('source');
        for (const {x, y} of this.state.candidates) {
          this.getCellEl(x, y)?.classList.remove('candidate');
        }
        this.state.locked = false;
        this.state.source = null;
        this.state.candidates = [];
        this.updateHintButtonState();
        //this.centerAllBlocks(); –ò–ó–ë–´–¢–û–ß–ù–û ??? 1509
      }
      // === –£–¥–∞–ª–µ–Ω–∏–µ –ø–∞—Ä—ã ===
      removePair(x1, y1, x2, y2) {
        this.board[y1][x1] = null;
        this.board[y2][x2] = null;
        const a = this.getCellEl(x1, y1);
        const b = this.getCellEl(x2, y2);
        // –ü—Ä–∏–º–µ–Ω—è–µ–º —Å–ª—É—á–∞–π–Ω—É—é –∞–Ω–∏–º–∞—Ü–∏—é —É–¥–∞–ª–µ–Ω–∏—è –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –±–ª–æ–∫–∞
        this.animateCellRemoval(a);
        this.animateCellRemoval(b);
        // –§–æ–Ω–æ–≤–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞: –µ—Å—Ç—å –ª–∏ –¥–æ—Å—Ç—É–ø–Ω—ã–µ —Ö–æ–¥—ã, –∏–Ω–∞—á–µ –ø–µ—Ä–µ–º–µ—à–∞—Ç—å
        setTimeout(() => this.checkAndReshuffleIfNoMoves(), 400);
      }
      // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏ —É–¥–∞–ª–µ–Ω–∏—è –±–ª–æ–∫–∞ —Å —Å–ª—É—á–∞–π–Ω—ã–º —ç—Ñ—Ñ–µ–∫—Ç–æ–º
      animateCellRemoval(cell) {
        if (!cell) return;
        // –ú–∞—Å—Å–∏–≤ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∞–Ω–∏–º–∞—Ü–∏–π
        const animations = ['explode', 'fade-out', 'shrink', 'wave-out'];
        // –í—ã–±–∏—Ä–∞–µ–º —Å–ª—É—á–∞–π–Ω—É—é –∞–Ω–∏–º–∞—Ü–∏—é
        const randomAnimation = animations[Math.floor(Math.random() * animations.length)];
        // –ü—Ä–∏–º–µ–Ω—è–µ–º –∞–Ω–∏–º–∞—Ü–∏—é
        cell.classList.add(randomAnimation);
        // –£–±–∏—Ä–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é –∏ –æ—á–∏—â–∞–µ–º —è—á–µ–π–∫—É –ø–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
        const animationDuration = this.getAnimationDuration(randomAnimation);
        setTimeout(() => {
          cell.classList.remove(randomAnimation);
          this.#clearCell(cell);
        }, animationDuration);
      }
      // –ü–æ–ª—É—á–µ–Ω–∏–µ –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –∞–Ω–∏–º–∞—Ü–∏–∏ –≤ –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥–∞—Ö
      getAnimationDuration(animationClass) {
        const durations = {
          'explode': 400,
          'fade-out': 300,
          'shrink': 250,
          'wave-out': 350
        };
        return durations[animationClass] || 300;
      }
      // === –°–±—Ä–æ—Å/–ø–µ—Ä–µ–≥–µ–Ω–µ—Ä–∞—Ü–∏—è ===
      reset() {

        this.exitSelectionMode();
        this.clearSuperHint(true);
        const pinnedPaletteIndex = this.pinnedPaletteIndex;
        this.theme = this.getCurrentThemeColors();
        this.maxColors = Math.min(this.maxColors, this.theme.length);
        this.board = this.generateBoard();
        this.mount();
        // –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –≤—Å–µ –±–ª–æ–∫–∏ –ø–æ—Å–ª–µ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞ //–ó–ê–ö–û–ú–ú–ï–ù–¢–ò–†–û–í–ê–ù–û –î–õ–Ø –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–Ø –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–ò –ù–ê–ì–†–£–ó–ö–ò
        //setTimeout(() => this.centerAllBlocks(), 100);
        //setTimeout(() => this.checkAndReshuffleIfNoMoves(), 50);
        //setTimeout(() => this.updateSettingsDisplay(), 300);
        
        saveGameData();
      }


      // === –§–æ–Ω–æ–≤–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ö–æ–¥–æ–≤ (—É—Å–ª–æ–≤–∏—è A –∏ B) ===

      checkAndReshuffleIfNoMoves() {
        if (this._animatingReshuffle) return;
        if (this.hasAnyAvailablePair()) return;


      if (game.checkLevelCompleted()) {
        const finalTime = document.getElementById("timer").textContent;
        stopTimerOnly();

        if (challengeMode) {
          // üéØ –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–±—ã—Ç–∏–µ –¥–ª—è –∏—Å–ø—ã—Ç–∞–Ω–∏–π
          try {
            const elapsedSeconds = parseTimeToSeconds(finalTime);
            //console.warn("–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ challenge_completed");
            gtag('event', 'challenge_completed', {
              time_spent_sec: elapsedSeconds ?? 0,  // –µ—Å–ª–∏ null ‚Üí 0
              time_spent_str: finalTime,            // —Å—Ç—Ä–æ–∫–∞ –Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π
              board_height: CONFIG.height,
              color_count: CONFIG.maxColors,
              min_pairs: CONFIG.minPair
            });
          } catch (err) {
           // console.warn("‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Å–æ–±—ã—Ç–∏—è challenge_completed");
          }

          showLevelCompleteMessage(finalTime);
        } else {
          // üéØ –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–±—ã—Ç–∏–µ –¥–ª—è –ø—Ä–æ—Å—Ç—ã—Ö —É—Ä–æ–≤–Ω–µ–π
          try {
            //console.warn("–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ level_completed");
            gtag('event', 'level_completed', {
              board_height: CONFIG.height,
              color_count: CONFIG.maxColors,
              min_pairs: CONFIG.minPair
            });
          } catch (err) {
           // console.warn("‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Å–æ–±—ã—Ç–∏—è level_completed");
          }

          game.reset();
          updateEventHandlers();
        }




          return;
        }





        this.showNoMovesMessage();
        setTimeout(() => {
          this.runWaveReshuffle();
        }, 500);
      }


      hasAnyAvailablePair() {
        // –£—Å–ª–æ–≤–∏–µ A: –µ—Å—Ç—å –ø—Ä—è–º–∞—è –ø–∞—Ä–∞ –±–µ–∑ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–π
        for (let y = 0; y < this.height; y++) {
          for (let x = 0; x < this.width; x++) {
            if (this.board[y][x] === null) continue;
            if (this.findNearestBlocksSameColor(x, y).length > 0) return true;
          }
        }
        // –£—Å–ª–æ–≤–∏–µ B: –º–æ–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å –ø–∞—Ä—É –ø–æ—Å–ª–µ –¥–æ–ø—É—Å—Ç–∏–º–æ–≥–æ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è —Ü–µ–ø–æ—á–∫–∏
        return this.canMakePairByMove();
      }

      canMakePairByMove() {
        const dirs = [
          { axis: 'x', step: +1 },
          { axis: 'x', step: -1 },
          { axis: 'y', step: +1 },
          { axis: 'y', step: -1 },
        ];
        for (let y = 0; y < this.height; y++) {
          for (let x = 0; x < this.width; x++) {
            if (this.board[y][x] === null) continue;
            for (const d of dirs) {
              const maxSteps = Math.abs(this.computeAllowedShiftOn(this.board, x, y, d.axis, d.step * 999));
              if (maxSteps <= 0) continue;
              for (let s = 1; s <= maxSteps; s++) {
                const { board: b2, nx, ny } = this.moveChainOn(this.board, x, y, d.axis, d.step * s);
                if (this.findNearestOn(b2, nx, ny).length > 0) return true;
              }
            }
          }
        }
        return false;
      }
      // === –ß–∏—Å—Ç—ã–µ —Ö–µ–ª–ø–µ—Ä—ã –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –Ω–∞ –∫–æ–ø–∏–∏ –ø–æ–ª—è ===
      computeAllowedShiftOn(board, x0, y0, axis, desiredSteps) {
        const width = this.width;
        const height = this.height;
        const sign = Math.sign(desiredSteps);
        if (sign === 0) return 0;
        
        if (x0 < 0 || x0 >= width || y0 < 0 || y0 >= height) return 0;
        
        const limit = Math.abs(desiredSteps);
        if (axis === 'x') {
          const y = y0;
          if (sign > 0) {
            let chainEnd = x0;
            while (chainEnd + 1 < width && board[y][chainEnd + 1] !== null) chainEnd++;
            let empty = 0; 
            let i = chainEnd + 1;
            while (i < width && board[y][i] === null) { 
              empty++; 
              i++; 
            }
            return Math.min(limit, empty) * sign;
          } else {
            let chainStart = x0;
            while (chainStart - 1 >= 0 && board[y][chainStart - 1] !== null) chainStart--;
            let empty = 0; 
            let i = chainStart - 1;
            while (i >= 0 && board[y][i] === null) { 
              empty++; 
              i--; 
            }
            return Math.min(limit, empty) * sign;
          }
        } else {
          const x = x0;
          if (sign > 0) {
            let chainEnd = y0;
            while (chainEnd + 1 < height && board[chainEnd + 1][x] !== null) chainEnd++;
            let empty = 0; 
            let i = chainEnd + 1;
            while (i < height && board[i][x] === null) { 
              empty++; 
              i++; 
            }
            return Math.min(limit, empty) * sign;
          } else {
            let chainStart = y0;
            while (chainStart - 1 >= 0 && board[chainStart - 1][x] !== null) chainStart--;
            let empty = 0; 
            let i = chainStart - 1;
            while (i >= 0 && board[i][x] === null) { 
              empty++; 
              i--; 
            }
            return Math.min(limit, empty) * sign;
          }
        }
      }


       moveChainOn(board, x0, y0, axis, steps) {
        const width = this.width;
        const height = this.height;
        const b = board.map(row => row.slice());
        const sign = Math.sign(steps);
        if (sign === 0) return { board: b, nx: x0, ny: y0, changed: [] };

        const changed = [];

        if (axis === 'x') {
          const y = y0;
          if (sign > 0) {
            let chainEnd = x0;
            while (chainEnd + 1 < width && b[y][chainEnd + 1] !== null) chainEnd++;
            for (let x = chainEnd; x >= x0; x--) {
              const newX = x + steps;
              if (newX < width) {
                b[y][newX] = b[y][x];
                b[y][x] = null;
                changed.push([x, y], [newX, y]);
              }
            }
          } else {
            let chainStart = x0;
            while (chainStart - 1 >= 0 && b[y][chainStart - 1] !== null) chainStart--;
            for (let x = chainStart; x <= x0; x++) {
              const newX = x + steps;
              if (newX >= 0) {
                b[y][newX] = b[y][x];
                b[y][x] = null;
                changed.push([x, y], [newX, y]);
              }
            }
          }
          return { board: b, nx: x0 + steps, ny: y0, changed };
        } else {
          const x = x0;
          if (sign > 0) {
            let chainEnd = y0;
            while (chainEnd + 1 < height && b[chainEnd + 1][x] !== null) chainEnd++;
            for (let y = chainEnd; y >= y0; y--) {
              const newY = y + steps;
              if (newY < height) {
                b[newY][x] = b[y][x];
                b[y][x] = null;
                changed.push([x, y], [x, newY]);
              }
            }
          } else {
            let chainStart = y0;
            while (chainStart - 1 >= 0 && b[chainStart - 1][x] !== null) chainStart--;
            for (let y = chainStart; y <= y0; y++) {
              const newY = y + steps;
              if (newY >= 0) {
                b[newY][x] = b[y][x];
                b[y][x] = null;
                changed.push([x, y], [x, newY]);
              }
            }
          }
          return { board: b, nx: x0, ny: y0 + steps, changed };
        }
      }


      findNearestOn(board, x, y) {
        const width = this.width;
        const height = this.height;
        const color = board[y][x];
        if (color === null) return [];
        
        const dirs = [ [1,0], [-1,0], [0,1], [0,-1] ];
        const found = [];
        
        for (const [dx, dy] of dirs) {
          let cx = x + dx, cy = y + dy;
          while (cx >= 0 && cx < width && cy >= 0 && cy < height) {
            const c = board[cy][cx];
            if (c !== null) {
              if (c === color) {
                found.push({ x: cx, y: cy });
              }
              break;
            }
            cx += dx; 
            cy += dy;
          }
        }
        return found;
      }
      // === –í—Å–ø–ª—ã–≤–∞—é—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ ===
      showNoMovesMessage() {
        const boardEl = document.getElementById('board');
        const msg = document.createElement('div');
        msg.className = 'overlay-message';
        msg.textContent = '–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ö–æ–¥–æ–≤. –ü–µ—Ä–µ–º–µ—à–∏–≤–∞—é.';
        boardEl.appendChild(msg);
        setTimeout(() => { msg.remove(); }, 3000);
      }

 
      // === –í–æ–ª–Ω–æ–≤–∞—è –∞–Ω–∏–º–∞—Ü–∏—è –≤ —Å–µ—Ä—ã–π –∏ –ø–µ—Ä–µ–º–µ—à–∏–≤–∞–Ω–∏–µ ===
      runWaveReshuffle() {
        if (this._animatingReshuffle) return;
        this._animatingReshuffle = true;
        this.state.locked = true;
        this.updateHintButtonState();

        // 1) –ü–ª–∞–Ω–∏—Ä—É–µ–º –Ω–æ–≤–æ–µ —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏–µ (—Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –∫–æ–ª-–≤–∞ —Ü–≤–µ—Ç–æ–≤)
        const newBoard = this.planReshufflePreserveCounts();

        // 2) –í–æ–ª–Ω–∞ "–≤ —Å–µ—Ä—ã–π" –∏–∑ –ª–µ–≤–æ–≥–æ –≤–µ—Ä—Ö–Ω–µ–≥–æ —É–≥–ª–∞
        const steps = [];
        let lastDelay = 0;
        for (let y = 0; y < this.height; y++) {
          for (let x = 0; x < this.width; x++) {
            const el = this.getCellEl(x, y);
            if (!el) continue;
            el.classList.remove("candidate", "source"); // —Å—Ä–∞–∑—É —á–∏—Å—Ç–∏–º
            const delay = (x + y) * 14;
            steps.push({ el, x, y, delay });
            if (delay > lastDelay) lastDelay = delay;
          }
        }

        // 3) –ü—Ä–∏–º–µ–Ω—è–µ–º –Ω–æ–≤—É—é —Ä–∞—Å–∫–ª–∞–¥–∫—É –ø–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è "—Å–µ—Ä–æ–π –≤–æ–ª–Ω—ã"
        setTimeout(() => {
          this.board = newBoard;
          this.theme = this.getCurrentThemeColors();
          this.maxColors = Math.min(this.maxColors, this.theme.length);

          // –ü–æ–¥–≥–æ—Ç–æ–≤–∏—Ç—å DOM: –æ—Å—Ç–∞–≤–∏—Ç—å —Å–µ—Ä—ã–º (activated=0)
          for (let y = 0; y < this.height; y++) {
            for (let x = 0; x < this.width; x++) {
              const el = this.getCellEl(x, y);
              const color = this.board[y][x];
              if (color !== null) {
                el.classList.add("filled");
                el.dataset.colorId = String(color);
                el.dataset.activated = "0";
              } else {
                this.#clearCellImmediate(el);
              }
            }
          }

          // –í–æ–ª–Ω–∞ –≤–∫–ª—é—á–µ–Ω–∏—è (–¥–∏–∞–≥–æ–Ω–∞–ª–∏ –∏–∑ –ª–µ–≤–æ–≥–æ –≤–µ—Ä—Ö–Ω–µ–≥–æ)
          const revealDuration = 1000; // –º–æ–∂–Ω–æ –≤—ã–Ω–µ—Å—Ç–∏ –≤ CONFIG
          this.runInitialReveal(revealDuration);

          // –†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å —Å—Ç—Ä–æ–≥–æ –ø–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≤–æ–ª–Ω—ã
          setTimeout(() => {
            this._animatingReshuffle = false;
            this.state.locked = false;
            this.updateHintButtonState();
            this.centerAllBlocks();
          }, revealDuration + 50);

        }, lastDelay + 30);
      }


      planReshufflePreserveCounts() {
        // –°–æ–±—Ä–∞—Ç—å —Å–ø–∏—Å–æ–∫ —Ü–≤–µ—Ç–æ–≤
        const colors = [];
        for (let y = 0; y < this.height; y++) {
          for (let x = 0; x < this.width; x++) {
            const c = this.board[y][x];
            if (c !== null) colors.push(c);
          }
        }
        const total = this.width * this.height;
        const empties = total - colors.length;
        const cells = [...Array(total).keys()].map(i => ({ x: i % this.width, y: Math.floor(i / this.width) }));

        let attempt = 0;
        const maxAttempts = 300;
        while (attempt++ < maxAttempts) {
          // —Ç–∞—Å—É–µ–º –ø–æ–∑–∏—Ü–∏–∏ –∏ —Ü–≤–µ—Ç–∞
          const shuffledCells = cells.slice().sort(() => Math.random() - 0.5);
          const shuffledColors = colors.slice().sort(() => Math.random() - 0.5);
          const grid = Array.from({ length: this.height }, () => Array(this.width).fill(null));
          let ci = 0;
          for (let i = 0; i < shuffledCells.length; i++) {
            const { x, y } = shuffledCells[i];
            if (i < shuffledColors.length) grid[y][x] = shuffledColors[ci++];
          }
          // –ø—Ä–æ–≤–µ—Ä–∏–º –Ω–∞ –Ω–∞–ª–∏—á–∏–µ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ö–æ–¥–æ–≤
          if (this.hasAnyAvailablePairOn(grid)) return grid;
        }
        // fallback: –µ—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏, –ø—Ä–æ—Å—Ç–æ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –Ω–æ–≤–æ–µ –ø–æ–ª–µ, —Å–æ—Ö—Ä–∞–Ω—è—è –∫–æ–Ω—Ñ–∏–≥
        console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å –±—ã—Å—Ç—Ä–æ –ø–æ–¥–æ–±—Ä–∞—Ç—å —Ä–∞—Å–∫–ª–∞–¥–∫—É, –≥–µ–Ω–µ—Ä–∏—Ä—É—é –Ω–æ–≤–æ–µ –ø–æ–ª–µ.');



        return this.generateBoard();
      }

      hasAnyAvailablePairOn(board) {
        // –£—Å–ª–æ–≤–∏–µ A
        for (let y = 0; y < this.height; y++) {
          for (let x = 0; x < this.width; x++) {
            if (board[y][x] === null) continue;
            if (this.findNearestOn(board, x, y).length > 0) return true;
          }
        }
        // –£—Å–ª–æ–≤–∏–µ B (–Ω–∞ –∫–æ–ø–∏–∏)
        const dirs = [
          { axis: 'x', step: +1 },
          { axis: 'x', step: -1 },
          { axis: 'y', step: +1 },
          { axis: 'y', step: -1 },
        ];
        for (let y = 0; y < this.height; y++) {
          for (let x = 0; x < this.width; x++) {
            if (board[y][x] === null) continue;
            for (const d of dirs) {
              const maxSteps = Math.abs(this.computeAllowedShiftOn(board, x, y, d.axis, d.step * 999));
              if (maxSteps <= 0) continue;
              for (let s = 1; s <= maxSteps; s++) {
                const { board: b2, nx, ny } = this.moveChainOn(board, x, y, d.axis, d.step * s);
                if (this.findNearestOn(b2, nx, ny).length > 0) return true;
              }
            }
          }
        }
        return false;
      }
      // === –ü–æ–¥—Å–∫–∞–∑–∫–∞: –≤—ã—á–∏—Å–ª–µ–Ω–∏–µ –ø–∞—Ä—ã –∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ ===
      bindHintButton() {
        const btn = document.getElementById('hint');
        if (!btn) return;
        this._hintBtn = btn;
        btn.addEventListener('click', () => {
          if (this.state.locked) return; 
          if (performance.now() < this._hintCooldownUntil) return;
          if (this.superHint) return;
          const pair = this.computeHintPair();
          if (!pair) {
            this.checkAndReshuffleIfNoMoves();
            return;
          }
          this.showSuperHint(pair);
        });
        this.updateHintButtonState();
      }

      updateHintButtonState() {
        if (!this._hintBtn) return;
        const disabled = this.state.locked || (performance.now() < this._hintCooldownUntil) || this._animatingReshuffle;
        this._hintBtn.disabled = !!disabled;
        if (performance.now() < this._hintCooldownUntil) this._hintBtn.classList.add('cooldown');
        else this._hintBtn.classList.remove('cooldown');
      }

      startHintCooldown() {
        const cooldownMs = 5000; // 3 —Å–µ–∫—É–Ω–¥—ã
        this._hintCooldownUntil = performance.now() + cooldownMs;
        this.updateHintButtonState();
        setTimeout(() => {
          this.updateHintButtonState();
        }, cooldownMs);
      }


      clearSuperHint(skipBtnUpdate) {
        if (this.superHint) {
          const { a, b } = this.superHint;
          const toClear = [this.getCellEl(a.x, a.y), this.getCellEl(b.x, b.y)].filter(Boolean);

          let idx = 0;
          const batchSize = 8;
          const removeBatch = () => {
            let processed = 0;
            while (idx < toClear.length && processed < batchSize) {
              toClear[idx].classList.remove('hinted-super');
              idx++;
              processed++;
            }
            if (idx < toClear.length) {
              requestAnimationFrame(removeBatch);
            }
          };
          requestAnimationFrame(removeBatch);
        }

        this.superHint = null;

        if (this.state.locked) this.exitSelectionMode();
      }

      showSuperHint(pair) {
        this.clearSuperHint(true);
        this.superHint = pair;

        const toAdd = [this.getCellEl(pair.a.x, pair.a.y), this.getCellEl(pair.b.x, pair.b.y)].filter(Boolean);

        let idx = 0;
        const batchSize = 2;
        const addBatch = () => {
          let processed = 0;
          while (idx < toAdd.length && processed < batchSize) {
            toAdd[idx].classList.add('hinted-super');
            idx++;
            processed++;
          }
          if (idx < toAdd.length) {
            requestAnimationFrame(addBatch);
          }
        };
        requestAnimationFrame(addBatch);

         this.startHintCooldown(); //this.updateHintButtonState();
      }

      computeHintPair() {
        // 1) –°–Ω–∞—á–∞–ª–∞ –∏—â–µ–º –ø—Ä—è–º—É—é –ø–∞—Ä—É (—É—Å–ª–æ–≤–∏–µ A)
        for (let y = 0; y < this.height; y++) {
          for (let x = 0; x < this.width; x++) {
            const color = this.board[y][x];
            if (color === null) continue;
            const cands = this.findNearestBlocksSameColor(x, y);
            if (cands.length > 0) {
              const c = cands[0];
              return { a: { x, y }, b: { x: c.x, y: c.y } };
            }
          }
        }
        // 2) –ï—Å–ª–∏ –Ω–µ—Ç ‚Äî –∏—â–µ–º –ø–∞—Ä—É –ø–æ—Å–ª–µ –¥–æ–ø—É—Å—Ç–∏–º–æ–≥–æ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è (—É—Å–ª–æ–≤–∏–µ B)
        const dirs = [
          { axis: 'x', step: +1 },
          { axis: 'x', step: -1 },
          { axis: 'y', step: +1 },
          { axis: 'y', step: -1 },
        ];
        for (let y = 0; y < this.height; y++) {
          for (let x = 0; x < this.width; x++) {
            if (this.board[y][x] === null) continue;
            for (const d of dirs) {
              const maxSteps = Math.abs(this.computeAllowedShiftOn(this.board, x, y, d.axis, d.step * 999));
              if (maxSteps <= 0) continue;
              const sign = Math.sign(d.step);
              const rng = this.getChainRangeOn(this.board, x, y, d.axis, sign);
              for (let s = 1; s <= maxSteps; s++) {
                const { board: b2, nx, ny } = this.moveChainOn(this.board, x, y, d.axis, d.step * s);
                const near = this.findNearestOn(b2, nx, ny);
                if (near.length > 0) {
                  const p = near[0];
                  // –ù–∞–π—Ç–∏ –∏—Å—Ö–æ–¥–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –ø–∞—Ä—Ç–Ω—ë—Ä–∞, –µ—Å–ª–∏ –æ–Ω –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∞–ª —Å–¥–≤–∏–≥–∞–µ–º–æ–π —Ü–µ–ø–æ—á–∫–µ
                  let bx = p.x, by = p.y;
                  if (d.axis === 'x' && p.y === y && p.x >= rng.from + s && p.x <= rng.to + s) {
                    bx = p.x - d.step * s;
                  }
                  if (d.axis === 'y' && p.x === x && p.y >= rng.from + s && p.y <= rng.to + s) {
                    by = p.y - d.step * s;
                  }
                  return { a: { x, y }, b: { x: bx, y: by } };
                }
              }
            }
          }
        }
        return null;
      }

      getChainRangeOn(board, x0, y0, axis, sign) {
        const width = this.width;
        const height = this.height;
        if (axis === 'x') {
          const y = y0;
          if (sign > 0) {
            let end = x0;
            while (end + 1 < width && board[y][end + 1] !== null) end++;
            return { from: x0, to: end };
          } else {
            let start = x0;
            while (start - 1 >= 0 && board[y][start - 1] !== null) start--;
            return { from: start, to: x0 };
          }
        } else {
          const x = x0;
          if (sign > 0) {
            let end = y0;
            while (end + 1 < height && board[end + 1][x] !== null) end++;
            return { from: y0, to: end };
          } else {
            let start = y0;
            while (start - 1 >= 0 && board[start - 1][x] !== null) start--;
            return { from: start, to: y0 };
          }
        }
      }

      checkLevelCompleted() {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –æ—Å—Ç–∞–ª–∏—Å—å –ª–∏ –∫–∞–∫–∏–µ-—Ç–æ –±–ª–æ–∫–∏
        for (let y = 0; y < this.height; y++) {
          for (let x = 0; x < this.width; x++) {
            if (this.board[y][x] !== null) return false;
          }
        }
        return true;
      }


    }

    let game;
    
    const savedData = loadGameData();
    if (savedData) {
      Object.assign(CONFIG, savedData.config);
      
      THEMES_CUSTOM.length = 0;
      THEMES_CUSTOM.push(...savedData.customPalettes);
      
      game = new Game(CONFIG);
      
      if (savedData.gameState) {
        game.board = savedData.gameState.board;
        game.pinnedPaletteIndex = savedData.gameState.pinnedPaletteIndex;
        game.theme = savedData.gameState.theme;
        game.mount();
        showMessage('–ò–≥—Ä–∞ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –∏–∑ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è', 'success');
      }
    } else {
      game = new Game(CONFIG);
    }
    
    document.addEventListener('fullscreenchange', handleFullscreenChange);
    document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
    document.addEventListener('msfullscreenchange', handleFullscreenChange);


let countdownTimeout = null; // id —Ç–µ–∫—É—â–µ–≥–æ —Ç–∞–π–º–µ—Ä–∞ –æ–±—Ä–∞—Ç–Ω–æ–≥–æ –æ—Ç—Å—á—ë—Ç–∞
let countdownToken = 0; // —Ç–æ–∫–µ–Ω –¥–ª—è –∑–∞—â–∏—Ç—ã –æ—Ç "—É—Å—Ç–∞—Ä–µ–≤—à–∏—Ö" –∑–∞–ø—É—Å–∫–æ–≤

function applyDim() {
  const boardEl = document.getElementById('board');
  boardEl.classList.add("dimmedclone");
  requestAnimationFrame(() => {
    boardEl.classList.add("active");
  });
}

function waitForBoardAnimation(boardEl) {
    return new Promise((resolve) => {
      const cells = boardEl.querySelectorAll(".cell");
      let remaining = cells.length;

      if (remaining === 0) {
        resolve();
        return;
      }

      cells.forEach((cell) => {
        cell.addEventListener("transitionend", function handler(e) {
          if (
            e.propertyName === "background-color" ||
            e.propertyName === "--color"
          ) {
            remaining--;
            cell.removeEventListener("transitionend", handler);
            if (remaining === 0) resolve();
          }
        });
      });
    });
  }
    // –û–±—Ä–∞—Ç–Ω—ã–π –æ—Ç—Å—á—ë—Ç
// –û–±—Ä–∞—Ç–Ω—ã–π –æ—Ç—Å—á—ë—Ç
function startCountdown() {
  const boardEl = document.getElementById("board");

  const overlay = document.createElement("div");
  overlay.id = "countdown-overlay";
  overlay.className = "overlay-countdown";
  boardEl.appendChild(overlay);

  const sequence = ["3", "2", "1", "–ü–æ–µ—Ö–∞–ª–∏!"];
  let index = 0;

  function showNext() {
    if (index >= sequence.length) {
      overlay.remove();
      boardEl.classList.remove("dimmedclone");

      // ‚úÖ –†–∞–∑–±–ª–æ–∫–∏—Ä—É–µ–º back –ø–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ –æ—Ç—Å—á—ë—Ç–∞
      const backBtn = document.getElementById("back"); // ‚úÖ –ø–æ–ª—É—á–∞–µ–º –∫–Ω–æ–ø–∫—É –≤–æ–∑–≤—Ä–∞—Ç–∞
      backBtn.classList.remove("cooldown");

      startTimer();
      countdownTimeout = null; // –æ—á–∏—Å—Ç–∏–ª–∏
      return;
    }

    overlay.textContent = sequence[index];
    overlay.classList.remove("animate"); 
    void overlay.offsetWidth;           
    overlay.classList.add("animate");   

    index++;
    countdownTimeout = setTimeout(showNext, 1000);
  }

  showNext();
}


    function handleFullscreenChange() {
      const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement);
      CONFIG.fullscreen = isFullscreen;
      
      const fullscreenSlider = document.getElementById('fullscreen-slider');
      if (fullscreenSlider) {
        fullscreenSlider.value = isFullscreen ? 1 : 0;
        document.getElementById('settings-fullscreen').textContent = isFullscreen ? '–í–∫–ª—é—á–µ–Ω' : '–í—ã–∫–ª—é—á–µ–Ω';
      }
      
      if (!isFullscreen && CONFIG.fullscreen) {
        //showMessage('–ü–æ–ª–Ω–æ—ç–∫—Ä–∞–Ω–Ω—ã–π —Ä–µ–∂–∏–º –æ—Ç–∫–ª—é—á–µ–Ω', 'info');
      }
    }
    //–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è , –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è
    function updateBoardScale() {
      const root = document.documentElement;
      const styles = getComputedStyle(root);

      const width = parseInt(styles.getPropertyValue('--width'));      // –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–æ–ª–æ–Ω–æ–∫
      const height = parseInt(styles.getPropertyValue('--height'));    // –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å—Ç—Ä–æ–∫
      const padding = parseInt(styles.getPropertyValue('--board-padding'));
      const outerMargin = 5; // –≤–Ω–µ—à–Ω–∏–π –∑–∞–ø–∞—Å –ø–æ –∫—Ä–∞—è–º

      const hud = document.querySelector('.hud');
      const hudHeight = hud ? hud.offsetHeight : 0;

      const game = document.querySelector('.game');
      const rowGap = game ? parseInt(getComputedStyle(game).rowGap) || 0 : 0;

      // –¥–æ—Å—Ç—É–ø–Ω–∞—è —à–∏—Ä–∏–Ω–∞
      const availW = window.innerWidth - 2 * padding - 2 * outerMargin;

      // –¥–æ—Å—Ç—É–ø–Ω–∞—è –≤—ã—Å–æ—Ç–∞ (–º–∏–Ω—É—Å hud, row-gap –∏ –≤–Ω–µ—à–Ω–∏–µ –æ—Ç—Å—Ç—É–ø—ã)
      const availH = window.innerHeight - hudHeight - rowGap - 2 * padding - 2 * outerMargin;

      // —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ: gap = cell / ratio
      const ratio = 12;

      // –≤—ã—á–∏—Å–ª—è–µ–º –≤–æ–∑–º–æ–∂–Ω—ã–µ —Ä–∞–∑–º–µ—Ä—ã
      const cellFromWidth  = availW / (width + (width - 1) / ratio);
      const cellFromHeight = availH / (height + (height - 1) / ratio);

      // –≤—ã–±–∏—Ä–∞–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ (—á—Ç–æ–±—ã —Ç–æ—á–Ω–æ –≤–ª–µ–∑–ª–æ)
      const cell = Math.min(cellFromWidth, cellFromHeight);
      const gap = cell / ratio;

      // –ø—Ä–∏–º–µ–Ω—è–µ–º
      root.style.setProperty('--cell', cell + 'px');
      root.style.setProperty('--gap', gap + 'px');

      // –≤–Ω–µ—à–Ω–∏–π –æ—Ç—Å—Ç—É–ø –ø–æ –±–æ–∫–∞–º
      const board = document.getElementById('board');
      board.style.margin = `${outerMargin}px auto`;
    }

    window.addEventListener('load', updateBoardScale);
    window.addEventListener('resize', updateBoardScale);




    const challengeBtn = document.getElementById("challenge-mode");

    function updateEventHandlers() {
      const resetBtn = document.getElementById("reset");
      const hintBtn = document.getElementById("hint");

      resetBtn.replaceWith(resetBtn.cloneNode(true));
      hintBtn.replaceWith(hintBtn.cloneNode(true));

      const newResetBtn = document.getElementById("reset");
      const newHintBtn = document.getElementById("hint");

      newResetBtn.addEventListener("click", () => {
        game.reset();
      });

      newHintBtn.addEventListener("click", () => {
        if (game.state.locked) return;
        if (performance.now() < game._hintCooldownUntil) return;
        if (game.superHint) return;

        const pair = game.computeHintPair();
        if (!pair) {
          game.checkAndReshuffleIfNoMoves();
          return;
        }
        game.showSuperHint(pair);

        const cooldownMs = 5000; // 5 —Å–µ–∫—É–Ω–¥
        game._hintCooldownUntil = performance.now() + cooldownMs;

        // –ö–Ω–æ–ø–∫–∞ hint ‚Äî –∞–Ω–∏–º–∞—Ü–∏—è –∫—É–ª–¥–∞—É–Ω–∞
        newHintBtn.classList.add("cooldown");
        newHintBtn.style.setProperty("--cooldown-time", cooldownMs + "ms");
        newHintBtn.style.animation = "none";
        newHintBtn.offsetHeight; // reflow
        newHintBtn.style.animation = null;

        // Challenge —Ç–æ–∂–µ –≤ –∫—É–ª–¥–∞—É–Ω
        challengeBtn.classList.add("cooldown");
        challengeBtn.style.setProperty("--cooldown-time", cooldownMs + "ms");
        challengeBtn.style.animation = "none";
        challengeBtn.offsetHeight;
        challengeBtn.style.animation = null;

        // üö© –ö–Ω–æ–ø–∫–∞ challenge —Ç–æ–∂–µ –≤ –∫—É–ª–¥–∞—É–Ω
        challengeBtn.classList.add("cooldown");
        challengeBtn.disabled = true;

        setTimeout(() => {
          newHintBtn.classList.remove("cooldown");

          // –°–Ω–∏–º–∞–µ–º –∫—É–ª–¥–∞—É–Ω —Å challenge
          challengeBtn.classList.remove("cooldown");
          challengeBtn.disabled = false;
        }, cooldownMs);
      });

      window.hintBtn = newHintBtn;
      window.resetBtn = newResetBtn;
    }




    updateEventHandlers();

    window.addEventListener('resize', () => {
      if (game) {
        const maxHeight = game.calculateMaxHeight();
        if (game.height > maxHeight) {
          const pinnedPaletteIndex = game.pinnedPaletteIndex;
          
          CONFIG.height = maxHeight - 1;
          game = new Game(CONFIG);
          
          if (pinnedPaletteIndex >= 0) {
            game.pinnedPaletteIndex = pinnedPaletteIndex;
            game.theme = game.getCurrentThemeColors();
            
            const maxColorsInPalette = game.theme.length;
            if (CONFIG.maxColors > maxColorsInPalette) {
              CONFIG.maxColors = maxColorsInPalette;
              game.maxColors = maxColorsInPalette;
            }
            
            game.board = game.generateBoard();
            game.mount();
            setTimeout(() => game.runInitialReveal(2000), 100);
            
            if (CONFIG.maxColors !== game.maxColors) {
              //showMessage(`–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ü–≤–µ—Ç–æ–≤ –∏–∑–º–µ–Ω–µ–Ω–æ –¥–æ ${game.maxColors}`, 'info');
            }
          }
          
          updateEventHandlers();
        }
      }
    });

    document.getElementById('settings').addEventListener('click', () => {
      openSettings();
    });

    function openSettings() {
      game.updateSettingsDisplay();
      
      const sizeSlider = document.getElementById('size-slider');
      const maxColorsSlider = document.getElementById('maxColors-slider');
      const minPairSlider = document.getElementById('minPair-slider');
      const fullscreenSlider = document.getElementById('fullscreen-slider');
      const saveDataSlider = document.getElementById('saveData-slider');
      
      sizeSlider.oninput = function() {
        const sizes = ['auto', '10√ó10', '10√ó15', '10√ó20'];
        document.getElementById('settings-size').textContent = sizes[this.value];
      };
      
      maxColorsSlider.oninput = function() {
        document.getElementById('settings-maxColors').textContent = this.value;
      };
      
      minPairSlider.oninput = function() {
        document.getElementById('settings-minPair').textContent = this.value;
      };
      
      fullscreenSlider.oninput = function() {
        const isFullscreen = this.value == 1;
        document.getElementById('settings-fullscreen').textContent = isFullscreen ? '–í–∫–ª—é—á–µ–Ω' : '–í—ã–∫–ª—é—á–µ–Ω';
      };
      


      const themeSelector = document.getElementById('theme-selector');
      themeSelector.onchange = function() {
        const selectedTheme = this.value;
        const themeName = AVAILABLE_THEMES[selectedTheme]?.name || '–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é';
        document.getElementById('settings-theme').textContent = themeName;
        
        const customInput = document.getElementById('custom-theme-input');
        if (customInput) {
          customInput.style.display = selectedTheme === 'custom' ? 'block' : 'none';
        }
        
        if (game) {
          game.currentTheme = selectedTheme;

          // üîπ –°–±—Ä–æ—Å –∑–∞–∫—Ä–µ–ø–ª–µ–Ω–∏—è –ø—Ä–∏ —Å–º–µ–Ω–µ —Ç–µ–º—ã
          game.pinnedPaletteIndex = -1;
          game.updateThemePreview();
        }
      };

      const customInput = document.getElementById('custom-colors-input');
      if (customInput) {
        customInput.addEventListener('keydown', function(e) {
          if (e.key === 'Enter' && e.ctrlKey) {
            e.preventDefault();
            addCustomColors();
          }
        });
      }

      document.querySelector('.settings-modal').classList.add('active');

    }

    function closeSettings() {
      document.querySelector('.settings-modal').classList.remove('active');
    }

    document.querySelector('.settings-modal').addEventListener('click', (e) => {
      if (e.target.classList.contains('settings-modal')) {
        closeSettings();
      }
    });


     function applySettings() {
      const sizeSlider = document.getElementById('size-slider');
      const maxColors = parseInt(document.getElementById('settings-maxColors').textContent);
      const minPair = parseInt(document.getElementById('settings-minPair').textContent);
      const selectedTheme = document.getElementById('theme-selector').value;
      const fullscreenSlider = document.getElementById('fullscreen-slider');
      const isFullscreen = fullscreenSlider ? fullscreenSlider.value == 1 : false;

      let width = 10, height = 10;
      if (sizeSlider.value == 0) {
        width = game.width;
        height = game.height;
      } else if (sizeSlider.value == 1) {
        width = 10; height = 10;
      } else if (sizeSlider.value == 2) {
        width = 10; height = 15;
      } else if (sizeSlider.value == 3) {
        width = 10; height = 20;
      }

      const maxHeight = game.calculateMaxHeight();
      if (height > maxHeight) {
        height = maxHeight - 1;
      }

      const pinnedPaletteIndex = game ? game.pinnedPaletteIndex : -1;

      // üîπ –ø—Ä–∏–º–µ–Ω—è–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
      CONFIG.width = width;
      CONFIG.height = height;
      CONFIG.maxColors = maxColors;
      CONFIG.minPair = minPair;
      CONFIG.theme = selectedTheme;
      CONFIG.fullscreen = isFullscreen;

      // —Ñ–ª–∞–≥–∏ –¥–ª—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –±–µ—Ä—ë–º –∏–∑ UI
      CONFIG.useImages = document.getElementById('useImages-slider')?.value === '1';
      CONFIG.currentRoom = document.getElementById('room-selector')?.value || 'room1';

      // –æ—á–∏—â–∞–µ–º –∫–µ—à blob-—Å—Å—ã–ª–æ–∫ –ø—Ä–∏ —Å–º–µ–Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–∫
      if (game && game.clearImageUrlCache) {
        game.clearImageUrlCache();
      }

      game = new Game(CONFIG);

      if (pinnedPaletteIndex >= 0) {
        game.pinnedPaletteIndex = pinnedPaletteIndex;
        game.theme = game.getCurrentThemeColors();

        const maxColorsInPalette = game.theme.length;
        if (maxColors > maxColorsInPalette) {
          CONFIG.maxColors = maxColorsInPalette;
          game.maxColors = maxColorsInPalette;
          showMessage(`–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ü–≤–µ—Ç–æ–≤ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–æ ${game.maxColors}`, 'info');
        } else {
          CONFIG.maxColors = maxColors;
          game.maxColors = maxColors;
        }
        game.redrawAll()
        game.board = game.generateBoard();
        game.mount();
        setTimeout(() => game.runInitialReveal(2000), 100);
      }

// üîπ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–µ–≥ –∫–æ–º–Ω–∞—Ç—ã –≤ gtag
if (typeof gtag === "function") {
  gtag('config', 'G-PYJ5SM4Z1Y', {
    'page_path': '/' + CONFIG.currentRoom
  });
}


      updateEventHandlers();
      saveGameData();
      closeSettings();

    }


    function addCustomColors() {
      const input = document.getElementById('custom-colors-input');
      const colorsText = input.value.trim();
      
      if (!colorsText) {
        showMessage('–í–≤–µ–¥–∏—Ç–µ —Ü–≤–µ—Ç–∞ –≤ —Ñ–æ—Ä–º–∞—Ç–µ #xxxxxx, #xxxxxx, ...', 'error');
        return;
      }
      
      const colorRegex = /#[0-9A-Fa-f]{6}/g;
      const colors = colorsText.match(colorRegex);
      
      if (!colors || colors.length === 0) {
        showMessage('–í–≤–µ–¥–∏—Ç–µ —Ü–≤–µ—Ç–∞ –≤ —Ñ–æ—Ä–º–∞—Ç–µ #xxxxxx, #xxxxxx, ...', 'error');
        return;
      }
      
      THEMES_CUSTOM.push(colors);
      
      if (game) {
        game.updateThemePreview();
      }
      
      input.value = '';
      
      const message = `–î–æ–±–∞–≤–ª–µ–Ω–æ ${colors.length} —Ü–≤–µ—Ç–æ–≤ –≤ –ø–∞–ª–∏—Ç—Ä—É ${THEMES_CUSTOM.length}`;
      showMessage(message);
      
      saveGameData();
    }

    function clearCustomTheme() {
      const input = document.getElementById('custom-colors-input');
      if (input) {
        input.value = '';
      }
      
      showMessage('–ü–æ–ª–µ –≤–≤–æ–¥–∞ –æ—á–∏—â–µ–Ω–æ');
    }

    function showMessage(text, type = 'success') {
      const message = document.createElement('div');
      let bgColor, textColor;
      
      switch (type) {
        case 'error':
          bgColor = '#ff4444';
          textColor = '#ffffff';
          break;
        case 'info':
          bgColor = '#4a90e2';
          textColor = '#ffffff';
          break;
        default: 
          bgColor = '#64e0d0';
          textColor = '#0f1522';
          break;
      }
      
      message.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: ${bgColor};
        color: ${textColor};
        padding: 12px 16px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 500;
        z-index: 10000;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        animation: slideIn 0.3s ease-out;
        max-width: 300px;
        word-wrap: break-word;
      `;
      message.textContent = text;
      
      const style = document.createElement('style');
      style.textContent = `
        @keyframes slideIn {
          from { transform: translateX(100%); opacity: 0; }
          to { transform: translateX(0); opacity: 1; }
        }
      `;
      document.head.appendChild(style);
      
      document.body.appendChild(message);
      
      setTimeout(() => {
        message.style.animation = 'slideOut 0.3s ease-in';
        message.style.transform = 'translateX(100%)';
        message.style.opacity = '0';
        setTimeout(() => {
          document.body.removeChild(message);
          document.head.removeChild(style);
        }, 300);
      }, 3000);
    }
document.addEventListener("DOMContentLoaded", () => {
    // --- —ç–ª–µ–º–µ–Ω—Ç—ã ---
  const boardEl = document.getElementById("board");
  const challengeBtn = document.getElementById("challenge-mode");
  const backBtn = document.getElementById("back");
  const hintBtn = document.getElementById("hint");

  const settingsBtn = document.getElementById("settings");
  const resetBtn = document.getElementById("reset");

  const timerEl = document.getElementById("timer");
  const startBtn = document.getElementById("start-challenge");

  const gameContainer = document.querySelector('.game'); // —Ä–æ–¥–∏—Ç–µ–ª—å, —Ä–µ–¥–∫–æ –∑–∞–º–µ–Ω—è–µ—Ç—Å—è

    // –≠—Ç–∏ —ç–ª–µ–º–µ–Ω—Ç—ã –º–æ–≥—É—Ç –±—ã—Ç—å –∫–ª–æ–Ω–∏—Ä–æ–≤–∞–Ω—ã/–∑–∞–º–µ–Ω–µ–Ω—ã —Ñ—É–Ω–∫—Ü–∏–µ–π updateEventHandlers,
  // –ø–æ—ç—Ç–æ–º—É –≤ –º–µ—Å—Ç–∞—Ö, –≥–¥–µ –∫—Ä–∏—Ç–∏—á–Ω–æ, –º—ã –∑–∞–Ω–æ–≤–æ —á–∏—Ç–∞–µ–º –∏—Ö —á–µ—Ä–µ–∑ getElementById.
  const settingsId = "settings";
  const resetId = "reset";
  const hintId = "hint";


// --- —Ç–∞–π–º–µ—Ä ---
  let timerInterval = null;
  let startTime = 0;



function removeDim() {
  const boardEl = document.getElementById('board');
  boardEl.classList.remove("active");
  boardEl.classList.remove("dimmedclone");
}


    function activateChallengeMode() {
      settingsBtn.classList.add('hidden');
      resetBtn.classList.add('hidden');
      hintBtn.classList.add('hidden');
      document.getElementById("hint").classList.add('hidden');
      document.getElementById("reset").classList.add('hidden');
      challengeBtn.classList.add('hidden');
      backBtn.classList.remove('hidden');
      timerEl.classList.remove('hidden');

      challengeMode = true;
      game.reset();
      applyDim();
      updateEventHandlers();

      const myToken = ++countdownToken; // –Ω–æ–≤—ã–π —Ç–æ–∫–µ–Ω –¥–ª—è —ç—Ç–æ–π –ø–æ–ø—ã—Ç–∫–∏

      waitForBoardAnimation(document.getElementById("board")).then(() => {
        // –∑–∞–ø—É—Å–∫–∞–µ–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —Ç–æ–∫–µ–Ω –Ω–µ —É—Å—Ç–∞—Ä–µ–ª –∏ –º—ã –≤—Å—ë –µ—â—ë –≤ —Ä–µ–∂–∏–º–µ –∏—Å–ø—ã—Ç–∞–Ω–∏—è
        if (challengeMode && myToken === countdownToken) {
          startCountdown();
        }
      });
    }



 
    // –ö–Ω–æ–ø–∫–∞ –≤–∫–ª—é—á–µ–Ω–∏—è —Ä–µ–∂–∏–º–∞
    challengeBtn.addEventListener("click", () => {
      if (challengeBtn.classList.contains("cooldown")) return; // –∑–∞—â–∏—Ç–∞

      activateChallengeMode();

      const cooldownMs = 5000;

      // Challenge –≤ –∫—É–ª–¥–∞—É–Ω
      challengeBtn.classList.add("cooldown");
      challengeBtn.style.setProperty("--cooldown-time", cooldownMs + "ms");
      challengeBtn.style.animation = "none";
      challengeBtn.offsetHeight; // reflow
      challengeBtn.style.animation = null;

      // Back –≤ –∫—É–ª–¥–∞—É–Ω (–∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω –º–∏–Ω–∏–º—É–º –Ω–∞ –≤—Ä–µ–º—è –æ—Ç—Å—á—ë—Ç–∞!)
      backBtn.classList.add("cooldown");
      backBtn.style.setProperty("--cooldown-time", cooldownMs + "ms");
      backBtn.style.animation = "none";
      backBtn.offsetHeight;
      backBtn.style.animation = null;

      // –°–Ω–∏–º–∞–µ–º –∫—É–ª–¥–∞—É–Ω challenge —á–µ—Ä–µ–∑ 5—Å
      setTimeout(() => {
        challengeBtn.classList.remove("cooldown");
        // backBtn –ù–ï —Å–Ω–∏–º–∞–µ–º —Ç—É—Ç ‚Äî –µ–≥–æ —Å–Ω–∏–º–∞–µ—Ç startCountdown()
      }, cooldownMs);
    });


    backBtn.addEventListener("click", () => {
      challengeMode = false;
      countdownToken++; // –∏–Ω–≤–∞–ª–∏–¥–∏—Ä—É–µ–º –≤—Å–µ –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –æ—Ç—Å—á—ë—Ç—ã

      if (countdownTimeout) {
        clearTimeout(countdownTimeout);
        countdownTimeout = null;
      }

      // ‚úÖ –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –æ–∫–Ω–æ "–ò—Å–ø—ã—Ç–∞–Ω–∏–µ –ø—Ä–æ–π–¥–µ–Ω–æ"
      const levelCompleteOverlay = document.getElementById("level-complete");
      if (levelCompleteOverlay) {
        levelCompleteOverlay.remove();

        // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –Ω–æ–≤—É—é –¥–æ—Å–∫—É
        game.reset();
        updateEventHandlers();
      }

      // ‚úÖ –ó–∞–∫—Ä—ã–≤–∞–µ–º –æ–≤–µ—Ä–ª–µ–π –æ–±—Ä–∞—Ç–Ω–æ–≥–æ –æ—Ç—Å—á—ë—Ç–∞, –µ—Å–ª–∏ –±—ã–ª
      const countdownOverlay = document.getElementById("countdown-overlay");
      if (countdownOverlay) countdownOverlay.remove();

      settingsBtn.classList.remove("hidden");
      document.getElementById("reset").classList.remove("hidden");
      document.getElementById("hint").classList.remove("hidden");

      backBtn.classList.add("hidden");
      timerEl.classList.add("hidden");
      challengeBtn.classList.remove("hidden");

      const boardEl = document.getElementById("board");
      boardEl.classList.remove("dimmedclone");

      stopAndResetTimer();
    });


    });
let timerInterval = null;
let startTime = 0;


function startTimer() {
  if (timerInterval) return; // —á—Ç–æ–±—ã –Ω–µ –∑–∞–ø—É—Å–∫–∞—Ç—å –ø–æ–≤—Ç–æ—Ä–Ω–æ

  startTime = performance.now();
  timerInterval = setInterval(updateTimer, 1000); // –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–∞–∂–¥—É—é 1ms
}

function stopAndResetTimer() {
  clearInterval(timerInterval);
  timerInterval = null;
  document.getElementById("timer").textContent = "00:00";
}

function updateTimer() {
  const timerEl = document.getElementById("timer");
  const now = performance.now();
  const elapsed = now - startTime;

  const minutes = Math.floor(elapsed / 60000);
  const seconds = Math.floor((elapsed % 60000) / 1000);
  //const milliseconds = Math.floor(elapsed % 1000);

  timerEl.textContent =
    String(minutes).padStart(2, "0") +
    ":" +
    String(seconds).padStart(2, "0")// +
    //":" +
    //String(milliseconds).padStart(3, "0");
}






function showLevelCompleteMessage(finalTime) {
  if (!challengeMode) return;

  const boardEl = document.getElementById("board");

  if (document.getElementById("level-complete")) return;

  const overlay = document.createElement("div");
  overlay.id = "level-complete";
  overlay.className = "overlay-level";

  const title = document.createElement("div");
  title.className = "overlay-level-title";
  title.textContent = "–ò—Å–ø—ã—Ç–∞–Ω–∏–µ –ø—Ä–æ–π–¥–µ–Ω–æ";

  const time = document.createElement("div");
  time.className = "overlay-level-time";
  time.textContent = `–í—Ä–µ–º—è: ${finalTime}`;

  // –±–ª–æ–∫ —Å –¥–æ–ø. –∏–Ω—Ñ–æ–π
  const info = document.createElement("div");
  info.className = "overlay-level-info";
  info.innerHTML = `
    <div>–†–∞–∑–º–µ—Ä –ø–æ–ª—è: ${CONFIG.width} x ${CONFIG.height}</div>
    <div>–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ü–≤–µ—Ç–æ–≤: ${CONFIG.maxColors}</div>
    <div>–ú–∏–Ω–∏–º—É–º –ø–∞—Ä: ${CONFIG.minPair}</div>
  `;

  const okBtn = document.createElement("button");
  okBtn.className = "overlay-level-btn";
  okBtn.textContent = "–û–ö";

  okBtn.addEventListener("click", () => {
    overlay.remove();
    stopAndResetTimer();

    game.reset();
    updateEventHandlers();

    applyDim();

    // üö© –Ø–≤–Ω–æ –±–µ—Ä—ë–º –∫–Ω–æ–ø–∫—É Back –∏–∑ DOM
    const backBtn = document.getElementById("back");
    if (backBtn) {
      backBtn.classList.add("cooldown");
      //backBtn.style.setProperty("--cooldown-time", "3000ms"); // –º–æ–∂–Ω–æ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Å 3..2..1
      backBtn.style.animation = "none";
      backBtn.offsetHeight;
      backBtn.style.animation = null;
    }

    waitForBoardAnimation(boardEl).then(() => {
      startCountdown(); // –≤–Ω—É—Ç—Ä–∏ –Ω–µ–≥–æ —Ä–∞–∑–±–ª–æ–∫–∏—Ä—É–µ–º back
    });
  });


  overlay.appendChild(title);
  overlay.appendChild(time);
  overlay.appendChild(info);
  overlay.appendChild(okBtn);
  boardEl.appendChild(overlay);
}






function stopTimerOnly() {
  clearInterval(timerInterval);
  timerInterval = null;
}



  </script>
  

  <script>
if ("serviceWorker" in navigator) {
  navigator.serviceWorker.register("/onet/service-worker.js")
    .then(() => console.log("Service Worker –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω"))
    .catch(err => console.error("–û—à–∏–±–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ SW:", err));
}



</script>


</body>

</html>


